<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/30/hello-world/</url>
    <content><![CDATA[<p>这篇文章主要用来测试自己的博客。检测搭建的博客是否有问题。</p>
<p>主要测试排版以及数学公式的使用。</p>
<a id="more"></a>
<h4 id="cpp代码块"><a href="#cpp代码块" class="headerlink" title="cpp代码块"></a><code>cpp</code>代码块</h4><p>下面测试一下博客的代码块功能，不关注语法高亮。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello,World!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mathjax公式块"><a href="#mathjax公式块" class="headerlink" title="mathjax公式块"></a><code>mathjax</code>公式块</h4><h5 id="行间公式"><a href="#行间公式" class="headerlink" title="行间公式"></a>行间公式</h5><p>测试在<code>markdown</code>文档中插入独占一行的公式。</p>
<script type="math/tex; mode=display">
\frac{x}{y} = cos(x_{1}+x_{1}^{2})</script><h5 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h5><p>测试在<code>markdown</code>文档中嵌入文章内的公式。</p>
<p>公式前 $\frac{x}{y} = cos(x_{1}+x_{1}^{2})$ 公式后。</p>
<h4 id="rust代码块"><a href="#rust代码块" class="headerlink" title="rust代码块"></a><code>rust</code>代码块</h4><p>下面测试以下<code>rust</code>代码的代码块。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,<span class="string">"Hello,World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣周赛186</title>
    <url>/2020/04/30/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B186/</url>
    <content><![CDATA[<p>鄙文章是第186场周赛的题目解答。题目个数仍然是四个。四个小题的分数分别是：</p>
<ol>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/maximum-score-after-splitting-a-string/" target="_blank" rel="noopener">分割字符串的最大得分</a> : 3 分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/maximum-points-you-can-obtain-from-cards/" target="_blank" rel="noopener">可获得的最大点数</a> :  4分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/diagonal-traverse-ii/" target="_blank" rel="noopener">对角线遍历 II</a> : 5分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/constrained-subsequence-sum/" target="_blank" rel="noopener">带限制的子序列和</a> : 6分</li>
</ol>
<a id="more"></a>
<h3 id="分割字符串的最大得分"><a href="#分割字符串的最大得分" class="headerlink" title="分割字符串的最大得分"></a><a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/maximum-score-after-splitting-a-string/" target="_blank" rel="noopener">分割字符串的最大得分</a></h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给你一个由若干 0 和 1 组成的字符串 <code>s</code> ，请你计算并返回将该字符串分割成两个 <strong>非空</strong> 子字符串（即 <strong>左</strong> 子字符串和 <strong>右</strong> 子字符串）所能获得的最大得分。</p>
<p>「分割字符串的得分」为 <strong>左</strong> 子字符串中 <strong>0</strong> 的数量加上 <strong>右</strong> 子字符串中 <strong>1</strong> 的数量。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;011101&quot;</span><br><span class="line">输出：5 </span><br><span class="line">解释：</span><br><span class="line">将字符串 s 划分为两个非空子字符串的可行方案有：</span><br><span class="line">左子字符串 &#x3D; &quot;0&quot; 且 右子字符串 &#x3D; &quot;11101&quot;，得分 &#x3D; 1 + 4 &#x3D; 5 </span><br><span class="line">左子字符串 &#x3D; &quot;01&quot; 且 右子字符串 &#x3D; &quot;1101&quot;，得分 &#x3D; 1 + 3 &#x3D; 4 </span><br><span class="line">左子字符串 &#x3D; &quot;011&quot; 且 右子字符串 &#x3D; &quot;101&quot;，得分 &#x3D; 1 + 2 &#x3D; 3 </span><br><span class="line">左子字符串 &#x3D; &quot;0111&quot; 且 右子字符串 &#x3D; &quot;01&quot;，得分 &#x3D; 1 + 1 &#x3D; 2 </span><br><span class="line">左子字符串 &#x3D; &quot;01110&quot; 且 右子字符串 &#x3D; &quot;1&quot;，得分 &#x3D; 2 + 1 &#x3D; 3</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;00111&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：当 左子字符串 &#x3D; &quot;00&quot; 且 右子字符串 &#x3D; &quot;111&quot; 时，我们得到最大得分 &#x3D; 2 + 3 &#x3D; 5</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;1111&quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>要找到一个分割点，这个分割点将字符串<code>s</code>分为两个<strong>非空</strong>的子串。按照题目要求遍历所有的可能分割点，求每个分割点的得分并取最大值。</p>
<h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(item ==<span class="string">'1'</span>) cnt++;	<span class="comment">// 整个串中'1'的个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> tcnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n<span class="number">-1</span>);i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'1'</span>) tcnt+=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 左串'0'的个数为(i+1-tcnt)</span></span><br><span class="line">            <span class="comment">// 右串'1'的个数为(cnt-tcnt)</span></span><br><span class="line">            res = <span class="built_in">max</span>(res,i+<span class="number">1</span>-tcnt+cnt-tcnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="可获得的最大点数"><a href="#可获得的最大点数" class="headerlink" title="可获得的最大点数"></a><a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/maximum-points-you-can-obtain-from-cards/" target="_blank" rel="noopener">可获得的最大点数</a></h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>几张卡牌 <strong>排成一行</strong>，每张卡牌都有一个对应的点数。点数由整数数组 <code>cardPoints</code> 给出。</p>
<p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 <code>k</code> 张卡牌。</p>
<p>你的点数就是你拿到手中的所有卡牌的点数之和。</p>
<p>给你一个整数数组 <code>cardPoints</code> 和整数 <code>k</code>，请你返回可以获得的最大点数。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：cardPoints &#x3D; [1,2,3,4,5,6,1], k &#x3D; 3</span><br><span class="line">输出：12</span><br><span class="line">解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 &#x3D; 12 。</span><br><span class="line"></span><br><span class="line">输入：cardPoints &#x3D; [2,2,2], k &#x3D; 2</span><br><span class="line">输出：4</span><br><span class="line">解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。</span><br><span class="line"></span><br><span class="line">输入：cardPoints &#x3D; [9,7,7,9,7,7,9], k &#x3D; 7</span><br><span class="line">输出：55</span><br><span class="line">解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。</span><br></pre></td></tr></table></figure>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>由于只能从两端取元素，最终只能是左侧取$cnt(0 \le cnt \le k)$个元素，右侧取$k-cnt$个元素，枚举$cnt$的所有可能取值，并更新最大得分。</p>
<h4 id="实现示例-1"><a href="#实现示例-1" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cp, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = cp.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-k;i&lt;n;i++)&#123;</span><br><span class="line">            r+=cp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;<span class="comment">// 左侧取(i+1)个元素</span></span><br><span class="line">            l+=cp[i];   <span class="comment">// 左侧得分</span></span><br><span class="line">            r-=cp[n-k+i];   <span class="comment">// 右侧得分</span></span><br><span class="line">            res = max(res,l+r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="对角线遍历-II"><a href="#对角线遍历-II" class="headerlink" title="对角线遍历 II"></a><a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/diagonal-traverse-ii/" target="_blank" rel="noopener">对角线遍历 II</a></h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>给你一个列表 <code>nums</code> ，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 <code>nums</code> 中对角线上的整数。</p>
<p><img src="/2020/04/30/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B186/sample_1_1784.png" alt="11"></p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,4,2,7,5,3,8,6,9]</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]</span><br><span class="line">输出：[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [[1,2,3],[4],[5,6,7],[8],[9,10,11]]</span><br><span class="line">输出：[1,4,2,5,3,8,6,9,7,10,11]</span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>元素的访问顺序是按照位置(0,0)的<code>bfs</code>遍历来的，并且下面的元素优先。因此按照<code>bfs</code>的思路遍历即可。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dir =&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">deque</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; que;</span><br><span class="line">        que.push_back(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        res.push_back(nums[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> m = nums.size();</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> tm = que.size();</span><br><span class="line">            <span class="keyword">while</span>(tm--)&#123;</span><br><span class="line">                <span class="keyword">auto</span> p = que.front();</span><br><span class="line">                que.pop_front();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = p.first+dir[i][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y = p.second+dir[i][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(x&gt;=m || y&gt;=nums[x].size() || nums[x][y]==<span class="number">0</span>)&#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line">                    que.push_back(&#123;x,y&#125;);</span><br><span class="line">                    res.push_back(nums[x][y]);</span><br><span class="line">                    nums[x][y] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="带限制的子序列和"><a href="#带限制的子序列和" class="headerlink" title="带限制的子序列和"></a><a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/constrained-subsequence-sum/" target="_blank" rel="noopener">带限制的子序列和</a></h3><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回 <strong>非空</strong> 子序列元素和的最大值，子序列需要满足：子序列中每两个 <strong>相邻</strong> 的整数 <code>nums[i]</code> 和 <code>nums[j]</code> ，它们在原数组中的下标 <code>i</code> 和 <code>j</code> 满足 <code>i &lt; j</code> 且 <code>j - i &lt;= k</code> 。</p>
<p>数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [10,2,-10,5,20], k &#x3D; 2</span><br><span class="line">输出：37</span><br><span class="line">解释：子序列为 [10, 2, 5, 20] 。</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [-1,-2,-3], k &#x3D; 1</span><br><span class="line">输出：-1</span><br><span class="line">解释：子序列必须是非空的，所以我们选择最大的数字。</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [10,-2,-10,-5,20], k &#x3D; 2</span><br><span class="line">输出：23</span><br><span class="line">解释：子序列为 [10, -2, -5, 20] 。</span><br></pre></td></tr></table></figure>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>设前$n$个元素的结果为$dp[n]$（包含第$n$个元素）,思考以下$dp[n]$与$dp[1],dp[2]…dp[n-1]$之间的递推关系。</p>
<p>明显可以得到：$dp[n] = max(dp[n-k]…dp[n-1])+nums[n-1]$。因此通过朴素的$dp$思路可以求得结果。但是提交会超时，那么，如何优化呢？</p>
<p>由上面的$dp$的递推方程可以看到，只要能快速获得前$k$个元素的最大值,那么$dp[n]$就可以很快的得到。</p>
<p>获得一个区间内的最大元素可以使用<code>线段树</code>来实现。</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegTree</span>&#123;</span>	<span class="comment">// 线段树</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree;</span><br><span class="line">    SegTree(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        t=nums;</span><br><span class="line">        <span class="keyword">int</span> n =t.<span class="built_in">size</span>();</span><br><span class="line">        tree=<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span> * n+<span class="number">1</span>,<span class="number">-1e5</span><span class="number">-1</span>);</span><br><span class="line">        buildTree(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = t.<span class="built_in">size</span>();</span><br><span class="line">        updateTree(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,i,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n =t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> query(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e,<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;e) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(s==e)&#123;</span><br><span class="line">            tree[node]=t[s];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (s+e)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> l_n = <span class="number">2</span> * node +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r_n = <span class="number">2</span> * node +<span class="number">2</span>;</span><br><span class="line">        buildTree(s,m,l_n);</span><br><span class="line">        buildTree(m+<span class="number">1</span>,e,r_n);</span><br><span class="line">        tree[node]= <span class="built_in">max</span>(tree[l_n],tree[r_n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateTree</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e,<span class="keyword">int</span> node,<span class="keyword">int</span> idx,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==e)&#123;</span><br><span class="line">            tree[node]=<span class="built_in">max</span>(tree[node],val);</span><br><span class="line">            t[idx]=val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (s+e)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> l_n=<span class="number">2</span>*node+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r_n = <span class="number">2</span> * node+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx&gt;=s &amp;&amp; idx &lt;= m)&#123;</span><br><span class="line">            updateTree(s,m,l_n,idx,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            updateTree(m+<span class="number">1</span>,e,r_n,idx,val);</span><br><span class="line">        &#125;</span><br><span class="line">        tree[node]= <span class="built_in">max</span>(tree[l_n],tree[r_n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e,<span class="keyword">int</span> node,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;s||l&gt;e) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s&gt;=l&amp;&amp;e&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">return</span> tree[node];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (s+e)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> l_n = <span class="number">2</span> * node +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r_n = <span class="number">2</span> * node +<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> ls = query(s, m,l_n,l, r);</span><br><span class="line">        <span class="keyword">int</span> rs = query(m+<span class="number">1</span>,e,r_n,l,r);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ls,rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">constrainedSubsetSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> tree = SegTree(nums);</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        tree.update(<span class="number">0</span>,nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="built_in">max</span>(i-k,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> item = <span class="built_in">max</span>(<span class="number">0</span>,tree.sumRange(l,i<span class="number">-1</span>));</span><br><span class="line">            res = <span class="built_in">max</span>(res,item+nums[i]);</span><br><span class="line">            tree.update(i,item+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>题目本身难度不算太大，但自己对线段树的写法还不是特别熟练，因此在第4题上遇到了一点问题。第3题也超时了一次，总的来说是做题要保持做题的手感，不然很难写出bug free的代码。</p>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣周赛191</title>
    <url>/2020/05/31/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B191/</url>
    <content><![CDATA[<p>这篇文章主要记录一下第191场周赛的题目解答。以下是四个题目:</p>
<ol>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-191/problems/maximum-product-of-two-elements-in-an-array/" target="_blank" rel="noopener">数组中两元素的最大乘积</a></li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-191/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/" target="_blank" rel="noopener">切割后面积最大的蛋糕</a></li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-191/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/" target="_blank" rel="noopener">重新规划路线</a></li>
<li>待补(还不会啊，哈哈哈)</li>
</ol>
<a id="more"></a>
<h3 id="数组中两元素的最大乘积"><a href="#数组中两元素的最大乘积" class="headerlink" title="数组中两元素的最大乘积"></a><a href="https://leetcode-cn.com/contest/weekly-contest-191/problems/maximum-product-of-two-elements-in-an-array/" target="_blank" rel="noopener">数组中两元素的最大乘积</a></h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给你一个整数数组 <code>nums</code>，请你选择数组的两个不同下标 <code>i</code> 和 <code>j</code><em>，</em>使 <code>(nums[i]-1)*(nums[j]-1)</code> 取得最大值。</p>
<p>请你计算并返回该式的最大值。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,5,2]</span><br><span class="line">输出：12 </span><br><span class="line">解释：如果选择下标 i&#x3D;1 和 j&#x3D;2（下标从 0 开始），则可以获得最大值，(nums[1]-1)*(nums[2]-1) &#x3D; (4-1)*(5-1) &#x3D; 3*4 &#x3D; 12 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,5,4,5]</span><br><span class="line">输出：16</span><br><span class="line">解释：选择下标 i&#x3D;1 和 j&#x3D;3（下标从 0 开始），则可以获得最大值 (5-1)*(5-1) &#x3D; 16 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,7]</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">2 &lt;&#x3D; nums.length &lt;&#x3D; 500</span><br><span class="line">1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^3</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>题意是找两个数，使之“乘积“最大。可考虑贪心，选最大的两个，或者选取最小的两个(都是负数，这个题都是正数)。获取最值可以通过排序，也可以通过优先队列来找到。</p>
<h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> (nums[n<span class="number">-1</span>]<span class="number">-1</span>) * (nums[n<span class="number">-2</span>]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="切割后面积最大的蛋糕"><a href="#切割后面积最大的蛋糕" class="headerlink" title="切割后面积最大的蛋糕"></a><a href="https://leetcode-cn.com/contest/weekly-contest-191/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/" target="_blank" rel="noopener">切割后面积最大的蛋糕</a></h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>矩形蛋糕的高度为 <code>h</code> 且宽度为 <code>w</code>，给你两个整数数组 <code>horizontalCuts</code> 和 <code>verticalCuts</code>，其中 <code>horizontalCuts[i]</code> 是从矩形蛋糕顶部到第 <code>i</code> 个水平切口的距离，类似地， <code>verticalCuts[j]</code> 是从矩形蛋糕的左侧到第 <code>j</code> 个竖直切口的距离。</p>
<p>请你按数组 <code>horizontalCuts</code> 和 <code>verticalCuts</code> 中提供的水平和竖直位置切割后，请你找出 <strong>面积最大</strong> 的那份蛋糕，并返回其 <strong>面积</strong> 。由于答案可能是一个很大的数字，因此需要将结果对 <code>10^9 + 7</code> 取余后返回。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p><img src="/2020/05/31/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B191/leetcode_max_area_2.png" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：h &#x3D; 5, w &#x3D; 4, horizontalCuts &#x3D; [1,2,4], verticalCuts &#x3D; [1,3]</span><br><span class="line">输出：4 </span><br><span class="line">解释：上图所示的矩阵蛋糕中，红色线表示水平和竖直方向上的切口。切割蛋糕后，绿色的那份蛋糕面积最大。</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/31/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B191/leetcode_max_area_3.png" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：h &#x3D; 5, w &#x3D; 4, horizontalCuts &#x3D; [3,1], verticalCuts &#x3D; [1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上图所示的矩阵蛋糕中，红色线表示水平和竖直方向上的切口。切割蛋糕后，绿色和黄色的两份蛋糕面积最大。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：h &#x3D; 5, w &#x3D; 4, horizontalCuts &#x3D; [3], verticalCuts &#x3D; [3]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>贪心思想:选取最大<code>y</code>（横向最大长度）,最大<code>x</code>(纵向最大长度)。那么咋求这个最大长度呢。</p>
<p>以横向为例，我们可以看到纵向的相连的两刀的间距是一个可能的<code>x</code>,即两元素的差值。</p>
<p>问：如何处理左右边界上的<code>x</code>呢?</p>
<blockquote>
<p>明显：左侧边界为<code>verticalCuts[0]-0</code>,右侧为<code>n - verticalCuts[n-1]</code>。</p>
</blockquote>
<p>上面的边界可以单独处理，也可以将元素<code>0</code>与<code>n</code>作为一刀，插入<code>verticalCuts</code></p>
<h4 id="实现示例-1"><a href="#实现示例-1" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> w, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; hc, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vc)</span> </span>&#123;</span><br><span class="line">        hc.push_back(<span class="number">0</span>);</span><br><span class="line">        hc.push_back(h);</span><br><span class="line">        vc.push_back(<span class="number">0</span>);</span><br><span class="line">        vc.push_back(w);</span><br><span class="line">        sort(hc.<span class="built_in">begin</span>(),hc.<span class="built_in">end</span>());</span><br><span class="line">        sort(vc.<span class="built_in">begin</span>(),vc.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> n = hc.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            x = <span class="built_in">max</span>(x,hc[i]-hc[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        n = vc.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            y = <span class="built_in">max</span>(y,vc[i]-vc[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1l</span>l * x * y) %MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意题目中结果可能溢出，所以用<code>long long</code>，并取模。</p>
<h3 id="重新规划路线"><a href="#重新规划路线" class="headerlink" title="重新规划路线"></a><a href="https://leetcode-cn.com/contest/weekly-contest-191/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/" target="_blank" rel="noopener">重新规划路线</a></h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p><code>n</code> 座城市，从 <code>0</code> 到 <code>n-1</code> 编号，其间共有 <code>n-1</code> 条路线。因此，要想在两座不同城市之间旅行只有唯一一条路线可供选择（路线网形成一颗树）。去年，交通运输部决定重新规划路线，以改变交通拥堵的状况。</p>
<p>路线用 <code>connections</code> 表示，其中 <code>connections[i] = [a, b]</code> 表示从城市 <code>a</code> 到 <code>b</code> 的一条有向路线。</p>
<p>今年，城市 0 将会举办一场大型比赛，很多游客都想前往城市 0 。</p>
<p>请你帮助重新规划路线方向，使每个城市都可以访问城市 0 。返回需要变更方向的最小路线数。</p>
<p>题目数据 <strong>保证</strong> 每个城市在重新规划路线方向后都能到达城市 0 。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p><img src="/2020/05/31/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B191/sample_1_1819.png" alt="3-1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 6, connections &#x3D; [[0,1],[1,3],[2,3],[4,0],[4,5]]</span><br><span class="line">输出：3</span><br><span class="line">解释：更改以红色显示的路线的方向，使每个城市都可以到达城市 0 。</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/31/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B191/sample_2_1819.png" alt="3-1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 5, connections &#x3D; [[1,0],[1,2],[3,2],[3,4]]</span><br><span class="line">输出：2</span><br><span class="line">解释：更改以红色显示的路线的方向，使每个城市都可以到达城市 0 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3, connections &#x3D; [[1,0],[2,0]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示:</span><br><span class="line"></span><br><span class="line">2 &lt;&#x3D; n &lt;&#x3D; 5 * 10^4</span><br><span class="line">connections.length &#x3D;&#x3D; n-1</span><br><span class="line">connections[i].length &#x3D;&#x3D; 2</span><br><span class="line">0 &lt;&#x3D; connections[i][0], connections[i][1] &lt;&#x3D; n-1</span><br><span class="line">connections[i][0] !&#x3D; connections[i][1]</span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>宽度优先搜索，从<code>0</code>开始，遍历所有与当前节点相连的节点，无论是指向它的节点，还是它指向的节点，将它指向的节点”反转”(将边逆向)，指向它的节点继续，访问过程中设置<code>vis</code>防止重复遍历。</p>
<h4 id="实现示例-2"><a href="#实现示例-2" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minReorder</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; connections)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">g</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:connections)&#123;	<span class="comment">// 建图</span></span><br><span class="line">            g[item[<span class="number">1</span>]+<span class="number">1</span>].push_back(item[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">            g[item[<span class="number">0</span>]+<span class="number">1</span>].push_back(-(item[<span class="number">1</span>]+<span class="number">1</span>));	<span class="comment">// 这里用负数表示有它指向的点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">        que.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n+<span class="number">1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        vis[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> tm = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(tm--)&#123;</span><br><span class="line">                <span class="keyword">auto</span> p = que.front();</span><br><span class="line">                que.pop_front();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> item:g[p])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(vis[<span class="built_in">abs</span>(item)]) <span class="keyword">continue</span>;</span><br><span class="line">                    vis[<span class="built_in">abs</span>(item)] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(item&lt;<span class="number">0</span>) res++;	<span class="comment">// 反转边</span></span><br><span class="line">                    que.push_back(<span class="built_in">abs</span>(item));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="待补第4题"><a href="#待补第4题" class="headerlink" title="待补第4题"></a>待补第4题</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前三题都不难，其中第三题的<code>BFS</code>中标记逆向边用负数花了一点时间思考，第四题还不太会,有点菜。下次努力吧。</p>
<p>本周的双周赛自己参加了一场虚拟竞赛，题目难度不大，四题都AC了。有需要的可以邮件联系。</p>
<p>最后还是希望能坚持做一下比赛，可能用处不大，但是还是多写写吧，毕竟算法与数据结构是很重要的。同时呢，也希望能慢慢地进步，写出更健壮、简洁的代码。</p>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣周赛192</title>
    <url>/2020/06/07/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B192/</url>
    <content><![CDATA[<p>这篇文章主要记录一下第192场周赛的题目解答。以下是四个题目:</p>
<ol>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-192/problems/shuffle-the-array/" target="_blank" rel="noopener">重新排列数组</a>: 3分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-192/problems/the-k-strongest-values-in-an-array/" target="_blank" rel="noopener">数组中的 k 个最强值</a>: 4分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-192/problems/design-browser-history/" target="_blank" rel="noopener">设计浏览器历史记录</a>: 5分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-192/problems/paint-house-iii/" target="_blank" rel="noopener">给房子涂色 III</a>: 6分</li>
</ol>
<a id="more"></a>
<h3 id="重新排列数组"><a href="#重新排列数组" class="headerlink" title="重新排列数组"></a><a href="https://leetcode-cn.com/contest/weekly-contest-192/problems/shuffle-the-array/" target="_blank" rel="noopener">重新排列数组</a></h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给你一个数组 <code>nums</code> ，数组中有 <code>2n</code> 个元素，按 <code>[x1,x2,...,xn,y1,y2,...,yn]</code> 的格式排列。</p>
<p>请你将数组按 <code>[x1,y1,x2,y2,...,xn,yn]</code> 格式重新排列，返回重排后的数组。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>], n = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>] </span><br><span class="line">解释：由于 x1=<span class="number">2</span>, x2=<span class="number">5</span>, x3=<span class="number">1</span>, y1=<span class="number">3</span>, y2=<span class="number">4</span>, y3=<span class="number">7</span> ，所以答案为 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], n = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>], n = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= n &lt;= <span class="number">500</span></span><br><span class="line">nums.length == <span class="number">2</span>n</span><br><span class="line"><span class="number">1</span> &lt;= nums[i] &lt;= <span class="number">10</span>^<span class="number">3</span></span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>按照题意相继向结果数组中添加元素即可。</p>
<h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">shuffle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            res.push_back(nums[i]);	<span class="comment">// 加入xi</span></span><br><span class="line">            res.push_back(nums[i+n]);<span class="comment">// 加入yi</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>题目不难，<code>res</code>可以提前分配空间，上面代码中持续使用<code>push_back</code>函数会频繁的重新分配内存，效率变低。提前分配足够的空间则只需一次内存分配。这个不细说了，是<code>vector</code>的使用细节问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">shuffle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>*n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            res[<span class="number">2</span>*i] = nums[i];</span><br><span class="line">            res[<span class="number">2</span>*i+<span class="number">1</span>]=nums[i+n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="数组中的-k-个最强值"><a href="#数组中的-k-个最强值" class="headerlink" title="数组中的 k 个最强值"></a><a href="https://leetcode-cn.com/contest/weekly-contest-192/problems/the-k-strongest-values-in-an-array/" target="_blank" rel="noopener">数组中的 k 个最强值</a></h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>给你一个整数数组 <code>arr</code> 和一个整数 <code>k</code> 。</p>
<p>设 <code>m</code> 为数组的中位数，只要满足下述两个前提之一，就可以判定 <code>arr[i]</code> 的值比 <code>arr[j]</code> 的值更强：</p>
<ul>
<li><code>|arr[i] - m| &gt; |arr[j] - m|</code></li>
<li><code>|arr[i] - m| == |arr[j] - m|</code>，且 <code>arr[i] &gt; arr[j]</code></li>
</ul>
<p>请返回由数组中最强的 <code>k</code> 个值组成的列表。答案可以以 <strong>任意顺序</strong> 返回。</p>
<p><strong>中位数</strong> 是一个有序整数列表中处于中间位置的值。形式上，如果列表的长度为 <code>n</code> ，那么中位数就是该有序列表（下标从 0 开始）中位于 <code>((n - 1) / 2)</code> 的元素。</p>
<ul>
<li>例如 <code>arr = [6, -3, 7, 2, 11]</code>，<code>n = 5</code>：数组排序后得到 <code>arr = [-3, 2, 6, 7, 11]</code> ，数组的中间位置为 <code>m = ((5 - 1) / 2) = 2</code> ，中位数 <code>arr[m]</code> 的值为 <code>6</code> 。</li>
<li>例如 <code>arr = [-7, 22, 17, 3]</code>，<code>n = 4</code>：数组排序后得到 <code>arr = [-7, 3, 17, 22]</code> ，数组的中间位置为 <code>m = ((4 - 1) / 2) = 1</code> ，中位数 <code>arr[m]</code> 的值为 <code>3</code> 。</li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2,3,4,5], k &#x3D; 2</span><br><span class="line">输出：[5,1]</span><br><span class="line">解释：中位数为 3，按从强到弱顺序排序后，数组变为 [5,1,4,2,3]。最强的两个元素是 [5, 1]。[1, 5] 也是正确答案。</span><br><span class="line">注意，尽管 |5 - 3| &#x3D;&#x3D; |1 - 3| ，但是 5 比 1 更强，因为 5 &gt; 1 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,1,3,5,5], k &#x3D; 2</span><br><span class="line">输出：[5,5]</span><br><span class="line">解释：中位数为 3, 按从强到弱顺序排序后，数组变为 [5,5,1,1,3]。最强的两个元素是 [5, 5]。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [6,7,11,7,6,8], k &#x3D; 5</span><br><span class="line">输出：[11,8,6,6,7]</span><br><span class="line">解释：中位数为 7, 按从强到弱顺序排序后，数组变为 [11,8,6,6,7,7]。</span><br><span class="line">[11,8,6,6,7] 的任何排列都是正确答案。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [6,-3,7,2,11], k &#x3D; 3</span><br><span class="line">输出：[-3,11,2]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [-7,22,17,3], k &#x3D; 2</span><br><span class="line">输出：[22,17]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; arr.length &lt;&#x3D; 10^5</span><br><span class="line">-10^5 &lt;&#x3D; arr[i] &lt;&#x3D; 10^5</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; arr.length</span><br></pre></td></tr></table></figure>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>先找到中位数<code>m</code>(通过排序)，然后找满足条件的前<code>k</code>个元素。</p>
<p>首先寻找”满足条件的前k个元素”可以通过贪心的思想，一旦想使用贪心思想，必然可能使用到排序或者优先队列，因为这两种方式都可以选取局部最值（当前最大或最小，或者满足某种条件的最大、最小）。</p>
<p>题目的条件告诉我们一个元素离中位数<code>m</code>越远值越”强”，那么可以明显的看到最末端的两个元素肯定是最“强”的两个，同理可以贪心地从两端取元素，判断谁是当前的最强值。</p>
<h4 id="实现示例-1"><a href="#实现示例-1" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getStrongest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        sort(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());	<span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = arr[(n<span class="number">-1</span>)/<span class="number">2</span>];   <span class="comment">// 获取中位数</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;     <span class="comment">// 指向两端的指针进行比较并获得较“强”的值</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(arr[l]-m) &gt; <span class="built_in">abs</span>(arr[r]-m))&#123;</span><br><span class="line">                res.push_back(arr[l++]);    <span class="comment">// l端更“强”</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.push_back(arr[r--]);    <span class="comment">// r端更“强”</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="设计浏览器历史记录"><a href="#设计浏览器历史记录" class="headerlink" title="设计浏览器历史记录"></a><a href="https://leetcode-cn.com/contest/weekly-contest-192/problems/design-browser-history/" target="_blank" rel="noopener">设计浏览器历史记录</a></h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>你有一个只支持单个标签页的 <strong>浏览器</strong> ，最开始你浏览的网页是 <code>homepage</code> ，你可以访问其他的网站 <code>url</code> ，也可以在浏览历史中后退 <code>steps</code> 步或前进 <code>steps</code> 步。</p>
<p>请你实现 <code>BrowserHistory</code> 类：</p>
<ul>
<li><code>BrowserHistory(string homepage)</code> ，用 <code>homepage</code> 初始化浏览器类。</li>
<li><code>void visit(string url)</code> 从当前页跳转访问 <code>url</code> 对应的页面 。执行此操作会把浏览历史前进的记录全部删除。</li>
<li><code>string back(int steps)</code> 在浏览历史中后退 <code>steps</code> 步。如果你只能在浏览历史中后退至多 <code>x</code> 步且 <code>steps &gt; x</code> ，那么你只后退 <code>x</code> 步。请返回后退 <strong>至多</strong> <code>steps</code> 步以后的 <code>url</code> 。</li>
<li><code>string forward(int steps)</code> 在浏览历史中前进 <code>steps</code> 步。如果你只能在浏览历史中前进至多 <code>x</code> 步且 <code>steps &gt; x</code> ，那么你只前进 <code>x</code> 步。请返回前进 <strong>至多</strong> <code>steps</code>步以后的 <code>url</code> 。</li>
</ul>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;BrowserHistory&quot;,&quot;visit&quot;,&quot;visit&quot;,&quot;visit&quot;,&quot;back&quot;,&quot;back&quot;,&quot;forward&quot;,&quot;visit&quot;,&quot;forward&quot;,&quot;back&quot;,&quot;back&quot;]</span><br><span class="line">[[&quot;leetcode.com&quot;],[&quot;google.com&quot;],[&quot;facebook.com&quot;],[&quot;youtube.com&quot;],[1],[1],[1],[&quot;linkedin.com&quot;],[2],[2],[7]]</span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,&quot;facebook.com&quot;,&quot;google.com&quot;,&quot;facebook.com&quot;,null,&quot;linkedin.com&quot;,&quot;google.com&quot;,&quot;leetcode.com&quot;]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">BrowserHistory browserHistory &#x3D; new BrowserHistory(&quot;leetcode.com&quot;);</span><br><span class="line">browserHistory.visit(&quot;google.com&quot;);       &#x2F;&#x2F; 你原本在浏览 &quot;leetcode.com&quot; 。访问 &quot;google.com&quot;</span><br><span class="line">browserHistory.visit(&quot;facebook.com&quot;);     &#x2F;&#x2F; 你原本在浏览 &quot;google.com&quot; 。访问 &quot;facebook.com&quot;</span><br><span class="line">browserHistory.visit(&quot;youtube.com&quot;);      &#x2F;&#x2F; 你原本在浏览 &quot;facebook.com&quot; 。访问 &quot;youtube.com&quot;</span><br><span class="line">browserHistory.back(1);                   &#x2F;&#x2F; 你原本在浏览 &quot;youtube.com&quot; ，后退到 &quot;facebook.com&quot; 并返回 &quot;facebook.com&quot;</span><br><span class="line">browserHistory.back(1);                   &#x2F;&#x2F; 你原本在浏览 &quot;facebook.com&quot; ，后退到 &quot;google.com&quot; 并返回 &quot;google.com&quot;</span><br><span class="line">browserHistory.forward(1);                &#x2F;&#x2F; 你原本在浏览 &quot;google.com&quot; ，前进到 &quot;facebook.com&quot; 并返回 &quot;facebook.com&quot;</span><br><span class="line">browserHistory.visit(&quot;linkedin.com&quot;);     &#x2F;&#x2F; 你原本在浏览 &quot;facebook.com&quot; 。 访问 &quot;linkedin.com&quot;</span><br><span class="line">browserHistory.forward(2);                &#x2F;&#x2F; 你原本在浏览 &quot;linkedin.com&quot; ，你无法前进任何步数。</span><br><span class="line">browserHistory.back(2);                   &#x2F;&#x2F; 你原本在浏览 &quot;linkedin.com&quot; ，后退两步依次先到 &quot;facebook.com&quot; ，然后到 &quot;google.com&quot; ，并返回 &quot;google.com&quot;</span><br><span class="line">browserHistory.back(7);                   &#x2F;&#x2F; 你原本在浏览 &quot;google.com&quot;， 你只能后退一步到 &quot;leetcode.com&quot; ，并返回 &quot;leetcode.com&quot;</span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>题目的意思不容易理解清楚，慢慢读。关键是判断要使用什么数据结构。</p>
<p>有一个前进以及后退的操作，可考虑双向链表。</p>
<p>注意<code>visit</code>接口的意思，一旦<code>visit</code>了这个<code>url</code>，那么这个<code>url</code>后面的网页全部丢失。</p>
<p>那么丢失在代码上的实现是什么呢？删除操作。</p>
<p>删除元素是一件费时的操作，可以用”有效”来表示，删除后面的元素，表示后面的元素无效。可以通过一个位置指针来指定最远的有效位置</p>
<h4 id="实现示例-2"><a href="#实现示例-2" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrowserHistory</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; t;   <span class="comment">// 保存记录</span></span><br><span class="line">    <span class="keyword">int</span> cur;    <span class="comment">// 当前访问位置</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span>;    <span class="comment">// 向后的界限，最远的有效位置</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BrowserHistory(<span class="built_in">string</span> homepage) &#123;</span><br><span class="line">        t.push_back(homepage);</span><br><span class="line">        cur = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="built_in">string</span> url)</span> </span>&#123;    <span class="comment">// 一旦visit那么向后记录消失，即界限为当前位置</span></span><br><span class="line">        <span class="keyword">if</span>(t.<span class="built_in">size</span>() == (cur+<span class="number">1</span>))&#123;    <span class="comment">// 容量不够</span></span><br><span class="line">            t.push_back(url);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            t[cur+<span class="number">1</span>] = url;</span><br><span class="line">        &#125;</span><br><span class="line">        cur++;</span><br><span class="line">        <span class="built_in">end</span> = cur;    <span class="comment">// 界限为idx，idx后的元素失效</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">back</span><span class="params">(<span class="keyword">int</span> steps)</span> </span>&#123;    <span class="comment">// 当前位置后退</span></span><br><span class="line">        cur = <span class="built_in">max</span>(cur-steps,<span class="number">0</span>);     <span class="comment">// 顶多退到首页</span></span><br><span class="line">        <span class="keyword">return</span> t[cur];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span> steps)</span> </span>&#123;     <span class="comment">// 当前位置后退</span></span><br><span class="line">        cur = <span class="built_in">min</span>(cur+steps,<span class="built_in">end</span>);   <span class="comment">// 顶多前进到界限处</span></span><br><span class="line">        <span class="keyword">return</span> t[cur];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个实现我是从<a href="https://blog.csdn.net/Solstice" target="_blank" rel="noopener">陈硕</a>写的开源网络库<a href="https://github.com/chenshuo/muduo" target="_blank" rel="noopener"><code>muduo</code></a>中的<code>buffer</code>的设计中获取到的灵感，有兴趣的可以去查看一下。这里就不展开来说了。</p>
<h3 id="给房子涂色-III"><a href="#给房子涂色-III" class="headerlink" title="给房子涂色 III"></a><a href="https://leetcode-cn.com/contest/weekly-contest-192/problems/paint-house-iii/" target="_blank" rel="noopener">给房子涂色 III</a></h3><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>在一个小城市里，有 <code>m</code> 个房子排成一排，你需要给每个房子涂上 <code>n</code> 种颜色之一（颜色编号为 <code>1</code> 到 <code>n</code> ）。有的房子去年夏天已经涂过颜色了，所以这些房子不需要被重新涂色。</p>
<p>我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 <code>houses = [1,2,2,3,3,2,1,1]</code> ，它包含 5 个街区 <code>[{1}, {2,2}, {3,3}, {2}, {1,1}]</code> 。）</p>
<p>给你一个数组 <code>houses</code> ，一个 <code>m * n</code> 的矩阵 <code>cost</code> 和一个整数 <code>target</code> ，其中：</p>
<ul>
<li><code>houses[i]</code>：是第 <code>i</code> 个房子的颜色，<strong>0</strong> 表示这个房子还没有被涂色。</li>
<li><code>cost[i][j]</code>：是将第 <code>i</code> 个房子涂成颜色 <code>j+1</code> 的花费。</li>
</ul>
<p>请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成 <code>target</code> 个街区。如果没有可用的涂色方案，请返回 <strong>-1</strong> 。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：houses &#x3D; [0,0,0,0,0], cost &#x3D; [[1,10],[10,1],[10,1],[1,10],[5,1]], m &#x3D; 5, n &#x3D; 2, target &#x3D; 3</span><br><span class="line">输出：9</span><br><span class="line">解释：房子涂色方案为 [1,2,2,1,1]</span><br><span class="line">此方案包含 target &#x3D; 3 个街区，分别是 [&#123;1&#125;, &#123;2,2&#125;, &#123;1,1&#125;]。</span><br><span class="line">涂色的总花费为 (1 + 1 + 1 + 1 + 5) &#x3D; 9。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：houses &#x3D; [0,2,1,2,0], cost &#x3D; [[1,10],[10,1],[10,1],[1,10],[5,1]], m &#x3D; 5, n &#x3D; 2, target &#x3D; 3</span><br><span class="line">输出：11</span><br><span class="line">解释：有的房子已经被涂色了，在此基础上涂色方案为 [2,2,1,2,2]</span><br><span class="line">此方案包含 target &#x3D; 3 个街区，分别是 [&#123;2,2&#125;, &#123;1&#125;, &#123;2,2&#125;]。</span><br><span class="line">给第一个和最后一个房子涂色的花费为 (10 + 1) &#x3D; 11。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：houses &#x3D; [0,0,0,0,0], cost &#x3D; [[1,10],[10,1],[1,10],[10,1],[1,10]], m &#x3D; 5, n &#x3D; 2, target &#x3D; 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：houses = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], cost = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]], m = <span class="number">4</span>, n = <span class="number">3</span>, target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：房子已经被涂色并组成了 <span class="number">4</span> 个街区，分别是 [&#123;<span class="number">3</span>&#125;,&#123;<span class="number">1</span>&#125;,&#123;<span class="number">2</span>&#125;,&#123;<span class="number">3</span>&#125;] ，无法形成 target = <span class="number">3</span> 个街区。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">m &#x3D;&#x3D; houses.length &#x3D;&#x3D; cost.length</span><br><span class="line">n &#x3D;&#x3D; cost[i].length</span><br><span class="line">1 &lt;&#x3D; m &lt;&#x3D; 100</span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 20</span><br><span class="line">1 &lt;&#x3D; target &lt;&#x3D; m</span><br><span class="line">0 &lt;&#x3D; houses[i] &lt;&#x3D; n</span><br><span class="line">1 &lt;&#x3D; cost[i][j] &lt;&#x3D; 10^4</span><br></pre></td></tr></table></figure>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p><code>DP</code>思想。</p>
<p>为什么会想到用<code>dp</code>呢?</p>
<blockquote>
<p>可以看到房子染色是一个接一个，有一个逐步染色的过程，一旦发现一个复杂的操作可以逐步进行，那么可以考虑<code>DP</code>。即<code>dp[第i步] = 某些运算(取最大或者最小等等操作){dp[第i-1步]...+当前操作对结果的影响}</code></p>
</blockquote>
<p><code>DP</code>的状态如何描述呢?</p>
<blockquote>
<p>选取染色的颜色以及有几个街区两个状态</p>
<p><code>dp[i][j]</code>表示当前选取颜色<code>i</code>并且有<code>j</code>个街区</p>
</blockquote>
<p>加上上面<code>步数</code>这个状态变量,<code>dp</code>完整的描述是<code>dp[k][i][j]</code>（第<code>k</code>步，选取颜色<code>i</code>，有<code>j</code>个街区）</p>
<p><code>DP</code>的状态如何转换呢?</p>
<blockquote>
<p>在找<code>DP</code>的状态转移方程时，可以想想当前的状态与之前的哪些状态相关</p>
<p>这里<code>dp[k][i][j]</code>与<code>dp[k-1][...][...]</code>的状态有关</p>
</blockquote>
<p>对状态进行分类，每一类状态的状态转移方程是相同的。比如:</p>
<blockquote>
<p>要求解<code>dp[k][i][j]</code> 那么<code>dp[k-1][i][...]</code>的转移方式是一种</p>
<p><code>dp[k][i][j]</code>与<code>dp[k-1][...][j-1]</code>的转移方式是另一种</p>
</blockquote>
<p>通过对<code>DP</code>的分析后，合理地设置初始条件就可以解出题目了（设置初始条件也有很多学问）。</p>
<h4 id="实现示例-3"><a href="#实现示例-3" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; houses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; cost, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> NIL = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(target+<span class="number">1</span>,NIL))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w=<span class="number">1</span>;w&lt;=m;w++)&#123;	<span class="comment">// 第w步</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; tdp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; (n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(target+<span class="number">1</span>,NIL));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;	<span class="comment">// 选取第i中颜色</span></span><br><span class="line">                <span class="keyword">int</span> tcnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(houses[w<span class="number">-1</span>] &amp;&amp; i!= houses[w<span class="number">-1</span>]) <span class="keyword">continue</span>;	<span class="comment">// 已经染过色了，只能选取本身地颜色</span></span><br><span class="line">                <span class="keyword">if</span>(houses[w<span class="number">-1</span>])&#123;</span><br><span class="line">                    tcnt = <span class="number">0</span>;	<span class="comment">// 已经染过色了,而且选取本身的颜色，当前cost为0</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tcnt = cost[w<span class="number">-1</span>][i<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;	<span class="comment">// 前一个房子的颜色</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=target;k++)&#123;	<span class="comment">// 有k个街区</span></span><br><span class="line">                        <span class="keyword">if</span>(i==j)&#123;	<span class="comment">// 当前选取地原色与前一个元素相同(街区数目不变)</span></span><br><span class="line">                            tdp[i][k] = <span class="built_in">min</span>(tdp[i][k],dp[j][k]+tcnt);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;	<span class="comment">// 当前选取地原色与前一个元素不同(街区数目加1)</span></span><br><span class="line">                            <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                            tdp[i][k] = <span class="built_in">min</span>(tdp[i][k],dp[j][k<span class="number">-1</span>]+tcnt);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = tdp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = NIL;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            res = <span class="built_in">min</span>(res,dp[i][target]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res==NIL) <span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">// 无法找到满足条件地染色方案</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，我的实现代码中采用了滚动数组进行优化，所以状态表示看上去好像是二维的，其实是因为采用滚动数组的原因，本质来说还是三维的状态。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>难度不大，第四题的在设置<code>tcnt</code>（当前选取的元素造成的<code>cost</code>）出现的一点点问题，花了一点时间调试，初始条件的设置也花了一点时间思考，其他地方按照<code>DP</code>思路写就行。</p>
<p>第三题我觉得这个题目描述不是很好，好在题目不难。而且前面我也提到过这个是从<a href="https://blog.csdn.net/Solstice" target="_blank" rel="noopener">陈硕</a>写的开源网络库<a href="https://github.com/chenshuo/muduo" target="_blank" rel="noopener"><code>muduo</code></a>中的<code>buffer</code>的设计中获取到的灵感,这个也算是一点点的学以致用吧，哈哈。</p>
<p>最后咧，还是那句话，刷题本身用处不大（面试时可能有点用），但是起码让你保持对你熟悉地编程语言地熟悉度，也许能从题目中获取一些解决类似的生活中、学习中、工作中的问题也说不定咧。</p>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣周赛187</title>
    <url>/2020/05/06/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B187/</url>
    <content><![CDATA[<p>这篇文章主要记录一下第187场周赛的题目解答。以下是四个题目：</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/destination-city/" target="_blank" rel="noopener">旅行终点站</a>: 3分</li>
<li><a href="https://leetcode-cn.com/problems/check-if-all-1s-are-at-least-length-k-places-away/" target="_blank" rel="noopener">是否所有1都至少相隔k个元素</a>: 4分</li>
<li><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" target="_blank" rel="noopener">绝对差不超过限制的最长连续子数组</a>: 5分</li>
<li><a href="https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/" target="_blank" rel="noopener">有序矩阵中的第 k 个最小数组和</a>: 7分</li>
</ol>
<a id="more"></a>
<h3 id="旅行终点站"><a href="#旅行终点站" class="headerlink" title="旅行终点站"></a><a href="https://leetcode-cn.com/problems/destination-city/" target="_blank" rel="noopener">旅行终点站</a></h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。</p>
<p>题目数据保证线路图会形成一条不存在循环的线路，因此只会有一个旅行终点站。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：paths &#x3D; [[&quot;London&quot;,&quot;New York&quot;],[&quot;New York&quot;,&quot;Lima&quot;],[&quot;Lima&quot;,&quot;Sao Paulo&quot;]]</span><br><span class="line">输出：&quot;Sao Paulo&quot; </span><br><span class="line">解释：从 &quot;London&quot; 出发，最后抵达终点站 &quot;Sao Paulo&quot; 。本次旅行的路线是 &quot;London&quot; -&gt; &quot;New York&quot; -&gt; &quot;Lima&quot; -&gt; &quot;Sao Paulo&quot; 。</span><br><span class="line"></span><br><span class="line">输入：paths &#x3D; [[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;,&quot;B&quot;],[&quot;C&quot;,&quot;A&quot;]]</span><br><span class="line">输出：&quot;A&quot;</span><br><span class="line">解释：所有可能的线路是：</span><br><span class="line">&quot;D&quot; -&gt; &quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;A&quot;. </span><br><span class="line">显然，旅行终点站是 &quot;A&quot; 。</span><br><span class="line"></span><br><span class="line">输入：paths &#x3D; [[&quot;A&quot;,&quot;Z&quot;]]</span><br><span class="line">输出：&quot;Z&quot;</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; paths.length &lt;&#x3D; 100</span><br><span class="line">paths[i].length &#x3D;&#x3D; 2</span><br><span class="line">1 &lt;&#x3D; cityAi.length, cityBi.length &lt;&#x3D; 10</span><br><span class="line">cityAi !&#x3D; cityBi</span><br><span class="line">所有字符串均由大小写英文字母和空格字符组成。</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>是一个有向图问题，注意到只有一个终点并且没有环，同时每个节点的<code>出度</code>最多为$1$，所以从任意节点出发，沿有向边遍历一定可以到达终点，不妨取$paths[0][0]$或者$paths[0][1]$。</p>
<h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">destCity</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:paths)&#123;</span><br><span class="line">            t[item[<span class="number">0</span>]] = item[<span class="number">1</span>];	<span class="comment">// 建立边</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> res = paths[<span class="number">0</span>][<span class="number">1</span>];	<span class="comment">// 从paths[0][1]出发</span></span><br><span class="line">        <span class="keyword">while</span>(t.<span class="built_in">find</span>(res) != t.<span class="built_in">end</span>())&#123;	<span class="comment">// 存在有向边，则跳转到下一个节点</span></span><br><span class="line">            res = t[res];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="是否所有1都至少相隔k个元素"><a href="#是否所有1都至少相隔k个元素" class="headerlink" title="是否所有1都至少相隔k个元素"></a><a href="https://leetcode-cn.com/problems/check-if-all-1s-are-at-least-length-k-places-away/" target="_blank" rel="noopener">是否所有1都至少相隔k个元素</a></h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>给你一个由若干 <code>0</code> 和 <code>1</code> 组成的数组 <code>nums</code> 以及整数 <code>k</code>。如果所有 <code>1</code> 都至少相隔 <code>k</code> 个元素，则返回 <code>True</code> ；否则，返回 <code>False</code> 。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p><img src="/2020/05/06/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B187/sample_1_1791.png" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,0,0,0,1,0,0,1], k &#x3D; 2</span><br><span class="line">输出：true</span><br><span class="line">解释：每个 1 都至少相隔 2 个元素。</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/06/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B187/sample_2_1791.png" alt="2"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,0,0,1,0,1], k &#x3D; 2</span><br><span class="line">输出：false</span><br><span class="line">解释：第二个 1 和第三个 1 之间只隔了 1 个元素。</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,1,1,1,1], k &#x3D; 0</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [0,1,0,1], k &#x3D; 1</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</span><br><span class="line">0 &lt;&#x3D; k &lt;&#x3D; nums.length</span><br><span class="line">nums[i] 的值为 0 或 1</span><br></pre></td></tr></table></figure>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>只需判断连续的$0$的个数是否都<strong>大于等于</strong>$k$。也即任意连个不相连的$1$的距离都大于$k$。</p>
<h4 id="实现示例-1"><a href="#实现示例-1" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">kLengthApart</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;	<span class="comment">// 连续0的个数</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt &amp;&amp; cnt&lt;k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> cnt&gt;=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="绝对差不超过限制的最长连续子数组"><a href="#绝对差不超过限制的最长连续子数组" class="headerlink" title="绝对差不超过限制的最长连续子数组"></a><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" target="_blank" rel="noopener">绝对差不超过限制的最长连续子数组</a></h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>给你一个整数数组 <code>nums</code>，和一个表示限制的整数 <code>limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 <code>limit</code>。</p>
<p>如果不存在满足条件的子数组，则返回 0 。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [8,2,4,7], limit &#x3D; 4</span><br><span class="line">输出：2 </span><br><span class="line">解释：所有子数组如下：</span><br><span class="line">[8] 最大绝对差 |8-8| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">[8,2] 最大绝对差 |8-2| &#x3D; 6 &gt; 4. </span><br><span class="line">[8,2,4] 最大绝对差 |8-2| &#x3D; 6 &gt; 4.</span><br><span class="line">[8,2,4,7] 最大绝对差 |8-2| &#x3D; 6 &gt; 4.</span><br><span class="line">[2] 最大绝对差 |2-2| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">[2,4] 最大绝对差 |2-4| &#x3D; 2 &lt;&#x3D; 4.</span><br><span class="line">[2,4,7] 最大绝对差 |2-7| &#x3D; 5 &gt; 4.</span><br><span class="line">[4] 最大绝对差 |4-4| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">[4,7] 最大绝对差 |4-7| &#x3D; 3 &lt;&#x3D; 4.</span><br><span class="line">[7] 最大绝对差 |7-7| &#x3D; 0 &lt;&#x3D; 4. </span><br><span class="line">因此，满足题意的最长子数组的长度为 2 。</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [10,1,2,4,7,2], limit &#x3D; 5</span><br><span class="line">输出：4 </span><br><span class="line">解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| &#x3D; 5 &lt;&#x3D; 5 。</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [4,2,2,2,4,4,2,2], limit &#x3D; 0</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</span><br><span class="line">1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9</span><br><span class="line">0 &lt;&#x3D; limit &lt;&#x3D; 10^9</span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>数据范围很大，因此$O(n^2)$的解法是会超时的。考虑滑动窗口(双指针)，窗口中维护所有元素并能快速的得到窗口中元素的最值，考虑用<code>ordered_set</code>，由于元素可能重复因此使用<code>map</code>或者<code>multiset</code>。</p>
<h4 id="实现示例-2"><a href="#实现示例-2" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; t;	<span class="comment">// 元素值 -&gt; 次数</span></span><br><span class="line">        <span class="keyword">int</span> n  = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;	<span class="comment">// 慢指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;	<span class="comment">// 快指针</span></span><br><span class="line">            t[nums[i]]++;</span><br><span class="line">            <span class="keyword">auto</span> ite = t.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">auto</span> mn = ite-&gt;first;</span><br><span class="line">            ite = t.<span class="built_in">end</span>();</span><br><span class="line">            --ite;</span><br><span class="line">            <span class="keyword">auto</span> mx = ite-&gt;first;</span><br><span class="line">            <span class="keyword">if</span>((mx-mn) &lt;= k)&#123;	<span class="comment">// 仍然满足条件</span></span><br><span class="line">                res = <span class="built_in">max</span>(res,i+<span class="number">1</span>-pre);</span><br><span class="line">                <span class="comment">// cout&lt;&lt;1&lt;&lt;": "&lt;&lt;res&lt;&lt;endl;</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;	<span class="comment">// 慢指针前移</span></span><br><span class="line">                <span class="keyword">while</span>(pre&lt;i)&#123;	</span><br><span class="line">                    <span class="comment">// cout&lt;&lt;pre&lt;&lt;endl;</span></span><br><span class="line">                    t[nums[pre]]--;</span><br><span class="line">                    <span class="keyword">if</span>(t[nums[pre]] == <span class="number">0</span>) t.erase(nums[pre]);</span><br><span class="line">                    pre+=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">auto</span> ite = t.<span class="built_in">begin</span>();</span><br><span class="line">                    <span class="keyword">auto</span> tmn = ite-&gt;first;</span><br><span class="line">                    ite = t.<span class="built_in">end</span>();</span><br><span class="line">                    --ite;</span><br><span class="line">                    <span class="keyword">auto</span> tmx = ite-&gt;first;</span><br><span class="line">                    <span class="keyword">if</span>((tmx-tmn)&lt;=k)&#123;	<span class="comment">// 满足条件，停止慢指针前移</span></span><br><span class="line">                        res = <span class="built_in">max</span>(res,i+<span class="number">1</span>-pre);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该题也有其他的实现方法，详情可以看看题目的题解部分。</p>
<h3 id="有序矩阵中的第-k-个最小数组和"><a href="#有序矩阵中的第-k-个最小数组和" class="headerlink" title="有序矩阵中的第 k 个最小数组和"></a><a href="https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/" target="_blank" rel="noopener">有序矩阵中的第 k 个最小数组和</a></h3><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>给你一个 m * n 的矩阵 mat，以及一个整数 k ，矩阵中的每一行都以非递减的顺序排列。</p>
<p>你可以从每一行中选出 1 个元素形成一个数组。返回所有可能数组中的第 k 个 最小 数组和。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：mat &#x3D; [[1,3,11],[2,4,6]], k &#x3D; 5</span><br><span class="line">输出：7</span><br><span class="line">解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：</span><br><span class="line">[1,2], [1,4], [3,2], [3,4], [1,6]。其中第 5 个的和是 7 。  </span><br><span class="line"></span><br><span class="line">输入：mat &#x3D; [[1,3,11],[2,4,6]], k &#x3D; 9</span><br><span class="line">输出：17</span><br><span class="line"></span><br><span class="line">输入：mat &#x3D; [[1,10,10],[1,4,5],[2,3,6]], k &#x3D; 7</span><br><span class="line">输出：9</span><br><span class="line">解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：</span><br><span class="line">[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]。其中第 7 个的和是 9 。 </span><br><span class="line"></span><br><span class="line">输入：mat &#x3D; [[1,1,10],[2,2,9]], k &#x3D; 7</span><br><span class="line">输出：12</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">m &#x3D;&#x3D; mat.length</span><br><span class="line">n &#x3D;&#x3D; mat.length[i]</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 40</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; min(200, n ^ m)</span><br><span class="line">1 &lt;&#x3D; mat[i][j] &lt;&#x3D; 5000</span><br><span class="line">mat[i] 是一个非递减数组</span><br></pre></td></tr></table></figure>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>第$k$小(或大)的元素，考虑用贪心的优先队列。</p>
<p>直观上看当每行取第1个元素时最小，下一个元素必然是某行的元素索引向后移动一位，至于是哪一位，放入优先队列中进行比较可得，同理可得到第$k$小的元素。</p>
<h4 id="实现示例-3"><a href="#实现示例-3" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; que;	<span class="comment">// 总和，索引列表</span></span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vis;</span><br><span class="line">        <span class="keyword">int</span> m = mat.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vis.insert(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m,<span class="number">0</span>));	<span class="comment">// 防止重复遍历</span></span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">int</span> tcnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            tcnt+=mat[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        que.push(&#123;-tcnt,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m,<span class="number">0</span>)&#125;);</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">auto</span> table= p.second;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;	<span class="comment">// 每个下一个元素加入优先队列中</span></span><br><span class="line">                <span class="keyword">int</span> item = table[i];</span><br><span class="line">                <span class="keyword">if</span>((item+<span class="number">1</span>)&gt;=n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">auto</span> temp = table;</span><br><span class="line">                temp[i]++;</span><br><span class="line">                <span class="keyword">if</span>(vis.count(temp)) <span class="keyword">continue</span>;</span><br><span class="line">                vis.insert(temp);</span><br><span class="line">                <span class="keyword">int</span> res = -p.first;</span><br><span class="line">                res+=mat[i][item+<span class="number">1</span>]-mat[i][item];</span><br><span class="line">                res = -res;</span><br><span class="line">                que.push(&#123;res,temp&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -que.top().first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>题解中也有使用<code>二分</code>的写法，这里就不搬运了，感兴趣的可以到该题目的题解处看看。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>抽象能力还是有待提高，要将题目转化成数学表示，再然后是代码实现。滑动窗口问题最近出现较频繁，题目也并不容易，有待进一步的总结，练习。</p>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣每日打卡20200506</title>
    <url>/2020/05/06/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A120200506/</url>
    <content><![CDATA[<p>这篇文章是关于<code>力扣每日打卡</code>的题目的一点点记录。</p>
<p>题目: <a href="https://leetcode-cn.com/problems/minimum-cost-for-tickets/" target="_blank" rel="noopener">最低票价</a></p>
<p>难度：中</p>
<a id="more"></a>
<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。</p>
<p>火车票有三种不同的销售方式：</p>
<p>一张为期一天的通行证售价为 costs[0] 美元；<br>一张为期七天的通行证售价为 costs[1] 美元；<br>一张为期三十天的通行证售价为 costs[2] 美元。<br>通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。</p>
<p>返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：days &#x3D; [1,4,6,7,8,20], costs &#x3D; [2,7,15]</span><br><span class="line">输出：11</span><br><span class="line">解释： </span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：</span><br><span class="line">在第 1 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 1 天生效。</span><br><span class="line">在第 3 天，你花了 costs[1] &#x3D; $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。</span><br><span class="line">在第 20 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 20 天生效。</span><br><span class="line">你总共花了 $11，并完成了你计划的每一天旅行。</span><br><span class="line"></span><br><span class="line">输入：days &#x3D; [1,2,3,4,5,6,7,8,9,10,30,31], costs &#x3D; [2,7,15]</span><br><span class="line">输出：17</span><br><span class="line">解释：</span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： </span><br><span class="line">在第 1 天，你花了 costs[2] &#x3D; $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。</span><br><span class="line">在第 31 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 </span><br><span class="line">你总共花了 $17，并完成了你计划的每一天旅行。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1. 1 &lt;&#x3D; days.length &lt;&#x3D; 365</span><br><span class="line">2. 1 &lt;&#x3D; days[i] &lt;&#x3D; 365</span><br><span class="line">3. days 按顺序严格递增</span><br><span class="line">4. costs.length &#x3D;&#x3D; 3</span><br><span class="line">5. 1 &lt;&#x3D; costs[i] &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><code>days</code>数组是严格递增的，那么在某个位置<code>i</code>（下标）,其天数信息为<code>day[i]</code>，有三种可选的计划方案:</p>
<ol>
<li>选取<code>为期1天</code>的通行证，那么在<code>[days[i],days[i]+1-1]</code>中的旅游不需要通行证，直接跳转到<strong>大于等于</strong><code>day[i]+1</code>处，设此处小标为<code>j</code>，那么有关系<code>dp[i] = dp[i]+1天通行证的代价</code></li>
<li>选取<code>为期7天</code>的通行证，同理在<code>[days[i],days[i]+7-1]</code>中的旅游不需要通行证,直接跳转到<strong>大于等于</strong><code>day[i]+7</code>处，设此处小标为<code>j</code>，那么有关系<code>dp[i] = dp[i]+7天通行证的代价</code></li>
<li>选取<code>为期30天</code>的通行证,同理</li>
</ol>
<p>只需取上面三种可能中的较小值即可。</p>
<p>初始条件设置当位置<code>i</code>为<code>n</code>（n为<code>days</code>的元素个数）时，代价为0。</p>
<p>按照上面的分析可以得出要求的结果为<code>dp[0]</code></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;days,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;costs,<span class="keyword">int</span> idx,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;dir,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = days.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(dp[idx] != <span class="number">-1</span>) <span class="keyword">return</span> dp[idx];   <span class="comment">// memo</span></span><br><span class="line">        dp[idx] = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tcost = costs[i];   <span class="comment">// 当前选取不同类别通行证的代价</span></span><br><span class="line">            <span class="keyword">int</span> rangeR = days[idx]+dir[i]<span class="number">-1</span>; <span class="comment">// 通行证的覆盖范围[idx,rangeR]</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 二分查找</span></span><br><span class="line">            <span class="comment">// 通行证未覆盖的最小下标</span></span><br><span class="line">            <span class="keyword">int</span> l = upper_bound(days.<span class="built_in">begin</span>(),days.<span class="built_in">end</span>(),rangeR)-days.<span class="built_in">begin</span>();</span><br><span class="line">            dp[idx] = <span class="built_in">min</span>(dp[idx],dfs(days,costs,l,dir,dp)+tcost);  <span class="comment">// 状态转移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; days, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dir = &#123;<span class="number">1</span>,<span class="number">7</span>,<span class="number">30</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = days.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        dp[n] = <span class="number">0</span>;  <span class="comment">// 初始化条件</span></span><br><span class="line">        <span class="keyword">return</span> dfs(days,costs,idx,dir,dp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>主方向：<code>dp</code></li>
<li>状态如何转移，上一或者下一状态的位置如何确定</li>
<li>初始条件是什么</li>
</ol>
<p>官方题解以及其他用户的题解也是相当的不错，都可以用自己熟悉的语言实现一下看看。</p>
<p>最后附上一首词:</p>
<center>青杏儿</center>

<center>[金]赵秉文</center>

<center>风雨替花愁。风雨罢，花也应休。劝君莫惜花前醉，今年花谢，明年花谢，白了人头。</center>

<center>乘兴两三瓯。拣溪山好处追游。但教有酒身无事，有花也好，无花也好，选甚春秋。</center>

<center></center>]]></content>
      <categories>
        <category>力扣打卡</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>力扣</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣周赛188</title>
    <url>/2020/05/10/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B188/</url>
    <content><![CDATA[<p>这篇文章主要记录一下第188场周赛的题目解答。以下是四个题目：</p>
<ol>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/build-an-array-with-stack-operations/" target="_blank" rel="noopener">用栈操作构建数组</a>: 3分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/" target="_blank" rel="noopener">形成两个异或相等数组的三元组数目</a>: 4分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/minimum-time-to-collect-all-apples-in-a-tree/" target="_blank" rel="noopener">收集树上所有苹果的最少时间</a>: 5分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/number-of-ways-of-cutting-a-pizza/" target="_blank" rel="noopener">切披萨的方案数</a>: 7分</li>
</ol>
<a id="more"></a>
<h3 id="用栈操作构建数组"><a href="#用栈操作构建数组" class="headerlink" title="用栈操作构建数组"></a><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/build-an-array-with-stack-operations/" target="_blank" rel="noopener">用栈操作构建数组</a></h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给你一个目标数组 <code>target</code> 和一个整数 <code>n</code>。每次迭代，需要从 <code>list = {1,2,3..., n}</code> 中依序读取一个数字。</p>
<p>请使用下述操作来构建目标数组 <code>target</code> ：</p>
<ul>
<li><strong>Push</strong>：从 <code>list</code> 中读取一个新元素， 并将其推入数组中。</li>
<li><strong>Pop</strong>：删除数组中的最后一个元素。</li>
<li>如果目标数组构建完成，就停止读取更多元素。</li>
</ul>
<p>题目数据保证目标数组严格递增，并且只包含 <code>1</code> 到 <code>n</code> 之间的数字。</p>
<p>请返回构建目标数组所用的操作序列。</p>
<p>题目数据保证答案是唯一的。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; [1,3], n &#x3D; 3</span><br><span class="line">输出：[&quot;Push&quot;,&quot;Push&quot;,&quot;Pop&quot;,&quot;Push&quot;]</span><br><span class="line">解释： </span><br><span class="line">读取 1 并自动推入数组 -&gt; [1]</span><br><span class="line">读取 2 并自动推入数组，然后删除它 -&gt; [1]</span><br><span class="line">读取 3 并自动推入数组 -&gt; [1,3]</span><br><span class="line"></span><br><span class="line">输入：target &#x3D; [1,2,3], n &#x3D; 3</span><br><span class="line">输出：[&quot;Push&quot;,&quot;Push&quot;,&quot;Push&quot;]</span><br><span class="line"></span><br><span class="line">输入：target &#x3D; [1,2], n &#x3D; 4</span><br><span class="line">输出：[&quot;Push&quot;,&quot;Push&quot;]</span><br><span class="line">解释：只需要读取前 2 个数字就可以停止。</span><br><span class="line"></span><br><span class="line">输入：target &#x3D; [2,3,4], n &#x3D; 4</span><br><span class="line">输出：[&quot;Push&quot;,&quot;Pop&quot;,&quot;Push&quot;,&quot;Push&quot;,&quot;Push&quot;]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; target.length &lt;&#x3D; 100</span><br><span class="line">1 &lt;&#x3D; target[i] &lt;&#x3D; 100</span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 100</span><br><span class="line">target 是严格递增的</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>从<code>List</code>中拿出元素必须是<code>{1,2,3...n}</code>的顺序，当拿出的元素不是需要的元素时，需要执行<code>Push</code>与<code>Pop</code>两个操作，当是需要的元素时，只执行<code>Push</code>操作，并且考虑下一个要拿出元素。</p>
<h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">buildArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> tn = target.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> item = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tn;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(item!=target[i])&#123;	<span class="comment">// 加入的值不是target[i]</span></span><br><span class="line">                res.push_back(<span class="string">"Push"</span>);</span><br><span class="line">                res.push_back(<span class="string">"Pop"</span>);</span><br><span class="line">                item++;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(<span class="string">"Push"</span>);</span><br><span class="line">            item++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="形成两个异或相等数组的三元组数目"><a href="#形成两个异或相等数组的三元组数目" class="headerlink" title="形成两个异或相等数组的三元组数目"></a><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/" target="_blank" rel="noopener">形成两个异或相等数组的三元组数目</a></h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>给你一个整数数组 <code>arr</code> 。</p>
<p>现需要从数组中取三个下标 <code>i</code>、<code>j</code> 和 <code>k</code> ，其中 <code>(0 &lt;= i &lt; j &lt;= k &lt; arr.length)</code> 。</p>
<p><code>a</code> 和 <code>b</code> 定义如下：</p>
<ul>
<li><code>a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]</code></li>
<li><code>b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]</code></li>
</ul>
<p>注意：<strong>^</strong> 表示 <strong>按位异或</strong> 操作。</p>
<p>请返回能够令 <code>a == b</code> 成立的三元组 (<code>i</code>, <code>j</code> , <code>k</code>) 的数目。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [2,3,1,6,7]</span><br><span class="line">输出：4</span><br><span class="line">解释：满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4)</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [1,1,1,1,1]</span><br><span class="line">输出：10</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [2,3]</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [1,3,5,7,9]</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [7,11,12,9,5,2,7,17,22]</span><br><span class="line">输出：8</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; arr.length &lt;&#x3D; 300</span><br><span class="line">1 &lt;&#x3D; arr[i] &lt;&#x3D; 10^8</span><br></pre></td></tr></table></figure>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>暴力枚举即可。</p>
<h4 id="实现示例-1"><a href="#实现示例-1" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                pre ^= nums[j<span class="number">-1</span>];	<span class="comment">// a</span></span><br><span class="line">                <span class="keyword">int</span> bac = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;n;k++)&#123;</span><br><span class="line">                    bac ^= nums[k];		<span class="comment">// b</span></span><br><span class="line">                    <span class="keyword">if</span>(pre == bac) res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="收集树上所有苹果的最少时间"><a href="#收集树上所有苹果的最少时间" class="headerlink" title="收集树上所有苹果的最少时间"></a><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/minimum-time-to-collect-all-apples-in-a-tree/" target="_blank" rel="noopener">收集树上所有苹果的最少时间</a></h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>给你一棵有 <code>n</code> 个节点的无向树，节点编号为 <code>0</code> 到 <code>n-1</code> ，它们中有一些节点有苹果。通过树上的一条边，需要花费 1 秒钟。你从 <strong>节点 0</strong> 出发，请你返回最少需要多少秒，可以收集到所有苹果，并回到节点 0 。</p>
<p>无向树的边由 <code>edges</code> 给出，其中 <code>edges[i] = [fromi, toi]</code> ，表示有一条边连接 <code>from</code> 和 <code>toi</code> 。除此以外，还有一个布尔数组 <code>hasApple</code> ，其中 <code>hasApple[i] = true</code> 代表节点 <code>i</code> 有一个苹果，否则，节点 <code>i</code> 没有苹果。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p><img src="/2020/05/10/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B188/min_time_collect_apple_1.png" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 7, edges &#x3D; [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple &#x3D; [false,false,true,false,true,true,false]</span><br><span class="line">输出：8 </span><br><span class="line">解释：上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/10/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B188/min_time_collect_apple_2.png" alt="2"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 7, edges &#x3D; [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple &#x3D; [false,false,true,false,false,true,false]</span><br><span class="line">输出：6</span><br><span class="line">解释：上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 7, edges &#x3D; [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple &#x3D; [false,false,false,false,false,false,false]</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 10^5</span><br><span class="line">edges.length &#x3D;&#x3D; n-1</span><br><span class="line">edges[i].length &#x3D;&#x3D; 2</span><br><span class="line">0 &lt;&#x3D; fromi, toi &lt;&#x3D; n-1</span><br><span class="line">fromi &lt; toi</span><br><span class="line">hasApple.length &#x3D;&#x3D; n</span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>观察到结果中的边都被使用了两次，因此求遍历的边数就可以得到答案。</p>
<p>问一：怎样的方案是最优的方案呢？</p>
<blockquote>
<p>贪心思想：对于某个根节点，如果左子树为空或者左子树中没有苹果，那么，该root到left的这条边不会被包含在结果中，右子树同理</p>
</blockquote>
<p>设结果为<code>set={e1,e2...}</code>,<code>set</code>中元素为边。(下面讨论的是<code>set</code>中的边)</p>
<p>问二: 子树中边的条数与根树中边的条数之间的递推关系是什么?</p>
<blockquote>
<p>设为$f(root),f(left),f(right)$</p>
<p>如果$f(left) != 0$,那么必然有边$(root,left)$,否则一定没有</p>
<p>同理$f(right)!=0$,那么必然有边$(root,right)$</p>
</blockquote>
<p>问三：怎么判断$f(left)$以及$f(right)$是否为0呢？</p>
<blockquote>
<p>已判断$f(left)$为例:</p>
<p>如果以$left$为根的树中含有苹果,那么$f(left)$一定不为0</p>
<p>即判断以$left$为根的树中是否含有苹果，如果有，则$f(left) != 0$,否则$f(left)=0$</p>
<p>那么就转化为求每个点以及子树包含的苹果的个数。</p>
</blockquote>
<p>问四：无向树如何<code>dfs</code>(不重复遍历)?</p>
<blockquote>
<p>对于一个顶点来说，除了父节点外，其他均是该顶点的子节点，因此只需标记父节点就行了。</p>
</blockquote>
<h4 id="实现示例-2"><a href="#实现示例-2" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 求to顶点及其子树包含的苹果个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;dp,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;g,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;ha)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[to] != <span class="number">-1</span>) <span class="keyword">return</span> dp[to];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ha[to]) ans++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:g[to])&#123;</span><br><span class="line">            <span class="keyword">if</span>(item==from) <span class="keyword">continue</span>;</span><br><span class="line">            ans+=dfs(to,item,dp,g,ha); <span class="comment">// 递归求子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        dp[to] = ans;</span><br><span class="line">        <span class="keyword">return</span> dp[to];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求to节点及其子树中包含的边数(结果set中的边)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;dp,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;g,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;ha)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[to]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:g[to])&#123;</span><br><span class="line">            <span class="keyword">if</span>(item==from) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[item]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ans +=<span class="number">1</span>+dfs2(to,item,dp,g,ha);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTime</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; hasApple)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">g</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; vis;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:edges)&#123;	<span class="comment">// 建立连接表</span></span><br><span class="line">            g[item[<span class="number">0</span>]].push_back(item[<span class="number">1</span>]);</span><br><span class="line">            g[item[<span class="number">1</span>]].push_back(item[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        dfs(<span class="number">-1</span>,<span class="number">0</span>,dp,g,hasApple);</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;n;i++) cout&lt;&lt;dp[i]&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * dfs2(<span class="number">-1</span>,<span class="number">0</span>,dp,g,hasApple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该题也有其他的实现方法，详情可以看看题目的题解部分。</p>
<h3 id="切披萨的方案数"><a href="#切披萨的方案数" class="headerlink" title="切披萨的方案数"></a><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/number-of-ways-of-cutting-a-pizza/" target="_blank" rel="noopener">切披萨的方案数</a></h3><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>给你一个 <code>rows x cols</code> 大小的矩形披萨和一个整数 <code>k</code> ，矩形包含两种字符： <code>&#39;A&#39;</code> （表示苹果）和 <code>&#39;.&#39;</code> （表示空白格子）。你需要切披萨 <code>k-1</code> 次，得到 <code>k</code> 块披萨并送给别人。</p>
<p>切披萨的每一刀，先要选择是向垂直还是水平方向切，再在矩形的边界上选一个切的位置，将披萨一分为二。如果垂直地切披萨，那么需要把左边的部分送给一个人，如果水平地切，那么需要把上面的部分送给一个人。在切完最后一刀后，需要把剩下来的一块送给最后一个人。</p>
<p>请你返回确保每一块披萨包含 <strong>至少</strong> 一个苹果的切披萨方案数。由于答案可能是个很大的数字，请你返回它对 10^9 + 7 取余的结果。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p><img src="/2020/05/10/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B188/ways_to_cut_apple_1.png" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：pizza &#x3D; [&quot;A..&quot;,&quot;AAA&quot;,&quot;...&quot;], k &#x3D; 3</span><br><span class="line">输出：3 </span><br><span class="line">解释：上图展示了三种切披萨的方案。注意每一块披萨都至少包含一个苹果。</span><br><span class="line"></span><br><span class="line">输入：pizza &#x3D; [&quot;A..&quot;,&quot;AA.&quot;,&quot;...&quot;], k &#x3D; 3</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：pizza &#x3D; [&quot;A..&quot;,&quot;A..&quot;,&quot;...&quot;], k &#x3D; 1</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; rows, cols &lt;&#x3D; 50</span><br><span class="line">rows &#x3D;&#x3D; pizza.length</span><br><span class="line">cols &#x3D;&#x3D; pizza[i].length</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; 10</span><br><span class="line">pizza 只包含字符 &#39;A&#39; 和 &#39;.&#39; 。</span><br></pre></td></tr></table></figure>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>关键词有逐步分割，逐步选择。联想到<code>DP</code>。</p>
<p>设要求的值为$f(m,n,k)$,表示有$m$行，$n$列,分割成$k$段的方案数。</p>
<p>问一：$f(m,n,k)$与$f(..,..,k-1)$有何关系?</p>
<blockquote>
<p>明显，</p>
<p>如果能在行上切一刀时,$f(m,n,k)$与$f(i,n,k-1)$$(0 \le i &lt; m)$有关</p>
<p>同理如果能在列上切一刀时，$f(m,n,k)$与$f(m,j,k-1)$$(0 \le j &lt; m)$有关</p>
</blockquote>
<p>问二：怎么判断在行上的一刀或者在列上的一刀是否合理？</p>
<blockquote>
<p>切出去的披萨是否含有苹果，含有的话，这一刀合理</p>
</blockquote>
<h4 id="实现示例-3"><a href="#实现示例-3" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ways</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; pizza, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = pizza.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = pizza[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="comment">// 是否要采取同下面代码中的上下翻转，左右翻转操作取决与你的DP状态表示方法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;	<span class="comment">// 左右翻转</span></span><br><span class="line">            reverse(pizza[i].<span class="built_in">begin</span>(),pizza[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(m/<span class="number">2</span>);i++)&#123;	<span class="comment">// 上下翻转</span></span><br><span class="line">            <span class="built_in">string</span> temp =pizza[i];</span><br><span class="line">            pizza[i] = pizza[m<span class="number">-1</span>-i];</span><br><span class="line">            pizza[m<span class="number">-1</span>-i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">ts</span><span class="params">(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(pizza[i<span class="number">-1</span>][j<span class="number">-1</span>]==<span class="string">'A'</span>) temp++;</span><br><span class="line">                ts[i][j] = ts[i<span class="number">-1</span>][j]+ts[i][j<span class="number">-1</span>]-ts[i<span class="number">-1</span>][j<span class="number">-1</span>]+temp;	<span class="comment">// 二维前缀和</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k+<span class="number">1</span>,<span class="number">0</span>)))</span></span>;</span><br><span class="line">        <span class="comment">// DP初始条件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>) dp[i][j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=k;p++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> ki=<span class="number">1</span>;ki&lt;i;ki++)&#123; <span class="comment">// dp[i][j][p]与dp[ki][j][p-1]</span></span><br><span class="line">                        <span class="keyword">int</span> temp = ts[i][j]-ts[ki][j];</span><br><span class="line">                        <span class="keyword">if</span>(temp==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        dp[i][j][p] = (dp[i][j][p]+dp[ki][j][p<span class="number">-1</span>])%MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> kj=<span class="number">1</span>;kj&lt;j;kj++)&#123;	<span class="comment">// dp[i][j][p]与dp[i][kj][p-1]</span></span><br><span class="line">                        <span class="keyword">int</span> temp = ts[i][j]-ts[i][kj];</span><br><span class="line">                        <span class="comment">// cout&lt;&lt;temp&lt;&lt;endl;</span></span><br><span class="line">                        <span class="keyword">if</span>(temp==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        dp[i][j][p] = (dp[i][j][p]+dp[i][kj][p<span class="number">-1</span>])%MOD;</span><br><span class="line">                        <span class="comment">// cout&lt;&lt;dp[i][j][k]&lt;&lt;endl;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(ts[i][j])&#123;	<span class="comment">// 整个分给一个人</span></span><br><span class="line">                        dp[i][j][p] = (dp[i][j][p]+dp[<span class="number">0</span>][<span class="number">0</span>][p<span class="number">-1</span>])%MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;dp[m][n][1]&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> dp[m][n][k]%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说，题目难度不算很大，前两题直接模拟或者暴力枚举即可。</p>
<p>第三题卡了一会儿，不是非常熟悉无向树的dfs写法，写得有点慢。</p>
<p>第4题记得<code>codeforces</code>上做过一个类似的<code>DP</code>题，调试花了一会儿，还是初始条件的设置容易出问题。</p>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣每日打卡20200507</title>
    <url>/2020/05/07/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A120200507/</url>
    <content><![CDATA[<p>这篇文章是关于<code>力扣每日打卡</code>的题目的一点点记录。</p>
<p>题目: <a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">另一个树的子树</a></p>
<p>难度：易</p>
<a id="more"></a>
<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定的树 s:</span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line"> 给定的树t:</span><br><span class="line">   4 </span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line"> 返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</span><br><span class="line"> </span><br><span class="line"> 给定的树 s：</span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line">    &#x2F;</span><br><span class="line">   0</span><br><span class="line">给定的树 t：</span><br><span class="line">   4</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line"> 返回 false。</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><code>t</code>要是<code>s</code>的子树，只能是下面的三种情形:</p>
<ol>
<li><code>t</code>是<code>s</code>的左子树的子树</li>
<li><code>t</code>是<code>s</code>的右子树的子树</li>
<li><code>t</code>与<code>s</code>相同</li>
</ol>
<p>上面1、2两点可以通过递归调用<code>isSubTree</code>实现，第3点可以通过写一个辅助函数<code>is_same</code>实现，同时<code>is_same</code>函数同样是递归结构。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_same</span><span class="params">(TreeNode *s,TreeNode *t)</span></span>&#123;  <span class="comment">// 相同的树结构</span></span><br><span class="line">        <span class="keyword">if</span>(s==t &amp;&amp; s==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s-&gt;val != t-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> is_same(s-&gt;left,t-&gt;left) &amp;&amp; is_same(s-&gt;right,t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(isSubtree(s-&gt;left,t)) <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">// t是s的左子树的子树</span></span><br><span class="line">        <span class="keyword">if</span>(isSubtree(s-&gt;right,t)) <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">// t是s的右子树的子树</span></span><br><span class="line">        <span class="keyword">return</span> is_same(s,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>要点是递归</li>
<li>分析递归基</li>
</ol>
<p>总的来说该题难度很小，只需要细致地分析其递归基就能很快地写出<code>bug free</code>的代码。</p>
]]></content>
      <categories>
        <category>力扣打卡</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>力扣</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣周赛190</title>
    <url>/2020/05/24/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B190/</url>
    <content><![CDATA[<p>这篇文章主要记录一下第190场周赛的题目解答。以下是四个题目:</p>
<ol>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/" target="_blank" rel="noopener">检查单词是否为句中其他单词的前缀</a>: 3分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/maximum-number-of-vowels-in-a-substring-of-given-length/" target="_blank" rel="noopener">定长子串中元音的最大数目</a>: 4分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/pseudo-palindromic-paths-in-a-binary-tree/" target="_blank" rel="noopener">二叉树中的伪回文路径</a>: 5分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/max-dot-product-of-two-subsequences/" target="_blank" rel="noopener">两个子序列的最大点积</a>: 6分</li>
</ol>
<a id="more"></a>
<h3 id="检查单词是否为句中其他单词的前缀"><a href="#检查单词是否为句中其他单词的前缀" class="headerlink" title="检查单词是否为句中其他单词的前缀"></a><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/" target="_blank" rel="noopener">检查单词是否为句中其他单词的前缀</a></h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给你一个字符串 <code>sentence</code> 作为句子并指定检索词为 <code>searchWord</code> ，其中句子由若干用 <strong>单个空格</strong> 分隔的单词组成。</p>
<p>请你检查检索词 <code>searchWord</code> 是否为句子 <code>sentence</code> 中任意单词的前缀。</p>
<ul>
<li>如果 <code>searchWord</code> 是某一个单词的前缀，则返回句子 <code>sentence</code> 中该单词所对应的下标（<strong>下标从 1 开始</strong>）。</li>
<li>如果 <code>searchWord</code> 是多个单词的前缀，则返回匹配的第一个单词的下标（<strong>最小下标</strong>）。</li>
<li>如果 <code>searchWord</code> 不是任何单词的前缀，则返回 <strong>-1</strong> 。</li>
</ul>
<p>字符串 <code>S</code> 的 「前缀」是 <code>S</code> 的任何前导连续子字符串。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：sentence &#x3D; &quot;i love eating burger&quot;, searchWord &#x3D; &quot;burg&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：&quot;burg&quot; 是 &quot;burger&quot; 的前缀，而 &quot;burger&quot; 是句子中第 4 个单词。</span><br><span class="line"></span><br><span class="line">输入：sentence &#x3D; &quot;this problem is an easy problem&quot;, searchWord &#x3D; &quot;pro&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：&quot;pro&quot; 是 &quot;problem&quot; 的前缀，而 &quot;problem&quot; 是句子中第 2 个也是第 6 个单词，但是应该返回最小下标 2 。</span><br><span class="line"></span><br><span class="line">输入：sentence &#x3D; &quot;i am tired&quot;, searchWord &#x3D; &quot;you&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：&quot;you&quot; 不是句子中任何单词的前缀。</span><br><span class="line"></span><br><span class="line">输入：sentence &#x3D; &quot;i use triple pillow&quot;, searchWord &#x3D; &quot;pill&quot;</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">输入：sentence &#x3D; &quot;hello from the other side&quot;, searchWord &#x3D; &quot;they&quot;</span><br><span class="line">输出：-1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; sentence.length &lt;&#x3D; 100</span><br><span class="line">1 &lt;&#x3D; searchWord.length &lt;&#x3D; 10</span><br><span class="line">sentence 由小写英文字母和空格组成。</span><br><span class="line">searchWord 由小写英文字母组成。</span><br><span class="line">前缀就是紧密附着于词根的语素，中间不能插入其它成分，并且它的位置是固定的——-位于词根之前。（引用自 前缀_百度百科 ）</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>按照题目要求模拟：</p>
<ol>
<li>获取字符串中的单词</li>
<li>判断<code>serachWord</code>是不是单词的前缀</li>
</ol>
<h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">isPrefixOfWord</span><span class="params">(<span class="built_in">string</span> sentence, <span class="built_in">string</span> searchWord)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> temp;	<span class="comment">// 单词</span></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">1</span>;	<span class="comment">// 单词的下标</span></span><br><span class="line">        <span class="keyword">int</span> n = sentence.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==n || sentence[i]==<span class="string">' '</span>)&#123;	<span class="comment">// 一个新单词产生</span></span><br><span class="line">                <span class="keyword">if</span>(temp==<span class="string">""</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 判断searchWord是不是单词的前缀</span></span><br><span class="line">                <span class="keyword">if</span>(temp.substr(<span class="number">0</span>,searchWord.<span class="built_in">size</span>()) == searchWord)&#123;	</span><br><span class="line">                    <span class="keyword">return</span> idx;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = <span class="string">""</span>;</span><br><span class="line">                idx+=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp+=sentence[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="定长子串中元音的最大数目"><a href="#定长子串中元音的最大数目" class="headerlink" title="定长子串中元音的最大数目"></a><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/maximum-number-of-vowels-in-a-substring-of-given-length/" target="_blank" rel="noopener">定长子串中元音的最大数目</a></h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>给你字符串 <code>s</code> 和整数 <code>k</code> 。</p>
<p>请返回字符串 <code>s</code> 中长度为 <code>k</code> 的单个子字符串中可能包含的最大元音字母数。</p>
<p>英文中的 <strong>元音字母</strong> 为（<code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>）。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abciiidef&quot;, k &#x3D; 3</span><br><span class="line">输出：3</span><br><span class="line">解释：子字符串 &quot;iii&quot; 包含 3 个元音字母。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aeiou&quot;, k &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line">解释：任意长度为 2 的子字符串都包含 2 个元音字母。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;leetcode&quot;, k &#x3D; 3</span><br><span class="line">输出：2</span><br><span class="line">解释：&quot;lee&quot;、&quot;eet&quot; 和 &quot;ode&quot; 都包含 2 个元音字母。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;rhythms&quot;, k &#x3D; 4</span><br><span class="line">输出：0</span><br><span class="line">解释：字符串 s 中不含任何元音字母。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;tryhard&quot;, k &#x3D; 4</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; s.length &lt;&#x3D; 10^5</span><br><span class="line">s 由小写英文字母组成</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; s.length</span><br></pre></td></tr></table></figure>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><code>k</code>是窗口的大小，用滑动窗口来模拟即可。</p>
<h4 id="实现示例-1"><a href="#实现示例-1" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxVowels</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;	<span class="comment">// 保存窗口内中的元音字符个数</span></span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:<span class="string">"aeiou"</span>)&#123;</span><br><span class="line">            t.insert(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cnt+=t.count(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=k)&#123;	<span class="comment">// 弹出窗口的队尾</span></span><br><span class="line">                cnt-=t.count(s[i-k]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=(k<span class="number">-1</span>))&#123;	<span class="comment">// 更新res</span></span><br><span class="line">                res = <span class="built_in">max</span>(res,cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树中的伪回文路径"><a href="#二叉树中的伪回文路径" class="headerlink" title="二叉树中的伪回文路径"></a><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/pseudo-palindromic-paths-in-a-binary-tree/" target="_blank" rel="noopener">二叉树中的伪回文路径</a></h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「<strong>伪回文</strong>」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。</p>
<p>请你返回从根到叶子节点的所有路径中 <strong>伪回文</strong> 路径的数目。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p><img src="/2020/05/24/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B190/palindromic_paths_1.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,null,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span> </span><br><span class="line">解释：上图为给定的二叉树。总共有 <span class="number">3</span> 条从根到叶子的路径：红色路径 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>] ，绿色路径 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>] 和路径 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>] 。</span><br><span class="line">     在这些路径中，只有红色和绿色的路径是伪回文路径，因为红色路径 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>] 存在回文排列 [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>] ，绿色路径 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>] 存在回文排列 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 。</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/24/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B190/palindromic_paths_2.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [2,1,1,1,3,null,null,null,null,null,1]</span><br><span class="line">输出：1 </span><br><span class="line">解释：上图为给定二叉树。总共有 3 条从根到叶子的路径：绿色路径 [2,1,1] ，路径 [2,1,3,1] 和路径 [2,1] 。</span><br><span class="line">     这些路径中只有绿色路径是伪回文路径，因为 [2,1,1] 存在回文排列 [1,2,1] 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [9]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>由题意可得:</p>
<ol>
<li>只用判断叶子节点</li>
<li>要保存从根节点到叶子节点的所有值能否构成回文</li>
</ol>
<p>用<code>dfs</code>来遍历整棵树，同时采用前序遍历的方式，而且要保存从根到当前节点中包含的所有数字，当是叶子节点时，判断保存的所有数字能否构成回文字符串。</p>
<p>问:那么到底该怎么判断一个数字集合能否构成回文字符串呢?</p>
<blockquote>
<p>观察得到回文字符串左右两端对称，那么除中间元素以外的所有元素的次数必然是偶数。</p>
<p>因此，如果能构成回文串，那么每种元素的出现次数必然是偶数个或者仅有一种元素出现奇数次。只需求解出现次数为奇数的元素种类的个数。</p>
<p>例如:</p>
<p>1出现5 次，2 出现2次，3出现4次</p>
<p>那么可以构成回文串，因为出现奇数次的元素只有1，因此可以构成。</p>
<p>1出现5 次，2 出现2次，3出现3次</p>
<p>那么不能构成回文串，因为出现奇数次的元素有1，3，因此不能构成。</p>
</blockquote>
<p>问: 是否需要保存每个元素的具体出现次数呢？</p>
<blockquote>
<p>不需要，在上面的讨论中，我们只用到了每个元素出现次数的奇偶性，因此可以用一个二进制数表述。</p>
<p>比如说:</p>
<p>001001011表示</p>
<p>987654321中1，2，4，7出现了奇数，其他出现了偶数次</p>
</blockquote>
<h4 id="实现示例-2"><a href="#实现示例-2" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 求[1,9]中包含奇数个元素的种类数。</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> &amp;mask)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = mask;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            res+=n&amp;<span class="number">1</span>;</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res &lt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> &amp;mask,<span class="keyword">int</span> &amp;res,TreeNode *root)</span></span>&#123;</span><br><span class="line">        mask ^= (<span class="number">1</span>&lt;&lt;(root-&gt;val<span class="number">-1</span>)); <span class="comment">// 当前元素的出现次数+1(奇偶数改变)</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; check(mask))&#123;res+=<span class="number">1</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123; dfs(mask,res,root-&gt;left);&#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123; dfs(mask,res,root-&gt;right);&#125;</span><br><span class="line">        mask ^= (<span class="number">1</span>&lt;&lt;(root-&gt;val<span class="number">-1</span>));	<span class="comment">// 回溯</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pseudoPalindromicPaths</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">        dfs(mask,res,root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最初的写法是用一个数组保存每个元素的出现次数，处理方式基本是相同的，用<code>bitmask</code>应该更省内存，运行速度也更快一些。下面是直接用数组来保存每个元素的出现次数的代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:dp)&#123;</span><br><span class="line">            res += item%<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res&lt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;dp,<span class="keyword">int</span> &amp;res,TreeNode *root)</span></span>&#123;</span><br><span class="line">        dp[root-&gt;val]+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; check(dp))&#123;</span><br><span class="line">            res+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            dfs(dp,res,root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            dfs(dp,res,root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[root-&gt;val]-=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pseudoPalindromicPaths</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">10</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dfs(dp,res,root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="两个子序列的最大点积"><a href="#两个子序列的最大点积" class="headerlink" title="两个子序列的最大点积"></a><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/max-dot-product-of-two-subsequences/" target="_blank" rel="noopener">两个子序列的最大点积</a></h3><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>给你两个数组 <code>nums1</code> 和 <code>nums2</code> 。</p>
<p>请你返回 <code>nums1</code> 和 <code>nums2</code> 中两个长度相同的 <strong>非空</strong> 子序列的最大点积。</p>
<p>数组的非空子序列是通过删除原数组中某些元素（可能一个也不删除）后剩余数字组成的序列，但不能改变数字间相对顺序。比方说，<code>[2,3,5]</code> 是 <code>[1,2,3,4,5]</code> 的一个子序列而 <code>[1,5,3]</code> 不是。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums1 &#x3D; [2,1,-2,5], nums2 &#x3D; [3,0,-6]</span><br><span class="line">输出：18</span><br><span class="line">解释：从 nums1 中得到子序列 [2,-2] ，从 nums2 中得到子序列 [3,-6] 。</span><br><span class="line">它们的点积为 (2*3 + (-2)*(-6)) &#x3D; 18 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums1 &#x3D; [3,-2], nums2 &#x3D; [2,-6,7]</span><br><span class="line">输出：21</span><br><span class="line">解释：从 nums1 中得到子序列 [3] ，从 nums2 中得到子序列 [7] 。</span><br><span class="line">它们的点积为 (3*7) &#x3D; 21 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums1 &#x3D; [-1,-1], nums2 &#x3D; [1,1]</span><br><span class="line">输出：-1</span><br><span class="line">解释：从 nums1 中得到子序列 [-1] ，从 nums2 中得到子序列 [1] 。</span><br><span class="line">它们的点积为 -1 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; nums1.length, nums2.length &lt;&#x3D; 500</span><br><span class="line">-1000 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>动态规划思想，一旦发现题目中的操作有分步进行的，可以考虑<code>dp</code>。</p>
<p><code>dp</code>的状态如何定义呢?</p>
<blockquote>
<p>明显$dp[i][j]$表示前$i$个<code>nums1</code>元素与前$j$个nums2`元素的最大点积。</p>
</blockquote>
<p><code>dp</code>的状态如何转化呢?</p>
<blockquote>
<p> $dp[i][j] = min(dp[i-1][j-1]+nums1[i] * nums2[j],dp[i][j-1],dp[i-1][j])$</p>
</blockquote>
<p>初始状态如何呢?</p>
<blockquote>
<p>$dp[0][j]=0,dp[i][0]=0$</p>
</blockquote>
<p>明显题意中<code>nums1</code>与<code>nums2</code>中至少都要取一个元素，因此要考虑如果最后<code>dp</code>结果为0时的情形</p>
<h4 id="实现示例-3"><a href="#实现示例-3" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDotProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> NIL = -(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,NIL))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = NIL;</span><br><span class="line">        <span class="keyword">int</span> lm = NIL;</span><br><span class="line">        <span class="keyword">int</span> rmn = -NIL;</span><br><span class="line">        <span class="comment">// 在nums1中与nums2中各选取一个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">            dp[i+<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i]&lt;=<span class="number">0</span>) lm = <span class="built_in">max</span>(lm,nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums2[j]&gt;=<span class="number">0</span>) rmn = <span class="built_in">min</span>(rmn,nums2[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        res = lm*rmn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                dp[i][j] = nums1[i<span class="number">-1</span>] * nums2[j<span class="number">-1</span>]+dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="comment">// cout&lt;&lt;dp[i][j]&lt;&lt;endl;</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j<span class="number">-1</span>],dp[i][j]);</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j]);</span><br><span class="line">                <span class="comment">// cout&lt;&lt;dp[i][j]&lt;&lt;endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[m][n]) <span class="keyword">return</span> dp[m][n];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>题目难度小，属于手速场，好多高手很快AK了。自己在第三题的回溯上出了点bug，花了几分钟调试了一下。第四题难度不大，但是在处理初始条件上也花了时间来调试。总的来说，动态规划的题目思路找对后要仔细地揣摩初始条件以及边界条件。</p>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
</search>
