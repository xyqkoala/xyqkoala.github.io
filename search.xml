<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>力扣双周赛33</title>
    <url>/2020/08/23/%E5%8A%9B%E6%89%A3%E5%8F%8C%E5%91%A8%E8%B5%9B33/</url>
    <content><![CDATA[<p>这篇文章主要记录一下第33场力扣双周赛的题目解答。以下是四个题目:</p>
<ol>
<li><a href="https://leetcode-cn.com/contest/biweekly-contest-33/problems/thousand-separator/" target="_blank" rel="noopener">千位分隔数</a>: 3分</li>
<li><a href="https://leetcode-cn.com/contest/biweekly-contest-33/problems/minimum-number-of-vertices-to-reach-all-nodes/" target="_blank" rel="noopener">可以到达所有点的最少点数目</a>: 4分</li>
<li><a href="https://leetcode-cn.com/contest/biweekly-contest-33/problems/minimum-numbers-of-function-calls-to-make-target-array/" target="_blank" rel="noopener">得到目标数组的最少函数调用次数</a>: 5分</li>
<li><a href="https://leetcode-cn.com/contest/biweekly-contest-33/problems/detect-cycles-in-2d-grid/" target="_blank" rel="noopener">二维网格图中探测环</a>: 6分</li>
</ol>
<a id="more"></a>
<h3 id="千位分隔数"><a href="#千位分隔数" class="headerlink" title="千位分隔数"></a><a href="https://leetcode-cn.com/contest/biweekly-contest-33/problems/thousand-separator/" target="_blank" rel="noopener">千位分隔数</a></h3><p>题目意思就是从低位开始，每三位之间添加一个“.”符号。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>按照题意模拟即可。</p>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">thousandSeparator</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="built_in">string</span> temp = to_string(n);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tn = temp.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(tn);i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt &amp;&amp; cnt%<span class="number">3</span>==<span class="number">0</span>) res.push_back(<span class="string">'.'</span>);</span><br><span class="line">            res.push_back(temp[tn<span class="number">-1</span>-i]);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="可以到达所有点的最少点数目"><a href="#可以到达所有点的最少点数目" class="headerlink" title="可以到达所有点的最少点数目"></a><a href="https://leetcode-cn.com/contest/biweekly-contest-33/problems/minimum-number-of-vertices-to-reach-all-nodes/" target="_blank" rel="noopener">可以到达所有点的最少点数目</a></h3><p>题目的意思是选取一个最小的节点集合，使得通过这些点可以访问所有点。</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>按照拓扑排序的思路，找到入度为0的顶点即可。</p>
<h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findSmallestSetOfVertices</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">deg</span><span class="params">(n,<span class="number">0</span>)</span></span>;	<span class="comment">// 入度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:edges)&#123;</span><br><span class="line">            deg[item[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(deg[i]==<span class="number">0</span>) res.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="得到目标数组的最少函数调用次数"><a href="#得到目标数组的最少函数调用次数" class="headerlink" title="得到目标数组的最少函数调用次数"></a><a href="https://leetcode-cn.com/contest/biweekly-contest-33/problems/minimum-numbers-of-function-calls-to-make-target-array/" target="_blank" rel="noopener">得到目标数组的最少函数调用次数</a></h3><p>题意就是按照题目的要求构造出给定的数组。求需要的最小次数。</p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>我们对每个数而言，加法是单独的，因此加法必须单独计算。</p>
<p>乘法呢，取所有数的最大值即可。</p>
<h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>,mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> n = item;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;   <span class="comment">// 加法次数</span></span><br><span class="line">            <span class="keyword">int</span> y = <span class="number">0</span>;  <span class="comment">// 乘法次数</span></span><br><span class="line">            <span class="keyword">while</span>(n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(n%<span class="number">2</span>)&#123;x++;&#125;</span><br><span class="line">                y++;</span><br><span class="line">                n = n/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx,y<span class="number">-1</span>);</span><br><span class="line">            res+=x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res+mx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二维网格图中探测环"><a href="#二维网格图中探测环" class="headerlink" title="二维网格图中探测环"></a><a href="https://leetcode-cn.com/contest/biweekly-contest-33/problems/detect-cycles-in-2d-grid/" target="_blank" rel="noopener">二维网格图中探测环</a></h3><p>题目的意思很明确，相邻的元素如果字母相同，则连通。找这图中是否有环存在。</p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>判环用dfs是常见的解法。并查集也是很常见的求解方法。这里使用并查集。</p>
<h4 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;t,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[x]!=x) t[x] = <span class="built_in">find</span>(t,t[x]);</span><br><span class="line">        <span class="keyword">return</span> t[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsCycle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">t</span><span class="params">(m*n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(m*n);i++)&#123;t[i] = i;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &amp;&amp; grid[i][j]==grid[i<span class="number">-1</span>][j])&#123;	<span class="comment">// 连通上下</span></span><br><span class="line">                    <span class="keyword">int</span> fx = <span class="built_in">find</span>(t,n*(i<span class="number">-1</span>)+j);</span><br><span class="line">                    <span class="keyword">int</span> fy = <span class="built_in">find</span>(t,n*i+j);</span><br><span class="line">                    t[fy] = fx;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j &amp;&amp; grid[i][j]==grid[i][j<span class="number">-1</span>])&#123;	<span class="comment">// 连通左右</span></span><br><span class="line">                    <span class="keyword">int</span> fx = <span class="built_in">find</span>(t,n*i+j<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">int</span> fy = <span class="built_in">find</span>(t,n*i+j);</span><br><span class="line">                    <span class="keyword">if</span>(fx==fy)&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">                    t[fy] = fx;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>简单模拟</li>
<li>拓扑排序，入度求解</li>
<li>求一个数的二进制表示</li>
<li>并查集或者DFS</li>
</ol>
<p>难度不大，第二次进前50名，有进步，也是运气好。在写代码的过程中基本没有调试，很顺利。前排的高手真的厉害👍，膜拜一波。</p>
]]></content>
      <categories>
        <category>力扣双周赛</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/30/hello-world/</url>
    <content><![CDATA[<p>这篇文章主要用来测试自己的博客。检测搭建的博客是否有问题。</p>
<p>主要测试排版以及数学公式的使用。</p>
<a id="more"></a>
<h4 id="cpp代码块"><a href="#cpp代码块" class="headerlink" title="cpp代码块"></a><code>cpp</code>代码块</h4><p>下面测试一下博客的代码块功能，不关注语法高亮。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello,World!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mathjax公式块"><a href="#mathjax公式块" class="headerlink" title="mathjax公式块"></a><code>mathjax</code>公式块</h4><h5 id="行间公式"><a href="#行间公式" class="headerlink" title="行间公式"></a>行间公式</h5><p>测试在<code>markdown</code>文档中插入独占一行的公式。</p>
<script type="math/tex; mode=display">
\frac{x}{y} = cos(x_{1}+x_{1}^{2})</script><h5 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h5><p>测试在<code>markdown</code>文档中嵌入文章内的公式。</p>
<p>公式前 $\frac{x}{y} = cos(x_{1}+x_{1}^{2})$ 公式后。</p>
<h4 id="rust代码块"><a href="#rust代码块" class="headerlink" title="rust代码块"></a><code>rust</code>代码块</h4><p>下面测试以下<code>rust</code>代码的代码块。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,<span class="string">"Hello,World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣周赛186</title>
    <url>/2020/04/30/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B186/</url>
    <content><![CDATA[<p>鄙文章是第186场周赛的题目解答。题目个数仍然是四个。四个小题的分数分别是：</p>
<ol>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/maximum-score-after-splitting-a-string/" target="_blank" rel="noopener">分割字符串的最大得分</a> : 3 分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/maximum-points-you-can-obtain-from-cards/" target="_blank" rel="noopener">可获得的最大点数</a> :  4分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/diagonal-traverse-ii/" target="_blank" rel="noopener">对角线遍历 II</a> : 5分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/constrained-subsequence-sum/" target="_blank" rel="noopener">带限制的子序列和</a> : 6分</li>
</ol>
<a id="more"></a>
<h3 id="分割字符串的最大得分"><a href="#分割字符串的最大得分" class="headerlink" title="分割字符串的最大得分"></a><a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/maximum-score-after-splitting-a-string/" target="_blank" rel="noopener">分割字符串的最大得分</a></h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给你一个由若干 0 和 1 组成的字符串 <code>s</code> ，请你计算并返回将该字符串分割成两个 <strong>非空</strong> 子字符串（即 <strong>左</strong> 子字符串和 <strong>右</strong> 子字符串）所能获得的最大得分。</p>
<p>「分割字符串的得分」为 <strong>左</strong> 子字符串中 <strong>0</strong> 的数量加上 <strong>右</strong> 子字符串中 <strong>1</strong> 的数量。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;011101&quot;</span><br><span class="line">输出：5 </span><br><span class="line">解释：</span><br><span class="line">将字符串 s 划分为两个非空子字符串的可行方案有：</span><br><span class="line">左子字符串 &#x3D; &quot;0&quot; 且 右子字符串 &#x3D; &quot;11101&quot;，得分 &#x3D; 1 + 4 &#x3D; 5 </span><br><span class="line">左子字符串 &#x3D; &quot;01&quot; 且 右子字符串 &#x3D; &quot;1101&quot;，得分 &#x3D; 1 + 3 &#x3D; 4 </span><br><span class="line">左子字符串 &#x3D; &quot;011&quot; 且 右子字符串 &#x3D; &quot;101&quot;，得分 &#x3D; 1 + 2 &#x3D; 3 </span><br><span class="line">左子字符串 &#x3D; &quot;0111&quot; 且 右子字符串 &#x3D; &quot;01&quot;，得分 &#x3D; 1 + 1 &#x3D; 2 </span><br><span class="line">左子字符串 &#x3D; &quot;01110&quot; 且 右子字符串 &#x3D; &quot;1&quot;，得分 &#x3D; 2 + 1 &#x3D; 3</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;00111&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：当 左子字符串 &#x3D; &quot;00&quot; 且 右子字符串 &#x3D; &quot;111&quot; 时，我们得到最大得分 &#x3D; 2 + 3 &#x3D; 5</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;1111&quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>要找到一个分割点，这个分割点将字符串<code>s</code>分为两个<strong>非空</strong>的子串。按照题目要求遍历所有的可能分割点，求每个分割点的得分并取最大值。</p>
<h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(item ==<span class="string">'1'</span>) cnt++;	<span class="comment">// 整个串中'1'的个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> tcnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n<span class="number">-1</span>);i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'1'</span>) tcnt+=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 左串'0'的个数为(i+1-tcnt)</span></span><br><span class="line">            <span class="comment">// 右串'1'的个数为(cnt-tcnt)</span></span><br><span class="line">            res = <span class="built_in">max</span>(res,i+<span class="number">1</span>-tcnt+cnt-tcnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="可获得的最大点数"><a href="#可获得的最大点数" class="headerlink" title="可获得的最大点数"></a><a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/maximum-points-you-can-obtain-from-cards/" target="_blank" rel="noopener">可获得的最大点数</a></h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>几张卡牌 <strong>排成一行</strong>，每张卡牌都有一个对应的点数。点数由整数数组 <code>cardPoints</code> 给出。</p>
<p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 <code>k</code> 张卡牌。</p>
<p>你的点数就是你拿到手中的所有卡牌的点数之和。</p>
<p>给你一个整数数组 <code>cardPoints</code> 和整数 <code>k</code>，请你返回可以获得的最大点数。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：cardPoints &#x3D; [1,2,3,4,5,6,1], k &#x3D; 3</span><br><span class="line">输出：12</span><br><span class="line">解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 &#x3D; 12 。</span><br><span class="line"></span><br><span class="line">输入：cardPoints &#x3D; [2,2,2], k &#x3D; 2</span><br><span class="line">输出：4</span><br><span class="line">解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。</span><br><span class="line"></span><br><span class="line">输入：cardPoints &#x3D; [9,7,7,9,7,7,9], k &#x3D; 7</span><br><span class="line">输出：55</span><br><span class="line">解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。</span><br></pre></td></tr></table></figure>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>由于只能从两端取元素，最终只能是左侧取$cnt(0 \le cnt \le k)$个元素，右侧取$k-cnt$个元素，枚举$cnt$的所有可能取值，并更新最大得分。</p>
<h4 id="实现示例-1"><a href="#实现示例-1" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cp, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = cp.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-k;i&lt;n;i++)&#123;</span><br><span class="line">            r+=cp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;<span class="comment">// 左侧取(i+1)个元素</span></span><br><span class="line">            l+=cp[i];   <span class="comment">// 左侧得分</span></span><br><span class="line">            r-=cp[n-k+i];   <span class="comment">// 右侧得分</span></span><br><span class="line">            res = max(res,l+r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="对角线遍历-II"><a href="#对角线遍历-II" class="headerlink" title="对角线遍历 II"></a><a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/diagonal-traverse-ii/" target="_blank" rel="noopener">对角线遍历 II</a></h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>给你一个列表 <code>nums</code> ，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 <code>nums</code> 中对角线上的整数。</p>
<p><img src="/2020/04/30/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B186/sample_1_1784.png" alt="11"></p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,4,2,7,5,3,8,6,9]</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]</span><br><span class="line">输出：[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [[1,2,3],[4],[5,6,7],[8],[9,10,11]]</span><br><span class="line">输出：[1,4,2,5,3,8,6,9,7,10,11]</span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>元素的访问顺序是按照位置(0,0)的<code>bfs</code>遍历来的，并且下面的元素优先。因此按照<code>bfs</code>的思路遍历即可。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dir =&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">deque</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; que;</span><br><span class="line">        que.push_back(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        res.push_back(nums[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> m = nums.size();</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> tm = que.size();</span><br><span class="line">            <span class="keyword">while</span>(tm--)&#123;</span><br><span class="line">                <span class="keyword">auto</span> p = que.front();</span><br><span class="line">                que.pop_front();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = p.first+dir[i][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y = p.second+dir[i][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(x&gt;=m || y&gt;=nums[x].size() || nums[x][y]==<span class="number">0</span>)&#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line">                    que.push_back(&#123;x,y&#125;);</span><br><span class="line">                    res.push_back(nums[x][y]);</span><br><span class="line">                    nums[x][y] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="带限制的子序列和"><a href="#带限制的子序列和" class="headerlink" title="带限制的子序列和"></a><a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/constrained-subsequence-sum/" target="_blank" rel="noopener">带限制的子序列和</a></h3><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回 <strong>非空</strong> 子序列元素和的最大值，子序列需要满足：子序列中每两个 <strong>相邻</strong> 的整数 <code>nums[i]</code> 和 <code>nums[j]</code> ，它们在原数组中的下标 <code>i</code> 和 <code>j</code> 满足 <code>i &lt; j</code> 且 <code>j - i &lt;= k</code> 。</p>
<p>数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [10,2,-10,5,20], k &#x3D; 2</span><br><span class="line">输出：37</span><br><span class="line">解释：子序列为 [10, 2, 5, 20] 。</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [-1,-2,-3], k &#x3D; 1</span><br><span class="line">输出：-1</span><br><span class="line">解释：子序列必须是非空的，所以我们选择最大的数字。</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [10,-2,-10,-5,20], k &#x3D; 2</span><br><span class="line">输出：23</span><br><span class="line">解释：子序列为 [10, -2, -5, 20] 。</span><br></pre></td></tr></table></figure>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>设前$n$个元素的结果为$dp[n]$（包含第$n$个元素）,思考以下$dp[n]$与$dp[1],dp[2]…dp[n-1]$之间的递推关系。</p>
<p>明显可以得到：$dp[n] = max(dp[n-k]…dp[n-1])+nums[n-1]$。因此通过朴素的$dp$思路可以求得结果。但是提交会超时，那么，如何优化呢？</p>
<p>由上面的$dp$的递推方程可以看到，只要能快速获得前$k$个元素的最大值,那么$dp[n]$就可以很快的得到。</p>
<p>获得一个区间内的最大元素可以使用<code>线段树</code>来实现。</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegTree</span>&#123;</span>	<span class="comment">// 线段树</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree;</span><br><span class="line">    SegTree(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        t=nums;</span><br><span class="line">        <span class="keyword">int</span> n =t.<span class="built_in">size</span>();</span><br><span class="line">        tree=<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span> * n+<span class="number">1</span>,<span class="number">-1e5</span><span class="number">-1</span>);</span><br><span class="line">        buildTree(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = t.<span class="built_in">size</span>();</span><br><span class="line">        updateTree(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,i,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n =t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> query(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e,<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;e) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(s==e)&#123;</span><br><span class="line">            tree[node]=t[s];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (s+e)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> l_n = <span class="number">2</span> * node +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r_n = <span class="number">2</span> * node +<span class="number">2</span>;</span><br><span class="line">        buildTree(s,m,l_n);</span><br><span class="line">        buildTree(m+<span class="number">1</span>,e,r_n);</span><br><span class="line">        tree[node]= <span class="built_in">max</span>(tree[l_n],tree[r_n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateTree</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e,<span class="keyword">int</span> node,<span class="keyword">int</span> idx,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==e)&#123;</span><br><span class="line">            tree[node]=<span class="built_in">max</span>(tree[node],val);</span><br><span class="line">            t[idx]=val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (s+e)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> l_n=<span class="number">2</span>*node+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r_n = <span class="number">2</span> * node+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx&gt;=s &amp;&amp; idx &lt;= m)&#123;</span><br><span class="line">            updateTree(s,m,l_n,idx,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            updateTree(m+<span class="number">1</span>,e,r_n,idx,val);</span><br><span class="line">        &#125;</span><br><span class="line">        tree[node]= <span class="built_in">max</span>(tree[l_n],tree[r_n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e,<span class="keyword">int</span> node,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;s||l&gt;e) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s&gt;=l&amp;&amp;e&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">return</span> tree[node];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (s+e)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> l_n = <span class="number">2</span> * node +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r_n = <span class="number">2</span> * node +<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> ls = query(s, m,l_n,l, r);</span><br><span class="line">        <span class="keyword">int</span> rs = query(m+<span class="number">1</span>,e,r_n,l,r);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ls,rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">constrainedSubsetSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> tree = SegTree(nums);</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        tree.update(<span class="number">0</span>,nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="built_in">max</span>(i-k,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> item = <span class="built_in">max</span>(<span class="number">0</span>,tree.sumRange(l,i<span class="number">-1</span>));</span><br><span class="line">            res = <span class="built_in">max</span>(res,item+nums[i]);</span><br><span class="line">            tree.update(i,item+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>题目本身难度不算太大，但自己对线段树的写法还不是特别熟练，因此在第4题上遇到了一点问题。第3题也超时了一次，总的来说是做题要保持做题的手感，不然很难写出bug free的代码。</p>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣周赛188</title>
    <url>/2020/05/10/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B188/</url>
    <content><![CDATA[<p>这篇文章主要记录一下第188场周赛的题目解答。以下是四个题目：</p>
<ol>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/build-an-array-with-stack-operations/" target="_blank" rel="noopener">用栈操作构建数组</a>: 3分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/" target="_blank" rel="noopener">形成两个异或相等数组的三元组数目</a>: 4分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/minimum-time-to-collect-all-apples-in-a-tree/" target="_blank" rel="noopener">收集树上所有苹果的最少时间</a>: 5分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/number-of-ways-of-cutting-a-pizza/" target="_blank" rel="noopener">切披萨的方案数</a>: 7分</li>
</ol>
<a id="more"></a>
<h3 id="用栈操作构建数组"><a href="#用栈操作构建数组" class="headerlink" title="用栈操作构建数组"></a><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/build-an-array-with-stack-operations/" target="_blank" rel="noopener">用栈操作构建数组</a></h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给你一个目标数组 <code>target</code> 和一个整数 <code>n</code>。每次迭代，需要从 <code>list = {1,2,3..., n}</code> 中依序读取一个数字。</p>
<p>请使用下述操作来构建目标数组 <code>target</code> ：</p>
<ul>
<li><strong>Push</strong>：从 <code>list</code> 中读取一个新元素， 并将其推入数组中。</li>
<li><strong>Pop</strong>：删除数组中的最后一个元素。</li>
<li>如果目标数组构建完成，就停止读取更多元素。</li>
</ul>
<p>题目数据保证目标数组严格递增，并且只包含 <code>1</code> 到 <code>n</code> 之间的数字。</p>
<p>请返回构建目标数组所用的操作序列。</p>
<p>题目数据保证答案是唯一的。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; [1,3], n &#x3D; 3</span><br><span class="line">输出：[&quot;Push&quot;,&quot;Push&quot;,&quot;Pop&quot;,&quot;Push&quot;]</span><br><span class="line">解释： </span><br><span class="line">读取 1 并自动推入数组 -&gt; [1]</span><br><span class="line">读取 2 并自动推入数组，然后删除它 -&gt; [1]</span><br><span class="line">读取 3 并自动推入数组 -&gt; [1,3]</span><br><span class="line"></span><br><span class="line">输入：target &#x3D; [1,2,3], n &#x3D; 3</span><br><span class="line">输出：[&quot;Push&quot;,&quot;Push&quot;,&quot;Push&quot;]</span><br><span class="line"></span><br><span class="line">输入：target &#x3D; [1,2], n &#x3D; 4</span><br><span class="line">输出：[&quot;Push&quot;,&quot;Push&quot;]</span><br><span class="line">解释：只需要读取前 2 个数字就可以停止。</span><br><span class="line"></span><br><span class="line">输入：target &#x3D; [2,3,4], n &#x3D; 4</span><br><span class="line">输出：[&quot;Push&quot;,&quot;Pop&quot;,&quot;Push&quot;,&quot;Push&quot;,&quot;Push&quot;]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; target.length &lt;&#x3D; 100</span><br><span class="line">1 &lt;&#x3D; target[i] &lt;&#x3D; 100</span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 100</span><br><span class="line">target 是严格递增的</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>从<code>List</code>中拿出元素必须是<code>{1,2,3...n}</code>的顺序，当拿出的元素不是需要的元素时，需要执行<code>Push</code>与<code>Pop</code>两个操作，当是需要的元素时，只执行<code>Push</code>操作，并且考虑下一个要拿出元素。</p>
<h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">buildArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> tn = target.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> item = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tn;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(item!=target[i])&#123;	<span class="comment">// 加入的值不是target[i]</span></span><br><span class="line">                res.push_back(<span class="string">"Push"</span>);</span><br><span class="line">                res.push_back(<span class="string">"Pop"</span>);</span><br><span class="line">                item++;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(<span class="string">"Push"</span>);</span><br><span class="line">            item++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="形成两个异或相等数组的三元组数目"><a href="#形成两个异或相等数组的三元组数目" class="headerlink" title="形成两个异或相等数组的三元组数目"></a><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/" target="_blank" rel="noopener">形成两个异或相等数组的三元组数目</a></h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>给你一个整数数组 <code>arr</code> 。</p>
<p>现需要从数组中取三个下标 <code>i</code>、<code>j</code> 和 <code>k</code> ，其中 <code>(0 &lt;= i &lt; j &lt;= k &lt; arr.length)</code> 。</p>
<p><code>a</code> 和 <code>b</code> 定义如下：</p>
<ul>
<li><code>a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]</code></li>
<li><code>b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]</code></li>
</ul>
<p>注意：<strong>^</strong> 表示 <strong>按位异或</strong> 操作。</p>
<p>请返回能够令 <code>a == b</code> 成立的三元组 (<code>i</code>, <code>j</code> , <code>k</code>) 的数目。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [2,3,1,6,7]</span><br><span class="line">输出：4</span><br><span class="line">解释：满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4)</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [1,1,1,1,1]</span><br><span class="line">输出：10</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [2,3]</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [1,3,5,7,9]</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [7,11,12,9,5,2,7,17,22]</span><br><span class="line">输出：8</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; arr.length &lt;&#x3D; 300</span><br><span class="line">1 &lt;&#x3D; arr[i] &lt;&#x3D; 10^8</span><br></pre></td></tr></table></figure>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>暴力枚举即可。</p>
<h4 id="实现示例-1"><a href="#实现示例-1" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                pre ^= nums[j<span class="number">-1</span>];	<span class="comment">// a</span></span><br><span class="line">                <span class="keyword">int</span> bac = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;n;k++)&#123;</span><br><span class="line">                    bac ^= nums[k];		<span class="comment">// b</span></span><br><span class="line">                    <span class="keyword">if</span>(pre == bac) res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="收集树上所有苹果的最少时间"><a href="#收集树上所有苹果的最少时间" class="headerlink" title="收集树上所有苹果的最少时间"></a><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/minimum-time-to-collect-all-apples-in-a-tree/" target="_blank" rel="noopener">收集树上所有苹果的最少时间</a></h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>给你一棵有 <code>n</code> 个节点的无向树，节点编号为 <code>0</code> 到 <code>n-1</code> ，它们中有一些节点有苹果。通过树上的一条边，需要花费 1 秒钟。你从 <strong>节点 0</strong> 出发，请你返回最少需要多少秒，可以收集到所有苹果，并回到节点 0 。</p>
<p>无向树的边由 <code>edges</code> 给出，其中 <code>edges[i] = [fromi, toi]</code> ，表示有一条边连接 <code>from</code> 和 <code>toi</code> 。除此以外，还有一个布尔数组 <code>hasApple</code> ，其中 <code>hasApple[i] = true</code> 代表节点 <code>i</code> 有一个苹果，否则，节点 <code>i</code> 没有苹果。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p><img src="/2020/05/10/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B188/min_time_collect_apple_1.png" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 7, edges &#x3D; [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple &#x3D; [false,false,true,false,true,true,false]</span><br><span class="line">输出：8 </span><br><span class="line">解释：上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/10/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B188/min_time_collect_apple_2.png" alt="2"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 7, edges &#x3D; [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple &#x3D; [false,false,true,false,false,true,false]</span><br><span class="line">输出：6</span><br><span class="line">解释：上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 7, edges &#x3D; [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple &#x3D; [false,false,false,false,false,false,false]</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 10^5</span><br><span class="line">edges.length &#x3D;&#x3D; n-1</span><br><span class="line">edges[i].length &#x3D;&#x3D; 2</span><br><span class="line">0 &lt;&#x3D; fromi, toi &lt;&#x3D; n-1</span><br><span class="line">fromi &lt; toi</span><br><span class="line">hasApple.length &#x3D;&#x3D; n</span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>观察到结果中的边都被使用了两次，因此求遍历的边数就可以得到答案。</p>
<p>问一：怎样的方案是最优的方案呢？</p>
<blockquote>
<p>贪心思想：对于某个根节点，如果左子树为空或者左子树中没有苹果，那么，该root到left的这条边不会被包含在结果中，右子树同理</p>
</blockquote>
<p>设结果为<code>set={e1,e2...}</code>,<code>set</code>中元素为边。(下面讨论的是<code>set</code>中的边)</p>
<p>问二: 子树中边的条数与根树中边的条数之间的递推关系是什么?</p>
<blockquote>
<p>设为$f(root),f(left),f(right)$</p>
<p>如果$f(left) != 0$,那么必然有边$(root,left)$,否则一定没有</p>
<p>同理$f(right)!=0$,那么必然有边$(root,right)$</p>
</blockquote>
<p>问三：怎么判断$f(left)$以及$f(right)$是否为0呢？</p>
<blockquote>
<p>已判断$f(left)$为例:</p>
<p>如果以$left$为根的树中含有苹果,那么$f(left)$一定不为0</p>
<p>即判断以$left$为根的树中是否含有苹果，如果有，则$f(left) != 0$,否则$f(left)=0$</p>
<p>那么就转化为求每个点以及子树包含的苹果的个数。</p>
</blockquote>
<p>问四：无向树如何<code>dfs</code>(不重复遍历)?</p>
<blockquote>
<p>对于一个顶点来说，除了父节点外，其他均是该顶点的子节点，因此只需标记父节点就行了。</p>
</blockquote>
<h4 id="实现示例-2"><a href="#实现示例-2" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 求to顶点及其子树包含的苹果个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;dp,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;g,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;ha)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[to] != <span class="number">-1</span>) <span class="keyword">return</span> dp[to];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ha[to]) ans++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:g[to])&#123;</span><br><span class="line">            <span class="keyword">if</span>(item==from) <span class="keyword">continue</span>;</span><br><span class="line">            ans+=dfs(to,item,dp,g,ha); <span class="comment">// 递归求子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        dp[to] = ans;</span><br><span class="line">        <span class="keyword">return</span> dp[to];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求to节点及其子树中包含的边数(结果set中的边)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;dp,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;g,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;ha)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[to]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:g[to])&#123;</span><br><span class="line">            <span class="keyword">if</span>(item==from) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[item]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ans +=<span class="number">1</span>+dfs2(to,item,dp,g,ha);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTime</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; hasApple)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">g</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; vis;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:edges)&#123;	<span class="comment">// 建立连接表</span></span><br><span class="line">            g[item[<span class="number">0</span>]].push_back(item[<span class="number">1</span>]);</span><br><span class="line">            g[item[<span class="number">1</span>]].push_back(item[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        dfs(<span class="number">-1</span>,<span class="number">0</span>,dp,g,hasApple);</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;n;i++) cout&lt;&lt;dp[i]&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * dfs2(<span class="number">-1</span>,<span class="number">0</span>,dp,g,hasApple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该题也有其他的实现方法，详情可以看看题目的题解部分。</p>
<h3 id="切披萨的方案数"><a href="#切披萨的方案数" class="headerlink" title="切披萨的方案数"></a><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/number-of-ways-of-cutting-a-pizza/" target="_blank" rel="noopener">切披萨的方案数</a></h3><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>给你一个 <code>rows x cols</code> 大小的矩形披萨和一个整数 <code>k</code> ，矩形包含两种字符： <code>&#39;A&#39;</code> （表示苹果）和 <code>&#39;.&#39;</code> （表示空白格子）。你需要切披萨 <code>k-1</code> 次，得到 <code>k</code> 块披萨并送给别人。</p>
<p>切披萨的每一刀，先要选择是向垂直还是水平方向切，再在矩形的边界上选一个切的位置，将披萨一分为二。如果垂直地切披萨，那么需要把左边的部分送给一个人，如果水平地切，那么需要把上面的部分送给一个人。在切完最后一刀后，需要把剩下来的一块送给最后一个人。</p>
<p>请你返回确保每一块披萨包含 <strong>至少</strong> 一个苹果的切披萨方案数。由于答案可能是个很大的数字，请你返回它对 10^9 + 7 取余的结果。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p><img src="/2020/05/10/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B188/ways_to_cut_apple_1.png" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：pizza &#x3D; [&quot;A..&quot;,&quot;AAA&quot;,&quot;...&quot;], k &#x3D; 3</span><br><span class="line">输出：3 </span><br><span class="line">解释：上图展示了三种切披萨的方案。注意每一块披萨都至少包含一个苹果。</span><br><span class="line"></span><br><span class="line">输入：pizza &#x3D; [&quot;A..&quot;,&quot;AA.&quot;,&quot;...&quot;], k &#x3D; 3</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：pizza &#x3D; [&quot;A..&quot;,&quot;A..&quot;,&quot;...&quot;], k &#x3D; 1</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; rows, cols &lt;&#x3D; 50</span><br><span class="line">rows &#x3D;&#x3D; pizza.length</span><br><span class="line">cols &#x3D;&#x3D; pizza[i].length</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; 10</span><br><span class="line">pizza 只包含字符 &#39;A&#39; 和 &#39;.&#39; 。</span><br></pre></td></tr></table></figure>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>关键词有逐步分割，逐步选择。联想到<code>DP</code>。</p>
<p>设要求的值为$f(m,n,k)$,表示有$m$行，$n$列,分割成$k$段的方案数。</p>
<p>问一：$f(m,n,k)$与$f(..,..,k-1)$有何关系?</p>
<blockquote>
<p>明显，</p>
<p>如果能在行上切一刀时,$f(m,n,k)$与$f(i,n,k-1)$$(0 \le i &lt; m)$有关</p>
<p>同理如果能在列上切一刀时，$f(m,n,k)$与$f(m,j,k-1)$$(0 \le j &lt; m)$有关</p>
</blockquote>
<p>问二：怎么判断在行上的一刀或者在列上的一刀是否合理？</p>
<blockquote>
<p>切出去的披萨是否含有苹果，含有的话，这一刀合理</p>
</blockquote>
<h4 id="实现示例-3"><a href="#实现示例-3" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ways</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; pizza, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = pizza.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = pizza[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="comment">// 是否要采取同下面代码中的上下翻转，左右翻转操作取决与你的DP状态表示方法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;	<span class="comment">// 左右翻转</span></span><br><span class="line">            reverse(pizza[i].<span class="built_in">begin</span>(),pizza[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(m/<span class="number">2</span>);i++)&#123;	<span class="comment">// 上下翻转</span></span><br><span class="line">            <span class="built_in">string</span> temp =pizza[i];</span><br><span class="line">            pizza[i] = pizza[m<span class="number">-1</span>-i];</span><br><span class="line">            pizza[m<span class="number">-1</span>-i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">ts</span><span class="params">(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(pizza[i<span class="number">-1</span>][j<span class="number">-1</span>]==<span class="string">'A'</span>) temp++;</span><br><span class="line">                ts[i][j] = ts[i<span class="number">-1</span>][j]+ts[i][j<span class="number">-1</span>]-ts[i<span class="number">-1</span>][j<span class="number">-1</span>]+temp;	<span class="comment">// 二维前缀和</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k+<span class="number">1</span>,<span class="number">0</span>)))</span></span>;</span><br><span class="line">        <span class="comment">// DP初始条件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>) dp[i][j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=k;p++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> ki=<span class="number">1</span>;ki&lt;i;ki++)&#123; <span class="comment">// dp[i][j][p]与dp[ki][j][p-1]</span></span><br><span class="line">                        <span class="keyword">int</span> temp = ts[i][j]-ts[ki][j];</span><br><span class="line">                        <span class="keyword">if</span>(temp==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        dp[i][j][p] = (dp[i][j][p]+dp[ki][j][p<span class="number">-1</span>])%MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> kj=<span class="number">1</span>;kj&lt;j;kj++)&#123;	<span class="comment">// dp[i][j][p]与dp[i][kj][p-1]</span></span><br><span class="line">                        <span class="keyword">int</span> temp = ts[i][j]-ts[i][kj];</span><br><span class="line">                        <span class="comment">// cout&lt;&lt;temp&lt;&lt;endl;</span></span><br><span class="line">                        <span class="keyword">if</span>(temp==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        dp[i][j][p] = (dp[i][j][p]+dp[i][kj][p<span class="number">-1</span>])%MOD;</span><br><span class="line">                        <span class="comment">// cout&lt;&lt;dp[i][j][k]&lt;&lt;endl;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(ts[i][j])&#123;	<span class="comment">// 整个分给一个人</span></span><br><span class="line">                        dp[i][j][p] = (dp[i][j][p]+dp[<span class="number">0</span>][<span class="number">0</span>][p<span class="number">-1</span>])%MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;dp[m][n][1]&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> dp[m][n][k]%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说，题目难度不算很大，前两题直接模拟或者暴力枚举即可。</p>
<p>第三题卡了一会儿，不是非常熟悉无向树的dfs写法，写得有点慢。</p>
<p>第4题记得<code>codeforces</code>上做过一个类似的<code>DP</code>题，调试花了一会儿，还是初始条件的设置容易出问题。</p>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣周赛187</title>
    <url>/2020/05/06/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B187/</url>
    <content><![CDATA[<p>这篇文章主要记录一下第187场周赛的题目解答。以下是四个题目：</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/destination-city/" target="_blank" rel="noopener">旅行终点站</a>: 3分</li>
<li><a href="https://leetcode-cn.com/problems/check-if-all-1s-are-at-least-length-k-places-away/" target="_blank" rel="noopener">是否所有1都至少相隔k个元素</a>: 4分</li>
<li><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" target="_blank" rel="noopener">绝对差不超过限制的最长连续子数组</a>: 5分</li>
<li><a href="https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/" target="_blank" rel="noopener">有序矩阵中的第 k 个最小数组和</a>: 7分</li>
</ol>
<a id="more"></a>
<h3 id="旅行终点站"><a href="#旅行终点站" class="headerlink" title="旅行终点站"></a><a href="https://leetcode-cn.com/problems/destination-city/" target="_blank" rel="noopener">旅行终点站</a></h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。</p>
<p>题目数据保证线路图会形成一条不存在循环的线路，因此只会有一个旅行终点站。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：paths &#x3D; [[&quot;London&quot;,&quot;New York&quot;],[&quot;New York&quot;,&quot;Lima&quot;],[&quot;Lima&quot;,&quot;Sao Paulo&quot;]]</span><br><span class="line">输出：&quot;Sao Paulo&quot; </span><br><span class="line">解释：从 &quot;London&quot; 出发，最后抵达终点站 &quot;Sao Paulo&quot; 。本次旅行的路线是 &quot;London&quot; -&gt; &quot;New York&quot; -&gt; &quot;Lima&quot; -&gt; &quot;Sao Paulo&quot; 。</span><br><span class="line"></span><br><span class="line">输入：paths &#x3D; [[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;,&quot;B&quot;],[&quot;C&quot;,&quot;A&quot;]]</span><br><span class="line">输出：&quot;A&quot;</span><br><span class="line">解释：所有可能的线路是：</span><br><span class="line">&quot;D&quot; -&gt; &quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;A&quot;. </span><br><span class="line">显然，旅行终点站是 &quot;A&quot; 。</span><br><span class="line"></span><br><span class="line">输入：paths &#x3D; [[&quot;A&quot;,&quot;Z&quot;]]</span><br><span class="line">输出：&quot;Z&quot;</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; paths.length &lt;&#x3D; 100</span><br><span class="line">paths[i].length &#x3D;&#x3D; 2</span><br><span class="line">1 &lt;&#x3D; cityAi.length, cityBi.length &lt;&#x3D; 10</span><br><span class="line">cityAi !&#x3D; cityBi</span><br><span class="line">所有字符串均由大小写英文字母和空格字符组成。</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>是一个有向图问题，注意到只有一个终点并且没有环，同时每个节点的<code>出度</code>最多为$1$，所以从任意节点出发，沿有向边遍历一定可以到达终点，不妨取$paths[0][0]$或者$paths[0][1]$。</p>
<h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">destCity</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:paths)&#123;</span><br><span class="line">            t[item[<span class="number">0</span>]] = item[<span class="number">1</span>];	<span class="comment">// 建立边</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> res = paths[<span class="number">0</span>][<span class="number">1</span>];	<span class="comment">// 从paths[0][1]出发</span></span><br><span class="line">        <span class="keyword">while</span>(t.<span class="built_in">find</span>(res) != t.<span class="built_in">end</span>())&#123;	<span class="comment">// 存在有向边，则跳转到下一个节点</span></span><br><span class="line">            res = t[res];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="是否所有1都至少相隔k个元素"><a href="#是否所有1都至少相隔k个元素" class="headerlink" title="是否所有1都至少相隔k个元素"></a><a href="https://leetcode-cn.com/problems/check-if-all-1s-are-at-least-length-k-places-away/" target="_blank" rel="noopener">是否所有1都至少相隔k个元素</a></h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>给你一个由若干 <code>0</code> 和 <code>1</code> 组成的数组 <code>nums</code> 以及整数 <code>k</code>。如果所有 <code>1</code> 都至少相隔 <code>k</code> 个元素，则返回 <code>True</code> ；否则，返回 <code>False</code> 。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p><img src="/2020/05/06/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B187/sample_1_1791.png" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,0,0,0,1,0,0,1], k &#x3D; 2</span><br><span class="line">输出：true</span><br><span class="line">解释：每个 1 都至少相隔 2 个元素。</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/06/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B187/sample_2_1791.png" alt="2"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,0,0,1,0,1], k &#x3D; 2</span><br><span class="line">输出：false</span><br><span class="line">解释：第二个 1 和第三个 1 之间只隔了 1 个元素。</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,1,1,1,1], k &#x3D; 0</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [0,1,0,1], k &#x3D; 1</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</span><br><span class="line">0 &lt;&#x3D; k &lt;&#x3D; nums.length</span><br><span class="line">nums[i] 的值为 0 或 1</span><br></pre></td></tr></table></figure>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>只需判断连续的$0$的个数是否都<strong>大于等于</strong>$k$。也即任意连个不相连的$1$的距离都大于$k$。</p>
<h4 id="实现示例-1"><a href="#实现示例-1" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">kLengthApart</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;	<span class="comment">// 连续0的个数</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt &amp;&amp; cnt&lt;k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> cnt&gt;=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="绝对差不超过限制的最长连续子数组"><a href="#绝对差不超过限制的最长连续子数组" class="headerlink" title="绝对差不超过限制的最长连续子数组"></a><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" target="_blank" rel="noopener">绝对差不超过限制的最长连续子数组</a></h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>给你一个整数数组 <code>nums</code>，和一个表示限制的整数 <code>limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 <code>limit</code>。</p>
<p>如果不存在满足条件的子数组，则返回 0 。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [8,2,4,7], limit &#x3D; 4</span><br><span class="line">输出：2 </span><br><span class="line">解释：所有子数组如下：</span><br><span class="line">[8] 最大绝对差 |8-8| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">[8,2] 最大绝对差 |8-2| &#x3D; 6 &gt; 4. </span><br><span class="line">[8,2,4] 最大绝对差 |8-2| &#x3D; 6 &gt; 4.</span><br><span class="line">[8,2,4,7] 最大绝对差 |8-2| &#x3D; 6 &gt; 4.</span><br><span class="line">[2] 最大绝对差 |2-2| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">[2,4] 最大绝对差 |2-4| &#x3D; 2 &lt;&#x3D; 4.</span><br><span class="line">[2,4,7] 最大绝对差 |2-7| &#x3D; 5 &gt; 4.</span><br><span class="line">[4] 最大绝对差 |4-4| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">[4,7] 最大绝对差 |4-7| &#x3D; 3 &lt;&#x3D; 4.</span><br><span class="line">[7] 最大绝对差 |7-7| &#x3D; 0 &lt;&#x3D; 4. </span><br><span class="line">因此，满足题意的最长子数组的长度为 2 。</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [10,1,2,4,7,2], limit &#x3D; 5</span><br><span class="line">输出：4 </span><br><span class="line">解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| &#x3D; 5 &lt;&#x3D; 5 。</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [4,2,2,2,4,4,2,2], limit &#x3D; 0</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</span><br><span class="line">1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9</span><br><span class="line">0 &lt;&#x3D; limit &lt;&#x3D; 10^9</span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>数据范围很大，因此$O(n^2)$的解法是会超时的。考虑滑动窗口(双指针)，窗口中维护所有元素并能快速的得到窗口中元素的最值，考虑用<code>ordered_set</code>，由于元素可能重复因此使用<code>map</code>或者<code>multiset</code>。</p>
<h4 id="实现示例-2"><a href="#实现示例-2" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; t;	<span class="comment">// 元素值 -&gt; 次数</span></span><br><span class="line">        <span class="keyword">int</span> n  = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;	<span class="comment">// 慢指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;	<span class="comment">// 快指针</span></span><br><span class="line">            t[nums[i]]++;</span><br><span class="line">            <span class="keyword">auto</span> ite = t.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">auto</span> mn = ite-&gt;first;</span><br><span class="line">            ite = t.<span class="built_in">end</span>();</span><br><span class="line">            --ite;</span><br><span class="line">            <span class="keyword">auto</span> mx = ite-&gt;first;</span><br><span class="line">            <span class="keyword">if</span>((mx-mn) &lt;= k)&#123;	<span class="comment">// 仍然满足条件</span></span><br><span class="line">                res = <span class="built_in">max</span>(res,i+<span class="number">1</span>-pre);</span><br><span class="line">                <span class="comment">// cout&lt;&lt;1&lt;&lt;": "&lt;&lt;res&lt;&lt;endl;</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;	<span class="comment">// 慢指针前移</span></span><br><span class="line">                <span class="keyword">while</span>(pre&lt;i)&#123;	</span><br><span class="line">                    <span class="comment">// cout&lt;&lt;pre&lt;&lt;endl;</span></span><br><span class="line">                    t[nums[pre]]--;</span><br><span class="line">                    <span class="keyword">if</span>(t[nums[pre]] == <span class="number">0</span>) t.erase(nums[pre]);</span><br><span class="line">                    pre+=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">auto</span> ite = t.<span class="built_in">begin</span>();</span><br><span class="line">                    <span class="keyword">auto</span> tmn = ite-&gt;first;</span><br><span class="line">                    ite = t.<span class="built_in">end</span>();</span><br><span class="line">                    --ite;</span><br><span class="line">                    <span class="keyword">auto</span> tmx = ite-&gt;first;</span><br><span class="line">                    <span class="keyword">if</span>((tmx-tmn)&lt;=k)&#123;	<span class="comment">// 满足条件，停止慢指针前移</span></span><br><span class="line">                        res = <span class="built_in">max</span>(res,i+<span class="number">1</span>-pre);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该题也有其他的实现方法，详情可以看看题目的题解部分。</p>
<h3 id="有序矩阵中的第-k-个最小数组和"><a href="#有序矩阵中的第-k-个最小数组和" class="headerlink" title="有序矩阵中的第 k 个最小数组和"></a><a href="https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/" target="_blank" rel="noopener">有序矩阵中的第 k 个最小数组和</a></h3><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>给你一个 m * n 的矩阵 mat，以及一个整数 k ，矩阵中的每一行都以非递减的顺序排列。</p>
<p>你可以从每一行中选出 1 个元素形成一个数组。返回所有可能数组中的第 k 个 最小 数组和。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：mat &#x3D; [[1,3,11],[2,4,6]], k &#x3D; 5</span><br><span class="line">输出：7</span><br><span class="line">解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：</span><br><span class="line">[1,2], [1,4], [3,2], [3,4], [1,6]。其中第 5 个的和是 7 。  </span><br><span class="line"></span><br><span class="line">输入：mat &#x3D; [[1,3,11],[2,4,6]], k &#x3D; 9</span><br><span class="line">输出：17</span><br><span class="line"></span><br><span class="line">输入：mat &#x3D; [[1,10,10],[1,4,5],[2,3,6]], k &#x3D; 7</span><br><span class="line">输出：9</span><br><span class="line">解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：</span><br><span class="line">[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]。其中第 7 个的和是 9 。 </span><br><span class="line"></span><br><span class="line">输入：mat &#x3D; [[1,1,10],[2,2,9]], k &#x3D; 7</span><br><span class="line">输出：12</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">m &#x3D;&#x3D; mat.length</span><br><span class="line">n &#x3D;&#x3D; mat.length[i]</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 40</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; min(200, n ^ m)</span><br><span class="line">1 &lt;&#x3D; mat[i][j] &lt;&#x3D; 5000</span><br><span class="line">mat[i] 是一个非递减数组</span><br></pre></td></tr></table></figure>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>第$k$小(或大)的元素，考虑用贪心的优先队列。</p>
<p>直观上看当每行取第1个元素时最小，下一个元素必然是某行的元素索引向后移动一位，至于是哪一位，放入优先队列中进行比较可得，同理可得到第$k$小的元素。</p>
<h4 id="实现示例-3"><a href="#实现示例-3" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; que;	<span class="comment">// 总和，索引列表</span></span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vis;</span><br><span class="line">        <span class="keyword">int</span> m = mat.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vis.insert(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m,<span class="number">0</span>));	<span class="comment">// 防止重复遍历</span></span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">int</span> tcnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            tcnt+=mat[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        que.push(&#123;-tcnt,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m,<span class="number">0</span>)&#125;);</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">auto</span> table= p.second;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;	<span class="comment">// 每个下一个元素加入优先队列中</span></span><br><span class="line">                <span class="keyword">int</span> item = table[i];</span><br><span class="line">                <span class="keyword">if</span>((item+<span class="number">1</span>)&gt;=n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">auto</span> temp = table;</span><br><span class="line">                temp[i]++;</span><br><span class="line">                <span class="keyword">if</span>(vis.count(temp)) <span class="keyword">continue</span>;</span><br><span class="line">                vis.insert(temp);</span><br><span class="line">                <span class="keyword">int</span> res = -p.first;</span><br><span class="line">                res+=mat[i][item+<span class="number">1</span>]-mat[i][item];</span><br><span class="line">                res = -res;</span><br><span class="line">                que.push(&#123;res,temp&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -que.top().first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>题解中也有使用<code>二分</code>的写法，这里就不搬运了，感兴趣的可以到该题目的题解处看看。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>抽象能力还是有待提高，要将题目转化成数学表示，再然后是代码实现。滑动窗口问题最近出现较频繁，题目也并不容易，有待进一步的总结，练习。</p>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣周赛190</title>
    <url>/2020/05/24/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B190/</url>
    <content><![CDATA[<p>这篇文章主要记录一下第190场周赛的题目解答。以下是四个题目:</p>
<ol>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/" target="_blank" rel="noopener">检查单词是否为句中其他单词的前缀</a>: 3分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/maximum-number-of-vowels-in-a-substring-of-given-length/" target="_blank" rel="noopener">定长子串中元音的最大数目</a>: 4分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/pseudo-palindromic-paths-in-a-binary-tree/" target="_blank" rel="noopener">二叉树中的伪回文路径</a>: 5分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/max-dot-product-of-two-subsequences/" target="_blank" rel="noopener">两个子序列的最大点积</a>: 6分</li>
</ol>
<a id="more"></a>
<h3 id="检查单词是否为句中其他单词的前缀"><a href="#检查单词是否为句中其他单词的前缀" class="headerlink" title="检查单词是否为句中其他单词的前缀"></a><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/" target="_blank" rel="noopener">检查单词是否为句中其他单词的前缀</a></h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给你一个字符串 <code>sentence</code> 作为句子并指定检索词为 <code>searchWord</code> ，其中句子由若干用 <strong>单个空格</strong> 分隔的单词组成。</p>
<p>请你检查检索词 <code>searchWord</code> 是否为句子 <code>sentence</code> 中任意单词的前缀。</p>
<ul>
<li>如果 <code>searchWord</code> 是某一个单词的前缀，则返回句子 <code>sentence</code> 中该单词所对应的下标（<strong>下标从 1 开始</strong>）。</li>
<li>如果 <code>searchWord</code> 是多个单词的前缀，则返回匹配的第一个单词的下标（<strong>最小下标</strong>）。</li>
<li>如果 <code>searchWord</code> 不是任何单词的前缀，则返回 <strong>-1</strong> 。</li>
</ul>
<p>字符串 <code>S</code> 的 「前缀」是 <code>S</code> 的任何前导连续子字符串。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：sentence &#x3D; &quot;i love eating burger&quot;, searchWord &#x3D; &quot;burg&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：&quot;burg&quot; 是 &quot;burger&quot; 的前缀，而 &quot;burger&quot; 是句子中第 4 个单词。</span><br><span class="line"></span><br><span class="line">输入：sentence &#x3D; &quot;this problem is an easy problem&quot;, searchWord &#x3D; &quot;pro&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：&quot;pro&quot; 是 &quot;problem&quot; 的前缀，而 &quot;problem&quot; 是句子中第 2 个也是第 6 个单词，但是应该返回最小下标 2 。</span><br><span class="line"></span><br><span class="line">输入：sentence &#x3D; &quot;i am tired&quot;, searchWord &#x3D; &quot;you&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：&quot;you&quot; 不是句子中任何单词的前缀。</span><br><span class="line"></span><br><span class="line">输入：sentence &#x3D; &quot;i use triple pillow&quot;, searchWord &#x3D; &quot;pill&quot;</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">输入：sentence &#x3D; &quot;hello from the other side&quot;, searchWord &#x3D; &quot;they&quot;</span><br><span class="line">输出：-1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; sentence.length &lt;&#x3D; 100</span><br><span class="line">1 &lt;&#x3D; searchWord.length &lt;&#x3D; 10</span><br><span class="line">sentence 由小写英文字母和空格组成。</span><br><span class="line">searchWord 由小写英文字母组成。</span><br><span class="line">前缀就是紧密附着于词根的语素，中间不能插入其它成分，并且它的位置是固定的——-位于词根之前。（引用自 前缀_百度百科 ）</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>按照题目要求模拟：</p>
<ol>
<li>获取字符串中的单词</li>
<li>判断<code>serachWord</code>是不是单词的前缀</li>
</ol>
<h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">isPrefixOfWord</span><span class="params">(<span class="built_in">string</span> sentence, <span class="built_in">string</span> searchWord)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> temp;	<span class="comment">// 单词</span></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">1</span>;	<span class="comment">// 单词的下标</span></span><br><span class="line">        <span class="keyword">int</span> n = sentence.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==n || sentence[i]==<span class="string">' '</span>)&#123;	<span class="comment">// 一个新单词产生</span></span><br><span class="line">                <span class="keyword">if</span>(temp==<span class="string">""</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 判断searchWord是不是单词的前缀</span></span><br><span class="line">                <span class="keyword">if</span>(temp.substr(<span class="number">0</span>,searchWord.<span class="built_in">size</span>()) == searchWord)&#123;	</span><br><span class="line">                    <span class="keyword">return</span> idx;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = <span class="string">""</span>;</span><br><span class="line">                idx+=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp+=sentence[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="定长子串中元音的最大数目"><a href="#定长子串中元音的最大数目" class="headerlink" title="定长子串中元音的最大数目"></a><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/maximum-number-of-vowels-in-a-substring-of-given-length/" target="_blank" rel="noopener">定长子串中元音的最大数目</a></h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>给你字符串 <code>s</code> 和整数 <code>k</code> 。</p>
<p>请返回字符串 <code>s</code> 中长度为 <code>k</code> 的单个子字符串中可能包含的最大元音字母数。</p>
<p>英文中的 <strong>元音字母</strong> 为（<code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>）。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abciiidef&quot;, k &#x3D; 3</span><br><span class="line">输出：3</span><br><span class="line">解释：子字符串 &quot;iii&quot; 包含 3 个元音字母。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aeiou&quot;, k &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line">解释：任意长度为 2 的子字符串都包含 2 个元音字母。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;leetcode&quot;, k &#x3D; 3</span><br><span class="line">输出：2</span><br><span class="line">解释：&quot;lee&quot;、&quot;eet&quot; 和 &quot;ode&quot; 都包含 2 个元音字母。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;rhythms&quot;, k &#x3D; 4</span><br><span class="line">输出：0</span><br><span class="line">解释：字符串 s 中不含任何元音字母。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;tryhard&quot;, k &#x3D; 4</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; s.length &lt;&#x3D; 10^5</span><br><span class="line">s 由小写英文字母组成</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; s.length</span><br></pre></td></tr></table></figure>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><code>k</code>是窗口的大小，用滑动窗口来模拟即可。</p>
<h4 id="实现示例-1"><a href="#实现示例-1" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxVowels</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;	<span class="comment">// 保存窗口内中的元音字符个数</span></span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:<span class="string">"aeiou"</span>)&#123;</span><br><span class="line">            t.insert(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cnt+=t.count(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=k)&#123;	<span class="comment">// 弹出窗口的队尾</span></span><br><span class="line">                cnt-=t.count(s[i-k]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=(k<span class="number">-1</span>))&#123;	<span class="comment">// 更新res</span></span><br><span class="line">                res = <span class="built_in">max</span>(res,cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树中的伪回文路径"><a href="#二叉树中的伪回文路径" class="headerlink" title="二叉树中的伪回文路径"></a><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/pseudo-palindromic-paths-in-a-binary-tree/" target="_blank" rel="noopener">二叉树中的伪回文路径</a></h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「<strong>伪回文</strong>」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。</p>
<p>请你返回从根到叶子节点的所有路径中 <strong>伪回文</strong> 路径的数目。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p><img src="/2020/05/24/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B190/palindromic_paths_1.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,null,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span> </span><br><span class="line">解释：上图为给定的二叉树。总共有 <span class="number">3</span> 条从根到叶子的路径：红色路径 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>] ，绿色路径 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>] 和路径 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>] 。</span><br><span class="line">     在这些路径中，只有红色和绿色的路径是伪回文路径，因为红色路径 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>] 存在回文排列 [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>] ，绿色路径 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>] 存在回文排列 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 。</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/24/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B190/palindromic_paths_2.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [2,1,1,1,3,null,null,null,null,null,1]</span><br><span class="line">输出：1 </span><br><span class="line">解释：上图为给定二叉树。总共有 3 条从根到叶子的路径：绿色路径 [2,1,1] ，路径 [2,1,3,1] 和路径 [2,1] 。</span><br><span class="line">     这些路径中只有绿色路径是伪回文路径，因为 [2,1,1] 存在回文排列 [1,2,1] 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [9]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>由题意可得:</p>
<ol>
<li>只用判断叶子节点</li>
<li>要保存从根节点到叶子节点的所有值能否构成回文</li>
</ol>
<p>用<code>dfs</code>来遍历整棵树，同时采用前序遍历的方式，而且要保存从根到当前节点中包含的所有数字，当是叶子节点时，判断保存的所有数字能否构成回文字符串。</p>
<p>问:那么到底该怎么判断一个数字集合能否构成回文字符串呢?</p>
<blockquote>
<p>观察得到回文字符串左右两端对称，那么除中间元素以外的所有元素的次数必然是偶数。</p>
<p>因此，如果能构成回文串，那么每种元素的出现次数必然是偶数个或者仅有一种元素出现奇数次。只需求解出现次数为奇数的元素种类的个数。</p>
<p>例如:</p>
<p>1出现5 次，2 出现2次，3出现4次</p>
<p>那么可以构成回文串，因为出现奇数次的元素只有1，因此可以构成。</p>
<p>1出现5 次，2 出现2次，3出现3次</p>
<p>那么不能构成回文串，因为出现奇数次的元素有1，3，因此不能构成。</p>
</blockquote>
<p>问: 是否需要保存每个元素的具体出现次数呢？</p>
<blockquote>
<p>不需要，在上面的讨论中，我们只用到了每个元素出现次数的奇偶性，因此可以用一个二进制数表述。</p>
<p>比如说:</p>
<p>001001011表示</p>
<p>987654321中1，2，4，7出现了奇数，其他出现了偶数次</p>
</blockquote>
<h4 id="实现示例-2"><a href="#实现示例-2" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 求[1,9]中包含奇数个元素的种类数。</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> &amp;mask)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = mask;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            res+=n&amp;<span class="number">1</span>;</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res &lt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> &amp;mask,<span class="keyword">int</span> &amp;res,TreeNode *root)</span></span>&#123;</span><br><span class="line">        mask ^= (<span class="number">1</span>&lt;&lt;(root-&gt;val<span class="number">-1</span>)); <span class="comment">// 当前元素的出现次数+1(奇偶数改变)</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; check(mask))&#123;res+=<span class="number">1</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123; dfs(mask,res,root-&gt;left);&#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123; dfs(mask,res,root-&gt;right);&#125;</span><br><span class="line">        mask ^= (<span class="number">1</span>&lt;&lt;(root-&gt;val<span class="number">-1</span>));	<span class="comment">// 回溯</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pseudoPalindromicPaths</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">        dfs(mask,res,root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最初的写法是用一个数组保存每个元素的出现次数，处理方式基本是相同的，用<code>bitmask</code>应该更省内存，运行速度也更快一些。下面是直接用数组来保存每个元素的出现次数的代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:dp)&#123;</span><br><span class="line">            res += item%<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res&lt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;dp,<span class="keyword">int</span> &amp;res,TreeNode *root)</span></span>&#123;</span><br><span class="line">        dp[root-&gt;val]+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; check(dp))&#123;</span><br><span class="line">            res+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            dfs(dp,res,root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            dfs(dp,res,root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[root-&gt;val]-=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pseudoPalindromicPaths</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">10</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dfs(dp,res,root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="两个子序列的最大点积"><a href="#两个子序列的最大点积" class="headerlink" title="两个子序列的最大点积"></a><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/max-dot-product-of-two-subsequences/" target="_blank" rel="noopener">两个子序列的最大点积</a></h3><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>给你两个数组 <code>nums1</code> 和 <code>nums2</code> 。</p>
<p>请你返回 <code>nums1</code> 和 <code>nums2</code> 中两个长度相同的 <strong>非空</strong> 子序列的最大点积。</p>
<p>数组的非空子序列是通过删除原数组中某些元素（可能一个也不删除）后剩余数字组成的序列，但不能改变数字间相对顺序。比方说，<code>[2,3,5]</code> 是 <code>[1,2,3,4,5]</code> 的一个子序列而 <code>[1,5,3]</code> 不是。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums1 &#x3D; [2,1,-2,5], nums2 &#x3D; [3,0,-6]</span><br><span class="line">输出：18</span><br><span class="line">解释：从 nums1 中得到子序列 [2,-2] ，从 nums2 中得到子序列 [3,-6] 。</span><br><span class="line">它们的点积为 (2*3 + (-2)*(-6)) &#x3D; 18 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums1 &#x3D; [3,-2], nums2 &#x3D; [2,-6,7]</span><br><span class="line">输出：21</span><br><span class="line">解释：从 nums1 中得到子序列 [3] ，从 nums2 中得到子序列 [7] 。</span><br><span class="line">它们的点积为 (3*7) &#x3D; 21 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums1 &#x3D; [-1,-1], nums2 &#x3D; [1,1]</span><br><span class="line">输出：-1</span><br><span class="line">解释：从 nums1 中得到子序列 [-1] ，从 nums2 中得到子序列 [1] 。</span><br><span class="line">它们的点积为 -1 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; nums1.length, nums2.length &lt;&#x3D; 500</span><br><span class="line">-1000 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>动态规划思想，一旦发现题目中的操作有分步进行的，可以考虑<code>dp</code>。</p>
<p><code>dp</code>的状态如何定义呢?</p>
<blockquote>
<p>明显$dp[i][j]$表示前$i$个<code>nums1</code>元素与前$j$个nums2`元素的最大点积。</p>
</blockquote>
<p><code>dp</code>的状态如何转化呢?</p>
<blockquote>
<p> $dp[i][j] = min(dp[i-1][j-1]+nums1[i] * nums2[j],dp[i][j-1],dp[i-1][j])$</p>
</blockquote>
<p>初始状态如何呢?</p>
<blockquote>
<p>$dp[0][j]=0,dp[i][0]=0$</p>
</blockquote>
<p>明显题意中<code>nums1</code>与<code>nums2</code>中至少都要取一个元素，因此要考虑如果最后<code>dp</code>结果为0时的情形</p>
<h4 id="实现示例-3"><a href="#实现示例-3" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDotProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> NIL = -(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,NIL))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = NIL;</span><br><span class="line">        <span class="keyword">int</span> lm = NIL;</span><br><span class="line">        <span class="keyword">int</span> rmn = -NIL;</span><br><span class="line">        <span class="comment">// 在nums1中与nums2中各选取一个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">            dp[i+<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i]&lt;=<span class="number">0</span>) lm = <span class="built_in">max</span>(lm,nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums2[j]&gt;=<span class="number">0</span>) rmn = <span class="built_in">min</span>(rmn,nums2[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        res = lm*rmn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                dp[i][j] = nums1[i<span class="number">-1</span>] * nums2[j<span class="number">-1</span>]+dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="comment">// cout&lt;&lt;dp[i][j]&lt;&lt;endl;</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j<span class="number">-1</span>],dp[i][j]);</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j]);</span><br><span class="line">                <span class="comment">// cout&lt;&lt;dp[i][j]&lt;&lt;endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[m][n]) <span class="keyword">return</span> dp[m][n];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>题目难度小，属于手速场，好多高手很快AK了。自己在第三题的回溯上出了点bug，花了几分钟调试了一下。第四题难度不大，但是在处理初始条件上也花了时间来调试。总的来说，动态规划的题目思路找对后要仔细地揣摩初始条件以及边界条件。</p>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣周赛191</title>
    <url>/2020/05/31/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B191/</url>
    <content><![CDATA[<p>这篇文章主要记录一下第191场周赛的题目解答。以下是四个题目:</p>
<ol>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-191/problems/maximum-product-of-two-elements-in-an-array/" target="_blank" rel="noopener">数组中两元素的最大乘积</a></li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-191/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/" target="_blank" rel="noopener">切割后面积最大的蛋糕</a></li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-191/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/" target="_blank" rel="noopener">重新规划路线</a></li>
<li>待补(还不会啊，哈哈哈)</li>
</ol>
<a id="more"></a>
<h3 id="数组中两元素的最大乘积"><a href="#数组中两元素的最大乘积" class="headerlink" title="数组中两元素的最大乘积"></a><a href="https://leetcode-cn.com/contest/weekly-contest-191/problems/maximum-product-of-two-elements-in-an-array/" target="_blank" rel="noopener">数组中两元素的最大乘积</a></h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给你一个整数数组 <code>nums</code>，请你选择数组的两个不同下标 <code>i</code> 和 <code>j</code><em>，</em>使 <code>(nums[i]-1)*(nums[j]-1)</code> 取得最大值。</p>
<p>请你计算并返回该式的最大值。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,5,2]</span><br><span class="line">输出：12 </span><br><span class="line">解释：如果选择下标 i&#x3D;1 和 j&#x3D;2（下标从 0 开始），则可以获得最大值，(nums[1]-1)*(nums[2]-1) &#x3D; (4-1)*(5-1) &#x3D; 3*4 &#x3D; 12 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,5,4,5]</span><br><span class="line">输出：16</span><br><span class="line">解释：选择下标 i&#x3D;1 和 j&#x3D;3（下标从 0 开始），则可以获得最大值 (5-1)*(5-1) &#x3D; 16 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,7]</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">2 &lt;&#x3D; nums.length &lt;&#x3D; 500</span><br><span class="line">1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^3</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>题意是找两个数，使之“乘积“最大。可考虑贪心，选最大的两个，或者选取最小的两个(都是负数，这个题都是正数)。获取最值可以通过排序，也可以通过优先队列来找到。</p>
<h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> (nums[n<span class="number">-1</span>]<span class="number">-1</span>) * (nums[n<span class="number">-2</span>]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="切割后面积最大的蛋糕"><a href="#切割后面积最大的蛋糕" class="headerlink" title="切割后面积最大的蛋糕"></a><a href="https://leetcode-cn.com/contest/weekly-contest-191/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/" target="_blank" rel="noopener">切割后面积最大的蛋糕</a></h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>矩形蛋糕的高度为 <code>h</code> 且宽度为 <code>w</code>，给你两个整数数组 <code>horizontalCuts</code> 和 <code>verticalCuts</code>，其中 <code>horizontalCuts[i]</code> 是从矩形蛋糕顶部到第 <code>i</code> 个水平切口的距离，类似地， <code>verticalCuts[j]</code> 是从矩形蛋糕的左侧到第 <code>j</code> 个竖直切口的距离。</p>
<p>请你按数组 <code>horizontalCuts</code> 和 <code>verticalCuts</code> 中提供的水平和竖直位置切割后，请你找出 <strong>面积最大</strong> 的那份蛋糕，并返回其 <strong>面积</strong> 。由于答案可能是一个很大的数字，因此需要将结果对 <code>10^9 + 7</code> 取余后返回。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p><img src="/2020/05/31/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B191/leetcode_max_area_2.png" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：h &#x3D; 5, w &#x3D; 4, horizontalCuts &#x3D; [1,2,4], verticalCuts &#x3D; [1,3]</span><br><span class="line">输出：4 </span><br><span class="line">解释：上图所示的矩阵蛋糕中，红色线表示水平和竖直方向上的切口。切割蛋糕后，绿色的那份蛋糕面积最大。</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/31/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B191/leetcode_max_area_3.png" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：h &#x3D; 5, w &#x3D; 4, horizontalCuts &#x3D; [3,1], verticalCuts &#x3D; [1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上图所示的矩阵蛋糕中，红色线表示水平和竖直方向上的切口。切割蛋糕后，绿色和黄色的两份蛋糕面积最大。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：h &#x3D; 5, w &#x3D; 4, horizontalCuts &#x3D; [3], verticalCuts &#x3D; [3]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>贪心思想:选取最大<code>y</code>（横向最大长度）,最大<code>x</code>(纵向最大长度)。那么咋求这个最大长度呢。</p>
<p>以横向为例，我们可以看到纵向的相连的两刀的间距是一个可能的<code>x</code>,即两元素的差值。</p>
<p>问：如何处理左右边界上的<code>x</code>呢?</p>
<blockquote>
<p>明显：左侧边界为<code>verticalCuts[0]-0</code>,右侧为<code>n - verticalCuts[n-1]</code>。</p>
</blockquote>
<p>上面的边界可以单独处理，也可以将元素<code>0</code>与<code>n</code>作为一刀，插入<code>verticalCuts</code></p>
<h4 id="实现示例-1"><a href="#实现示例-1" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> w, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; hc, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vc)</span> </span>&#123;</span><br><span class="line">        hc.push_back(<span class="number">0</span>);</span><br><span class="line">        hc.push_back(h);</span><br><span class="line">        vc.push_back(<span class="number">0</span>);</span><br><span class="line">        vc.push_back(w);</span><br><span class="line">        sort(hc.<span class="built_in">begin</span>(),hc.<span class="built_in">end</span>());</span><br><span class="line">        sort(vc.<span class="built_in">begin</span>(),vc.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> n = hc.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            x = <span class="built_in">max</span>(x,hc[i]-hc[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        n = vc.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            y = <span class="built_in">max</span>(y,vc[i]-vc[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1l</span>l * x * y) %MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意题目中结果可能溢出，所以用<code>long long</code>，并取模。</p>
<h3 id="重新规划路线"><a href="#重新规划路线" class="headerlink" title="重新规划路线"></a><a href="https://leetcode-cn.com/contest/weekly-contest-191/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/" target="_blank" rel="noopener">重新规划路线</a></h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p><code>n</code> 座城市，从 <code>0</code> 到 <code>n-1</code> 编号，其间共有 <code>n-1</code> 条路线。因此，要想在两座不同城市之间旅行只有唯一一条路线可供选择（路线网形成一颗树）。去年，交通运输部决定重新规划路线，以改变交通拥堵的状况。</p>
<p>路线用 <code>connections</code> 表示，其中 <code>connections[i] = [a, b]</code> 表示从城市 <code>a</code> 到 <code>b</code> 的一条有向路线。</p>
<p>今年，城市 0 将会举办一场大型比赛，很多游客都想前往城市 0 。</p>
<p>请你帮助重新规划路线方向，使每个城市都可以访问城市 0 。返回需要变更方向的最小路线数。</p>
<p>题目数据 <strong>保证</strong> 每个城市在重新规划路线方向后都能到达城市 0 。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p><img src="/2020/05/31/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B191/sample_1_1819.png" alt="3-1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 6, connections &#x3D; [[0,1],[1,3],[2,3],[4,0],[4,5]]</span><br><span class="line">输出：3</span><br><span class="line">解释：更改以红色显示的路线的方向，使每个城市都可以到达城市 0 。</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/31/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B191/sample_2_1819.png" alt="3-1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 5, connections &#x3D; [[1,0],[1,2],[3,2],[3,4]]</span><br><span class="line">输出：2</span><br><span class="line">解释：更改以红色显示的路线的方向，使每个城市都可以到达城市 0 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3, connections &#x3D; [[1,0],[2,0]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示:</span><br><span class="line"></span><br><span class="line">2 &lt;&#x3D; n &lt;&#x3D; 5 * 10^4</span><br><span class="line">connections.length &#x3D;&#x3D; n-1</span><br><span class="line">connections[i].length &#x3D;&#x3D; 2</span><br><span class="line">0 &lt;&#x3D; connections[i][0], connections[i][1] &lt;&#x3D; n-1</span><br><span class="line">connections[i][0] !&#x3D; connections[i][1]</span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>宽度优先搜索，从<code>0</code>开始，遍历所有与当前节点相连的节点，无论是指向它的节点，还是它指向的节点，将它指向的节点”反转”(将边逆向)，指向它的节点继续，访问过程中设置<code>vis</code>防止重复遍历。</p>
<h4 id="实现示例-2"><a href="#实现示例-2" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minReorder</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; connections)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">g</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:connections)&#123;	<span class="comment">// 建图</span></span><br><span class="line">            g[item[<span class="number">1</span>]+<span class="number">1</span>].push_back(item[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">            g[item[<span class="number">0</span>]+<span class="number">1</span>].push_back(-(item[<span class="number">1</span>]+<span class="number">1</span>));	<span class="comment">// 这里用负数表示有它指向的点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">        que.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n+<span class="number">1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        vis[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> tm = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(tm--)&#123;</span><br><span class="line">                <span class="keyword">auto</span> p = que.front();</span><br><span class="line">                que.pop_front();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> item:g[p])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(vis[<span class="built_in">abs</span>(item)]) <span class="keyword">continue</span>;</span><br><span class="line">                    vis[<span class="built_in">abs</span>(item)] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(item&lt;<span class="number">0</span>) res++;	<span class="comment">// 反转边</span></span><br><span class="line">                    que.push_back(<span class="built_in">abs</span>(item));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="待补第4题"><a href="#待补第4题" class="headerlink" title="待补第4题"></a>待补第4题</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前三题都不难，其中第三题的<code>BFS</code>中标记逆向边用负数花了一点时间思考，第四题还不太会,有点菜。下次努力吧。</p>
<p>本周的双周赛自己参加了一场虚拟竞赛，题目难度不大，四题都AC了。有需要的可以邮件联系。</p>
<p>最后还是希望能坚持做一下比赛，可能用处不大，但是还是多写写吧，毕竟算法与数据结构是很重要的。同时呢，也希望能慢慢地进步，写出更健壮、简洁的代码。</p>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣周赛196</title>
    <url>/2020/07/05/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B196/</url>
    <content><![CDATA[<p>这篇文章主要记录一下第196场力扣周赛的题目解答。以下是四个题目:</p>
<ol>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-196/problems/can-make-arithmetic-progression-from-sequence/" target="_blank" rel="noopener">判断能否形成等差数列</a>：3分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-196/problems/last-moment-before-all-ants-fall-out-of-a-plank/" target="_blank" rel="noopener">所有蚂蚁掉下来前的最后一刻</a>: 4分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-196/problems/count-submatrices-with-all-ones/" target="_blank" rel="noopener">统计全 1 子矩形</a>: 5分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-196/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/" target="_blank" rel="noopener">最多 K 次交换相邻数位后得到的最小整数</a>：7分</li>
</ol>
<a id="more"></a>
<h3 id="判断能否形成等差数列"><a href="#判断能否形成等差数列" class="headerlink" title="判断能否形成等差数列"></a><a href="https://leetcode-cn.com/contest/weekly-contest-196/problems/can-make-arithmetic-progression-from-sequence/" target="_blank" rel="noopener">判断能否形成等差数列</a></h3><p>题目意思就是判断一个数组在随意排序后能否成为一个等差数组。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>先排序，在判断相连元素的差是否相同。</p>
<h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canMakeArithmeticProgression</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        sort(arr.begin(),arr.end());    <span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">int</span> acc = arr[<span class="number">1</span>]-arr[<span class="number">0</span>];    <span class="comment">// 等差数列的“差”</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((arr[i]-arr[i<span class="number">-1</span>]) != acc) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="所有蚂蚁掉下来前的最后一刻"><a href="#所有蚂蚁掉下来前的最后一刻" class="headerlink" title="所有蚂蚁掉下来前的最后一刻"></a><a href="https://leetcode-cn.com/contest/weekly-contest-196/problems/last-moment-before-all-ants-fall-out-of-a-plank/" target="_blank" rel="noopener">所有蚂蚁掉下来前的最后一刻</a></h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>第一眼看到题目可知如果按照题目模拟的话是很复杂的，那么我们看一下这个题目的特殊性，当两只蚂蚁相遇时，就会马上反向，实际上等同于两只蚂蚁的身份互换了，然后以原来的方向前进，那么也就是说一只蚂蚁可以看作是朝着一个方向前进，因此找到每只蚂蚁前进的最大距离即可。</p>
<h4 id="实现示例-1"><a href="#实现示例-1" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLastMoment</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; left, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:left)&#123;    <span class="comment">// 向左的最大值</span></span><br><span class="line">            res = max(res,item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:right)&#123;   <span class="comment">// 向右的最大值</span></span><br><span class="line">            res = max(res,n-item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个题目有点脑筋急转弯的意思，我比赛的时候不会这道题，比赛中这个题目WA了4次，最后百度一下，算是抄袭别人的，哈哈哈。</p>
<h3 id="统计全-1-子矩形"><a href="#统计全-1-子矩形" class="headerlink" title="统计全 1 子矩形"></a><a href="https://leetcode-cn.com/contest/weekly-contest-196/problems/count-submatrices-with-all-ones/" target="_blank" rel="noopener">统计全 1 子矩形</a></h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>逐个判断肯定会超时的。我们来简化一下。</p>
<p>一个矩形可以如何唯一标识？</p>
<blockquote>
<p>一个位置信息(内部的一个点)，一个长，一个宽。</p>
<p>这个位置信息当然选择容易取的点，比如四个顶点</p>
</blockquote>
<p>那么我们就可以这么考虑:</p>
<blockquote>
<p>对于每个点$(i,j)$,枚举它可能的长度与宽度，求取这个$(i,j)$位置下的子矩阵的个数，最后求取所有点的总和</p>
</blockquote>
<p>下图描述了每个位置向上连续1的个数(高度越高，个数越多)</p>
<p><img src="/2020/07/05/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B196/1.png" alt="image-20200705144015054"></p>
<p>我们从长为1向左侧扩展(长度增加)，扩展的过程中，在每个长度下，最大高度是每个柱形高度的最小值，当最小高度为0时，后面长度更大的矩形一定不存在，退出循环，求取下一个位置。</p>
<blockquote>
<ol>
<li>向左扩展，长度增加，每个长度下，有哪些可能的高度</li>
<li>可能高度肯定不超过矩形中柱形的最小高度，设为<code>mn</code>,那么这个长度情形下有<code>mn</code>中不同高度的矩形，其高度值为$[1…mn]$中的所有整数</li>
</ol>
</blockquote>
<h4 id="实现示例-2"><a href="#实现示例-2" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubmat</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = mat.size();</span><br><span class="line">        <span class="keyword">int</span> n = mat[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j]==<span class="number">0</span>) <span class="keyword">continue</span>;	<span class="comment">// 当前位置是0</span></span><br><span class="line">                <span class="keyword">if</span>(i) mat[i][j]+=mat[i<span class="number">-1</span>][j]; <span class="comment">// 当前位置的柱形的高度</span></span><br><span class="line">                <span class="keyword">int</span> mn = mat[i][j];		<span class="comment">// 保存过程中的最小高度</span></span><br><span class="line">                res+=mn;</span><br><span class="line">                <span class="keyword">int</span> k=j<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(k&gt;=<span class="number">0</span> &amp;&amp; mat[i][k])&#123;</span><br><span class="line">                    mn = min(mn,mat[i][k]);</span><br><span class="line">                    res+=mn;	<span class="comment">// 当前长度下有mn中不同高度的子矩形</span></span><br><span class="line">                    k--;	<span class="comment">// 长度增加</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码在每个元素上保存了向上的、连续的1的个数（即柱形的高度），然后不断增加长度的情形下，求取当前长度下的高度种类数。直到当前可能高度为0。实际上是应用了前缀和的思想。</p>
<h3 id="最多-K-次交换相邻数位后得到的最小整数"><a href="#最多-K-次交换相邻数位后得到的最小整数" class="headerlink" title="最多 K 次交换相邻数位后得到的最小整数"></a><a href="https://leetcode-cn.com/contest/weekly-contest-196/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/" target="_blank" rel="noopener">最多 K 次交换相邻数位后得到的最小整数</a></h3><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>贪心+树状数组。</p>
<p>每次我们肯定选取最小的元素放在最左端。当有多个位置为最小的元素时，我们肯定选取最左侧的元素并将其交换到最左端，因为这样消耗的交换次数最小。同时这个交换次数不能超过剩下的可交换次数。</p>
<p>那么将这个元素交换到最左端需要交换多少次呢？</p>
<blockquote>
<p>这个元素左侧元素的个数。</p>
</blockquote>
<p>那么左侧元素的个数咋求呢?</p>
<blockquote>
<p>用树状数组进行维护，树状数组多用来维护动态的前缀和，那么可以用1,0来标识一个位置的元素是否还存在，同时它的前缀和表示了保存自己在内的元素的个数，减去1，就是交换次数了，同时要更新这个树状数组。</p>
</blockquote>
<h4 id="实现示例-3"><a href="#实现示例-3" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span>&#123;</span>  <span class="comment">// 树状数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">    BIT(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        t = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            ans+=t[x];</span><br><span class="line">            x-=(x&amp;(-x));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = t.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">            t[x] += val;</span><br><span class="line">            x+=(x&amp;(-x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minInteger</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> n = num.size();</span><br><span class="line">        <span class="function">BIT <span class="title">tree</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=(n<span class="number">-1</span>);i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            dp[num[i]-<span class="string">'0'</span>].push_back(i);    <span class="comment">// 保存每个数的索引</span></span><br><span class="line">            tree.update(i+<span class="number">1</span>,<span class="number">1</span>); <span class="comment">// 建立树状数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> mn = n+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> idx = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123; <span class="comment">// 优先从较小的数开始选取</span></span><br><span class="line">                <span class="keyword">if</span>(dp[j].empty()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> item = dp[j].back();    <span class="comment">// 选取索引最小的元素(因为这样交换次数最小)</span></span><br><span class="line">                <span class="keyword">int</span> times = tree.query(item+<span class="number">1</span>)<span class="number">-1</span>;   <span class="comment">// 交换次数(在这之前的元素个数)</span></span><br><span class="line">                <span class="keyword">if</span>(times &lt; mn)&#123;     <span class="comment">// 这个条件是多余的</span></span><br><span class="line">                    mn = times;</span><br><span class="line">                    idx = j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(times &lt;=k)&#123;  <span class="comment">// 找到了这样的元素j,它的交换次数为times</span></span><br><span class="line">                    mn = times;</span><br><span class="line">                    idx = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res+=to_string(idx);</span><br><span class="line">            k-=mn;  <span class="comment">// 更新可交换次数k</span></span><br><span class="line">            <span class="comment">// cout&lt;&lt;k&lt;&lt;endl;</span></span><br><span class="line">            tree.update(dp[idx].back()+<span class="number">1</span>,<span class="number">-1</span>); <span class="comment">// 更新树状数组</span></span><br><span class="line">            dp[idx].pop_back(); <span class="comment">// 弹出选取的这个元素，防止相同位置的元素重复使用</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>对于树状数组，这里有参考资料:<ol>
<li><a href="https://oi-wiki.org/ds/fenwick/" target="_blank" rel="noopener">oi-wiki</a></li>
<li><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/" target="_blank" rel="noopener">力扣题目：307. 区域和检索 - 数组可修改</a></li>
</ol>
</li>
<li>当然，用线段树也可以维护动态的区间和，有兴趣的可以写写试试，排名靠前的高手也有用线段树求解的，感兴趣的可以看看</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个题目的难度不算特别大，第二题是在比赛结束前10分钟以内提交的，还百度了类似题目，老实讲，这个题目不大会，解法的思想也很有意思，不大容易想到。对于其他题目呢，难度都不算太大。第四题难度不大，但是如果不知道树状数组、线段树这样的维护动态数组的前缀和的数据结构的话，估计不大容易想出比较好的解法，如果有读者有更好的解法，欢迎一起交流。</p>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣周赛193</title>
    <url>/2020/06/14/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B193/</url>
    <content><![CDATA[<p>这篇文章主要记录一下第193场力扣周赛的题目解答。以下是四个题目:</p>
<ol>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-193/problems/running-sum-of-1d-array/" target="_blank" rel="noopener">一维数组的动态和</a>: 3分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-193/problems/least-number-of-unique-integers-after-k-removals/" target="_blank" rel="noopener">不同整数的最少数目</a>: 4分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-193/problems/minimum-number-of-days-to-make-m-bouquets/" target="_blank" rel="noopener">制作 m 束花所需的最少天数</a>: 5分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-193/problems/kth-ancestor-of-a-tree-node/" target="_blank" rel="noopener">树节点的第 K 个祖先</a>: 6分</li>
</ol>
<a id="more"></a>
<h3 id="一维数组的动态和"><a href="#一维数组的动态和" class="headerlink" title="一维数组的动态和"></a><a href="https://leetcode-cn.com/contest/weekly-contest-193/problems/running-sum-of-1d-array/" target="_blank" rel="noopener">一维数组的动态和</a></h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给你一个数组 <code>nums</code> 。数组「动态和」的计算公式为：<code>runningSum[i] = sum(nums[0]…nums[i])</code> 。</p>
<p>请返回 <code>nums</code> 的动态和。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,6,10]</span><br><span class="line">解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,1,1,1]</span><br><span class="line">输出：[1,2,3,4,5]</span><br><span class="line">解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,1,1,1]</span><br><span class="line">输出：[1,2,3,4,5]</span><br><span class="line">解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,1,2,10,1]</span><br><span class="line">输出：[3,4,6,16,17]</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>前缀和直接保存就可以了。</p>
<h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">runningSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum+=nums[i];   <span class="comment">// 前缀和</span></span><br><span class="line">            res[i] = sum;   <span class="comment">// 保存至结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="不同整数的最少数目"><a href="#不同整数的最少数目" class="headerlink" title="不同整数的最少数目"></a><a href="https://leetcode-cn.com/contest/weekly-contest-193/problems/least-number-of-unique-integers-after-k-removals/" target="_blank" rel="noopener">不同整数的最少数目</a></h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>给你一个整数数组 <code>arr</code> 和一个整数 <code>k</code> 。现需要从数组中恰好移除 <code>k</code> 个元素，请找出移除后数组中不同整数的最少数目。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [5,5,4], k &#x3D; 1</span><br><span class="line">输出：1</span><br><span class="line">解释：移除 1 个 4 ，数组中只剩下 5 一种整数。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [4,3,1,1,3,3,2], k &#x3D; 3</span><br><span class="line">输出：2</span><br><span class="line">解释：先移除 4、2 ，然后再移除两个 1 中的任意 1 个或者三个 3 中的任意 1 个，最后剩下 1 和 3 两种整数。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; arr.length &lt;&#x3D; 10^5</span><br><span class="line">1 &lt;&#x3D; arr[i] &lt;&#x3D; 10^9</span><br><span class="line">0 &lt;&#x3D; k &lt;&#x3D; arr.length</span><br></pre></td></tr></table></figure>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>贪心思想，移除<code>k</code>个出现次数最少的元素，能让结果最大。</p>
<h4 id="实现示例-1"><a href="#实现示例-1" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLeastNumOfUniqueInts</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:arr)&#123; <span class="comment">// 缓存每个元素的出现次数</span></span><br><span class="line">            t[item]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:t)&#123;   <span class="comment">// 保存出现次数</span></span><br><span class="line">            res.push_back(item.second); </span><br><span class="line">        &#125;</span><br><span class="line">        sort(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());<span class="comment">// 排序出现次数</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = res.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;   <span class="comment">// 贪心地减去出现次数少地元素</span></span><br><span class="line">            <span class="keyword">if</span>(k&lt;res[i])&#123;</span><br><span class="line">                ans = n-i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k-=res[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="制作-m-束花所需的最少天数"><a href="#制作-m-束花所需的最少天数" class="headerlink" title="制作 m 束花所需的最少天数"></a><a href="https://leetcode-cn.com/contest/weekly-contest-193/problems/minimum-number-of-days-to-make-m-bouquets/" target="_blank" rel="noopener">制作 m 束花所需的最少天数</a></h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>给你一个整数数组 <code>bloomDay</code>，以及两个整数 <code>m</code> 和 <code>k</code> 。</p>
<p>现需要制作 <code>m</code> 束花。制作花束时，需要使用花园中 <strong>相邻的 <code>k</code> 朵花</strong> 。</p>
<p>花园中有 <code>n</code> 朵花，第 <code>i</code> 朵花会在 <code>bloomDay[i]</code> 时盛开，<strong>恰好</strong> 可以用于 <strong>一束</strong> 花中。</p>
<p>请你返回从花园中摘 <code>m</code> 束花需要等待的最少的天数。如果不能摘到 <code>m</code> 束花则返回 <strong>-1</strong> 。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：bloomDay &#x3D; [1,10,3,10,2], m &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br><span class="line">解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。</span><br><span class="line">现在需要制作 3 束花，每束只需要 1 朵。</span><br><span class="line">1 天后：[x, _, _, _, _]   &#x2F;&#x2F; 只能制作 1 束花</span><br><span class="line">2 天后：[x, _, _, _, x]   &#x2F;&#x2F; 只能制作 2 束花</span><br><span class="line">3 天后：[x, _, x, _, x]   &#x2F;&#x2F; 可以制作 3 束花，答案为 3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：bloomDay &#x3D; [1,10,3,10,2], m &#x3D; 3, k &#x3D; 2</span><br><span class="line">输出：-1</span><br><span class="line">解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：bloomDay &#x3D; [7,7,7,7,12,7,7], m &#x3D; 2, k &#x3D; 3</span><br><span class="line">输出：12</span><br><span class="line">解释：要制作 2 束花，每束需要 3 朵。</span><br><span class="line">花园在 7 天后和 12 天后的情况如下：</span><br><span class="line">7 天后：[x, x, x, x, _, x, x]</span><br><span class="line">可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。</span><br><span class="line">12 天后：[x, x, x, x, x, x, x]</span><br><span class="line">显然，我们可以用不同的方式制作两束花。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：bloomDay &#x3D; [1000000000,1000000000], m &#x3D; 1, k &#x3D; 1</span><br><span class="line">输出：1000000000</span><br><span class="line">解释：需要等 1000000000 天才能采到花来制作花束</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：bloomDay &#x3D; [1,10,2,9,3,8,4,7,5,6], m &#x3D; 4, k &#x3D; 2</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">bloomDay.length &#x3D;&#x3D; n</span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 10^5</span><br><span class="line">1 &lt;&#x3D; bloomDay[i] &lt;&#x3D; 10^9</span><br><span class="line">1 &lt;&#x3D; m &lt;&#x3D; 10^6</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; n</span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>二分加贪心。</p>
<h4 id="实现示例-2"><a href="#实现示例-2" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> mid,<span class="keyword">int</span> m,<span class="keyword">int</span> k)</span></span>&#123;   <span class="comment">// 判断mid天以后能制成多少束花</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;    <span class="comment">// 相连已开花元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;    <span class="comment">// 能制成的花的束数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;   <span class="comment">// 贪心地选取已开花相连元素</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=mid)&#123;</span><br><span class="line">                cnt+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cnt=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;=k)&#123;     <span class="comment">// 已开花相连元素地个数大于等于k，构成一束花</span></span><br><span class="line">                res++;</span><br><span class="line">                cnt = <span class="number">0</span>;    <span class="comment">// 将已开花相连元素地个数置为0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bd, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = bd.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>((m*k)&gt;n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1e9</span>+<span class="number">1</span>;  <span class="comment">// 右端点</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;  <span class="comment">// 左端点</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (r-l)/<span class="number">2</span>+l;</span><br><span class="line">            <span class="keyword">if</span>(check(bd,mid,m,k)&gt;=m)&#123;r = mid;&#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;l=mid+<span class="number">1</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>二分的题目还是很多的，也有很多变化，我这篇<a href="https://leetcode-cn.com/problems/find-positive-integer-solution-for-a-given-equation/solution/shuang-zhi-zhen-da-biao-fen-xi-by-xyqkoala/" target="_blank" rel="noopener">题解</a>中提到了二分的使用，有兴趣的可以去看一下。</p>
<p>对于这类<code>贪心+二分</code>的题目，这里做一个简单的列举：</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/" target="_blank" rel="noopener">在 D 天内送达包裹的能力</a></li>
<li><a href="https://leetcode-cn.com/problems/ugly-number-iii/" target="_blank" rel="noopener">丑数III</a></li>
<li><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">搜索插入位置</a>(二分基础题)</li>
</ol>
<p>对于<code>二分</code>算法来说，主要有三种区间分割形式：<code>[l,r]</code>以及<code>l</code>与<code>r</code>的中点<code>m</code>：</p>
<ol>
<li><code>[l,m-1]</code>,<code>[m,m]</code>,<code>[m+1,r]</code></li>
<li><code>[l,m-1]</code>以及<code>[m,r]</code></li>
<li><code>[l,m]</code>以及<code>[m,r]</code></li>
</ol>
<p>这个地方说的非常笼统，你可以从<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/" target="_blank" rel="noopener">这个题解</a>中找到思路以及相应的解释。那是<a href="https://leetcode-cn.com/u/labuladong/" target="_blank" rel="noopener">作者</a>的关于<code>二分查找</code>的总结。我觉得总结得挺好的，看懂后用上面的题目去练练手，可以巩固一下。我推荐第二种分割方式，上面的代码示例也是采用第二种区间分割方式，这样二分写起来更容易一点，不过这是我个人的感觉，你也可以按照你自己的理解来写二分。不过上面链接中关于<code>二分</code>思路的分析与梳理，是十分优秀的，值得一看。</p>
<h3 id="树节点的第-K-个祖先"><a href="#树节点的第-K-个祖先" class="headerlink" title="树节点的第 K 个祖先"></a><a href="https://leetcode-cn.com/contest/weekly-contest-193/problems/kth-ancestor-of-a-tree-node/" target="_blank" rel="noopener">树节点的第 K 个祖先</a></h3><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>给你一棵树，树上有 <code>n</code> 个节点，按从 <code>0</code> 到 <code>n-1</code> 编号。树以父节点数组的形式给出，其中 <code>parent[i]</code> 是节点 <code>i</code> 的父节点。树的根节点是编号为 <code>0</code> 的节点。</p>
<p>请你设计并实现 <code>getKthAncestor(int node, int k)</code> 函数，函数返回节点 <code>node</code> 的第 <code>k</code> 个祖先节点。如果不存在这样的祖先节点，返回 <code>-1</code> 。</p>
<p>树节点的第 <em><code>k</code></em> 个祖先节点是从该节点到根节点路径上的第 <code>k</code> 个节点。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p><img src="/2020/06/14/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B193/1528_ex1.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;TreeAncestor&quot;,&quot;getKthAncestor&quot;,&quot;getKthAncestor&quot;,&quot;getKthAncestor&quot;]</span><br><span class="line">[[7,[-1,0,0,1,1,2,2]],[3,1],[5,2],[6,3]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,1,0,-1]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">TreeAncestor treeAncestor &#x3D; new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);</span><br><span class="line"></span><br><span class="line">treeAncestor.getKthAncestor(3, 1);  &#x2F;&#x2F; 返回 1 ，它是 3 的父节点</span><br><span class="line">treeAncestor.getKthAncestor(5, 2);  &#x2F;&#x2F; 返回 0 ，它是 5 的祖父节点</span><br><span class="line">treeAncestor.getKthAncestor(6, 3);  &#x2F;&#x2F; 返回 -1 因为不存在满足要求的祖先节点</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; k &lt;&#x3D; n &lt;&#x3D; 5*10^4</span><br><span class="line">parent[0] &#x3D;&#x3D; -1 表示编号为 0 的节点是根节点。</span><br><span class="line">对于所有的 0 &lt; i &lt; n ，0 &lt;&#x3D; parent[i] &lt; n 总成立</span><br><span class="line">0 &lt;&#x3D; node &lt; n</span><br><span class="line">至多查询 5*10^4 次</span><br></pre></td></tr></table></figure>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>这个题目先动手写一下暴力<code>DFS</code>，可以看到会超时(我因此WA了一次)。</p>
<p>问一：为什么会超时?</p>
<blockquote>
<p>一般出现超时大部分情况是因为搜索了重复的空间，这里说一下<code>DP</code>，<code>DP</code>思想正是这么优化算法的。</p>
</blockquote>
<p>问二：哪个地方搜索了重复空间呢?</p>
<blockquote>
<p>比如有一条从叶子节点到根节点<code>0</code>的路径: 9 &gt; 8 &gt; 7 &gt; 6 &gt; 5 &gt; 4 &gt; 3 &gt; 2 &gt; 1 &gt; 0</p>
<p>现在要求解节点<code>9</code>的第<code>6</code>个父节点，明显是<code>3</code>,然后还要求解节点<code>5</code>的第<code>4</code>个父节点，明显是<code>5</code>,这里就有重复的搜索路径: 9 &gt; 8 &gt; 7 &gt; 6 &gt; 5</p>
</blockquote>
<p>问三：有啥解决方法呢？</p>
<blockquote>
<p>仍然求解：节点<code>9</code>的第<code>6</code>个父节点。</p>
<p>采用中间结果缓存。如果我们知道<code>9</code>的第<code>4</code>个父亲节点（<code>5</code>）,那么我们可以先一步跳转到节点<code>5</code>,然后再跳转<code>2</code>步就可以了，这样就不必重复走9 &gt;8 &gt; 7 &gt; 6 &gt; 5这条路径了。</p>
</blockquote>
<p>问四：咋实现呢？</p>
<blockquote>
<ol>
<li>我们有什么?</li>
</ol>
<p>每个节点跳转一步的父节点。</p>
<ol>
<li>如何缓存?</li>
</ol>
<p>1步的跳转位置我们知道，那么2步的跳转位置容易求得。(将一步的跳转进行两次)</p>
<p>2步的跳转位置我们知道，那么4步的跳转位置容易得到。(将两步的跳转进行两次）</p>
<p>同理容易得到4步，8步…的跳转位置</p>
</blockquote>
<h4 id="实现示例-3"><a href="#实现示例-3" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeAncestor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeAncestor(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; parent) &#123;</span><br><span class="line">        factor = <span class="number">12</span>;</span><br><span class="line">        <span class="comment">// t[0]保存跳转1次的父亲节点</span></span><br><span class="line">        <span class="comment">// t[1]保存跳转2次的父亲节点</span></span><br><span class="line">        <span class="comment">// t[2]保存跳转4次的父亲节点</span></span><br><span class="line">        <span class="comment">// 依次类推</span></span><br><span class="line">        t = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(factor,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">-1</span>));</span><br><span class="line">        t[<span class="number">0</span>] = parent;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;factor;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> node = j;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)&#123;</span><br><span class="line">                    node = t[i<span class="number">-1</span>][node];</span><br><span class="line">                    <span class="keyword">if</span>(node==<span class="number">-1</span>) <span class="keyword">break</span>;	<span class="comment">// 处理已经跳出根节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                t[i][j] = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = node;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=(factor<span class="number">-1</span>);i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> base = <span class="number">1</span>&lt;&lt;i;	<span class="comment">// 跳转base步的父亲节点</span></span><br><span class="line">            <span class="keyword">while</span>(k&gt;=base)&#123;	<span class="comment">// 跳转base步直到父亲节点为-1或者k为0</span></span><br><span class="line">                k-=base;</span><br><span class="line">                res = t[i][res];</span><br><span class="line">                <span class="keyword">if</span>(res==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;	</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKthAncestor</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(node,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; t;</span><br><span class="line">    <span class="keyword">int</span> factor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在比赛的过程当中采用过一些其他的方式缓存中间结果，但仍然超时，如果有其他的解法，非常希望您能够给我分享一下，一起交流一波。</p>
<p>这个题我感觉还是很好的题目，很有价值的题目。好多高手瞬间就<code>AK</code>了，真的强👍。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这周的题目难度还是可以的，还是熟悉的前三题很快结束，第四题需要调试一波。</p>
<p><code>二分+贪心</code>的题目还是很多的，也有不同等级难度的题目，多写写就熟悉了。</p>
<p><code>缓存</code>中间结果的思路在算法、软件工程以及其他领域都有非常广泛的应用，值得推敲。</p>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣周赛192</title>
    <url>/2020/06/07/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B192/</url>
    <content><![CDATA[<p>这篇文章主要记录一下第192场周赛的题目解答。以下是四个题目:</p>
<ol>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-192/problems/shuffle-the-array/" target="_blank" rel="noopener">重新排列数组</a>: 3分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-192/problems/the-k-strongest-values-in-an-array/" target="_blank" rel="noopener">数组中的 k 个最强值</a>: 4分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-192/problems/design-browser-history/" target="_blank" rel="noopener">设计浏览器历史记录</a>: 5分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-192/problems/paint-house-iii/" target="_blank" rel="noopener">给房子涂色 III</a>: 6分</li>
</ol>
<a id="more"></a>
<h3 id="重新排列数组"><a href="#重新排列数组" class="headerlink" title="重新排列数组"></a><a href="https://leetcode-cn.com/contest/weekly-contest-192/problems/shuffle-the-array/" target="_blank" rel="noopener">重新排列数组</a></h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给你一个数组 <code>nums</code> ，数组中有 <code>2n</code> 个元素，按 <code>[x1,x2,...,xn,y1,y2,...,yn]</code> 的格式排列。</p>
<p>请你将数组按 <code>[x1,y1,x2,y2,...,xn,yn]</code> 格式重新排列，返回重排后的数组。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>], n = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>] </span><br><span class="line">解释：由于 x1=<span class="number">2</span>, x2=<span class="number">5</span>, x3=<span class="number">1</span>, y1=<span class="number">3</span>, y2=<span class="number">4</span>, y3=<span class="number">7</span> ，所以答案为 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], n = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>], n = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= n &lt;= <span class="number">500</span></span><br><span class="line">nums.length == <span class="number">2</span>n</span><br><span class="line"><span class="number">1</span> &lt;= nums[i] &lt;= <span class="number">10</span>^<span class="number">3</span></span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>按照题意相继向结果数组中添加元素即可。</p>
<h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">shuffle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            res.push_back(nums[i]);	<span class="comment">// 加入xi</span></span><br><span class="line">            res.push_back(nums[i+n]);<span class="comment">// 加入yi</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>题目不难，<code>res</code>可以提前分配空间，上面代码中持续使用<code>push_back</code>函数会频繁的重新分配内存，效率变低。提前分配足够的空间则只需一次内存分配。这个不细说了，是<code>vector</code>的使用细节问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">shuffle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>*n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            res[<span class="number">2</span>*i] = nums[i];</span><br><span class="line">            res[<span class="number">2</span>*i+<span class="number">1</span>]=nums[i+n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="数组中的-k-个最强值"><a href="#数组中的-k-个最强值" class="headerlink" title="数组中的 k 个最强值"></a><a href="https://leetcode-cn.com/contest/weekly-contest-192/problems/the-k-strongest-values-in-an-array/" target="_blank" rel="noopener">数组中的 k 个最强值</a></h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>给你一个整数数组 <code>arr</code> 和一个整数 <code>k</code> 。</p>
<p>设 <code>m</code> 为数组的中位数，只要满足下述两个前提之一，就可以判定 <code>arr[i]</code> 的值比 <code>arr[j]</code> 的值更强：</p>
<ul>
<li><code>|arr[i] - m| &gt; |arr[j] - m|</code></li>
<li><code>|arr[i] - m| == |arr[j] - m|</code>，且 <code>arr[i] &gt; arr[j]</code></li>
</ul>
<p>请返回由数组中最强的 <code>k</code> 个值组成的列表。答案可以以 <strong>任意顺序</strong> 返回。</p>
<p><strong>中位数</strong> 是一个有序整数列表中处于中间位置的值。形式上，如果列表的长度为 <code>n</code> ，那么中位数就是该有序列表（下标从 0 开始）中位于 <code>((n - 1) / 2)</code> 的元素。</p>
<ul>
<li>例如 <code>arr = [6, -3, 7, 2, 11]</code>，<code>n = 5</code>：数组排序后得到 <code>arr = [-3, 2, 6, 7, 11]</code> ，数组的中间位置为 <code>m = ((5 - 1) / 2) = 2</code> ，中位数 <code>arr[m]</code> 的值为 <code>6</code> 。</li>
<li>例如 <code>arr = [-7, 22, 17, 3]</code>，<code>n = 4</code>：数组排序后得到 <code>arr = [-7, 3, 17, 22]</code> ，数组的中间位置为 <code>m = ((4 - 1) / 2) = 1</code> ，中位数 <code>arr[m]</code> 的值为 <code>3</code> 。</li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2,3,4,5], k &#x3D; 2</span><br><span class="line">输出：[5,1]</span><br><span class="line">解释：中位数为 3，按从强到弱顺序排序后，数组变为 [5,1,4,2,3]。最强的两个元素是 [5, 1]。[1, 5] 也是正确答案。</span><br><span class="line">注意，尽管 |5 - 3| &#x3D;&#x3D; |1 - 3| ，但是 5 比 1 更强，因为 5 &gt; 1 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,1,3,5,5], k &#x3D; 2</span><br><span class="line">输出：[5,5]</span><br><span class="line">解释：中位数为 3, 按从强到弱顺序排序后，数组变为 [5,5,1,1,3]。最强的两个元素是 [5, 5]。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [6,7,11,7,6,8], k &#x3D; 5</span><br><span class="line">输出：[11,8,6,6,7]</span><br><span class="line">解释：中位数为 7, 按从强到弱顺序排序后，数组变为 [11,8,6,6,7,7]。</span><br><span class="line">[11,8,6,6,7] 的任何排列都是正确答案。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [6,-3,7,2,11], k &#x3D; 3</span><br><span class="line">输出：[-3,11,2]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [-7,22,17,3], k &#x3D; 2</span><br><span class="line">输出：[22,17]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; arr.length &lt;&#x3D; 10^5</span><br><span class="line">-10^5 &lt;&#x3D; arr[i] &lt;&#x3D; 10^5</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; arr.length</span><br></pre></td></tr></table></figure>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>先找到中位数<code>m</code>(通过排序)，然后找满足条件的前<code>k</code>个元素。</p>
<p>首先寻找”满足条件的前k个元素”可以通过贪心的思想，一旦想使用贪心思想，必然可能使用到排序或者优先队列，因为这两种方式都可以选取局部最值（当前最大或最小，或者满足某种条件的最大、最小）。</p>
<p>题目的条件告诉我们一个元素离中位数<code>m</code>越远值越”强”，那么可以明显的看到最末端的两个元素肯定是最“强”的两个，同理可以贪心地从两端取元素，判断谁是当前的最强值。</p>
<h4 id="实现示例-1"><a href="#实现示例-1" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getStrongest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        sort(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());	<span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = arr[(n<span class="number">-1</span>)/<span class="number">2</span>];   <span class="comment">// 获取中位数</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;     <span class="comment">// 指向两端的指针进行比较并获得较“强”的值</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(arr[l]-m) &gt; <span class="built_in">abs</span>(arr[r]-m))&#123;</span><br><span class="line">                res.push_back(arr[l++]);    <span class="comment">// l端更“强”</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.push_back(arr[r--]);    <span class="comment">// r端更“强”</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="设计浏览器历史记录"><a href="#设计浏览器历史记录" class="headerlink" title="设计浏览器历史记录"></a><a href="https://leetcode-cn.com/contest/weekly-contest-192/problems/design-browser-history/" target="_blank" rel="noopener">设计浏览器历史记录</a></h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>你有一个只支持单个标签页的 <strong>浏览器</strong> ，最开始你浏览的网页是 <code>homepage</code> ，你可以访问其他的网站 <code>url</code> ，也可以在浏览历史中后退 <code>steps</code> 步或前进 <code>steps</code> 步。</p>
<p>请你实现 <code>BrowserHistory</code> 类：</p>
<ul>
<li><code>BrowserHistory(string homepage)</code> ，用 <code>homepage</code> 初始化浏览器类。</li>
<li><code>void visit(string url)</code> 从当前页跳转访问 <code>url</code> 对应的页面 。执行此操作会把浏览历史前进的记录全部删除。</li>
<li><code>string back(int steps)</code> 在浏览历史中后退 <code>steps</code> 步。如果你只能在浏览历史中后退至多 <code>x</code> 步且 <code>steps &gt; x</code> ，那么你只后退 <code>x</code> 步。请返回后退 <strong>至多</strong> <code>steps</code> 步以后的 <code>url</code> 。</li>
<li><code>string forward(int steps)</code> 在浏览历史中前进 <code>steps</code> 步。如果你只能在浏览历史中前进至多 <code>x</code> 步且 <code>steps &gt; x</code> ，那么你只前进 <code>x</code> 步。请返回前进 <strong>至多</strong> <code>steps</code>步以后的 <code>url</code> 。</li>
</ul>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;BrowserHistory&quot;,&quot;visit&quot;,&quot;visit&quot;,&quot;visit&quot;,&quot;back&quot;,&quot;back&quot;,&quot;forward&quot;,&quot;visit&quot;,&quot;forward&quot;,&quot;back&quot;,&quot;back&quot;]</span><br><span class="line">[[&quot;leetcode.com&quot;],[&quot;google.com&quot;],[&quot;facebook.com&quot;],[&quot;youtube.com&quot;],[1],[1],[1],[&quot;linkedin.com&quot;],[2],[2],[7]]</span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,&quot;facebook.com&quot;,&quot;google.com&quot;,&quot;facebook.com&quot;,null,&quot;linkedin.com&quot;,&quot;google.com&quot;,&quot;leetcode.com&quot;]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">BrowserHistory browserHistory &#x3D; new BrowserHistory(&quot;leetcode.com&quot;);</span><br><span class="line">browserHistory.visit(&quot;google.com&quot;);       &#x2F;&#x2F; 你原本在浏览 &quot;leetcode.com&quot; 。访问 &quot;google.com&quot;</span><br><span class="line">browserHistory.visit(&quot;facebook.com&quot;);     &#x2F;&#x2F; 你原本在浏览 &quot;google.com&quot; 。访问 &quot;facebook.com&quot;</span><br><span class="line">browserHistory.visit(&quot;youtube.com&quot;);      &#x2F;&#x2F; 你原本在浏览 &quot;facebook.com&quot; 。访问 &quot;youtube.com&quot;</span><br><span class="line">browserHistory.back(1);                   &#x2F;&#x2F; 你原本在浏览 &quot;youtube.com&quot; ，后退到 &quot;facebook.com&quot; 并返回 &quot;facebook.com&quot;</span><br><span class="line">browserHistory.back(1);                   &#x2F;&#x2F; 你原本在浏览 &quot;facebook.com&quot; ，后退到 &quot;google.com&quot; 并返回 &quot;google.com&quot;</span><br><span class="line">browserHistory.forward(1);                &#x2F;&#x2F; 你原本在浏览 &quot;google.com&quot; ，前进到 &quot;facebook.com&quot; 并返回 &quot;facebook.com&quot;</span><br><span class="line">browserHistory.visit(&quot;linkedin.com&quot;);     &#x2F;&#x2F; 你原本在浏览 &quot;facebook.com&quot; 。 访问 &quot;linkedin.com&quot;</span><br><span class="line">browserHistory.forward(2);                &#x2F;&#x2F; 你原本在浏览 &quot;linkedin.com&quot; ，你无法前进任何步数。</span><br><span class="line">browserHistory.back(2);                   &#x2F;&#x2F; 你原本在浏览 &quot;linkedin.com&quot; ，后退两步依次先到 &quot;facebook.com&quot; ，然后到 &quot;google.com&quot; ，并返回 &quot;google.com&quot;</span><br><span class="line">browserHistory.back(7);                   &#x2F;&#x2F; 你原本在浏览 &quot;google.com&quot;， 你只能后退一步到 &quot;leetcode.com&quot; ，并返回 &quot;leetcode.com&quot;</span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>题目的意思不容易理解清楚，慢慢读。关键是判断要使用什么数据结构。</p>
<p>有一个前进以及后退的操作，可考虑双向链表。</p>
<p>注意<code>visit</code>接口的意思，一旦<code>visit</code>了这个<code>url</code>，那么这个<code>url</code>后面的网页全部丢失。</p>
<p>那么丢失在代码上的实现是什么呢？删除操作。</p>
<p>删除元素是一件费时的操作，可以用”有效”来表示，删除后面的元素，表示后面的元素无效。可以通过一个位置指针来指定最远的有效位置</p>
<h4 id="实现示例-2"><a href="#实现示例-2" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrowserHistory</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; t;   <span class="comment">// 保存记录</span></span><br><span class="line">    <span class="keyword">int</span> cur;    <span class="comment">// 当前访问位置</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span>;    <span class="comment">// 向后的界限，最远的有效位置</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BrowserHistory(<span class="built_in">string</span> homepage) &#123;</span><br><span class="line">        t.push_back(homepage);</span><br><span class="line">        cur = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="built_in">string</span> url)</span> </span>&#123;    <span class="comment">// 一旦visit那么向后记录消失，即界限为当前位置</span></span><br><span class="line">        <span class="keyword">if</span>(t.<span class="built_in">size</span>() == (cur+<span class="number">1</span>))&#123;    <span class="comment">// 容量不够</span></span><br><span class="line">            t.push_back(url);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            t[cur+<span class="number">1</span>] = url;</span><br><span class="line">        &#125;</span><br><span class="line">        cur++;</span><br><span class="line">        <span class="built_in">end</span> = cur;    <span class="comment">// 界限为idx，idx后的元素失效</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">back</span><span class="params">(<span class="keyword">int</span> steps)</span> </span>&#123;    <span class="comment">// 当前位置后退</span></span><br><span class="line">        cur = <span class="built_in">max</span>(cur-steps,<span class="number">0</span>);     <span class="comment">// 顶多退到首页</span></span><br><span class="line">        <span class="keyword">return</span> t[cur];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span> steps)</span> </span>&#123;     <span class="comment">// 当前位置后退</span></span><br><span class="line">        cur = <span class="built_in">min</span>(cur+steps,<span class="built_in">end</span>);   <span class="comment">// 顶多前进到界限处</span></span><br><span class="line">        <span class="keyword">return</span> t[cur];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个实现我是从<a href="https://blog.csdn.net/Solstice" target="_blank" rel="noopener">陈硕</a>写的开源网络库<a href="https://github.com/chenshuo/muduo" target="_blank" rel="noopener"><code>muduo</code></a>中的<code>buffer</code>的设计中获取到的灵感，有兴趣的可以去查看一下。这里就不展开来说了。</p>
<h3 id="给房子涂色-III"><a href="#给房子涂色-III" class="headerlink" title="给房子涂色 III"></a><a href="https://leetcode-cn.com/contest/weekly-contest-192/problems/paint-house-iii/" target="_blank" rel="noopener">给房子涂色 III</a></h3><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>在一个小城市里，有 <code>m</code> 个房子排成一排，你需要给每个房子涂上 <code>n</code> 种颜色之一（颜色编号为 <code>1</code> 到 <code>n</code> ）。有的房子去年夏天已经涂过颜色了，所以这些房子不需要被重新涂色。</p>
<p>我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 <code>houses = [1,2,2,3,3,2,1,1]</code> ，它包含 5 个街区 <code>[{1}, {2,2}, {3,3}, {2}, {1,1}]</code> 。）</p>
<p>给你一个数组 <code>houses</code> ，一个 <code>m * n</code> 的矩阵 <code>cost</code> 和一个整数 <code>target</code> ，其中：</p>
<ul>
<li><code>houses[i]</code>：是第 <code>i</code> 个房子的颜色，<strong>0</strong> 表示这个房子还没有被涂色。</li>
<li><code>cost[i][j]</code>：是将第 <code>i</code> 个房子涂成颜色 <code>j+1</code> 的花费。</li>
</ul>
<p>请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成 <code>target</code> 个街区。如果没有可用的涂色方案，请返回 <strong>-1</strong> 。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：houses &#x3D; [0,0,0,0,0], cost &#x3D; [[1,10],[10,1],[10,1],[1,10],[5,1]], m &#x3D; 5, n &#x3D; 2, target &#x3D; 3</span><br><span class="line">输出：9</span><br><span class="line">解释：房子涂色方案为 [1,2,2,1,1]</span><br><span class="line">此方案包含 target &#x3D; 3 个街区，分别是 [&#123;1&#125;, &#123;2,2&#125;, &#123;1,1&#125;]。</span><br><span class="line">涂色的总花费为 (1 + 1 + 1 + 1 + 5) &#x3D; 9。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：houses &#x3D; [0,2,1,2,0], cost &#x3D; [[1,10],[10,1],[10,1],[1,10],[5,1]], m &#x3D; 5, n &#x3D; 2, target &#x3D; 3</span><br><span class="line">输出：11</span><br><span class="line">解释：有的房子已经被涂色了，在此基础上涂色方案为 [2,2,1,2,2]</span><br><span class="line">此方案包含 target &#x3D; 3 个街区，分别是 [&#123;2,2&#125;, &#123;1&#125;, &#123;2,2&#125;]。</span><br><span class="line">给第一个和最后一个房子涂色的花费为 (10 + 1) &#x3D; 11。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：houses &#x3D; [0,0,0,0,0], cost &#x3D; [[1,10],[10,1],[1,10],[10,1],[1,10]], m &#x3D; 5, n &#x3D; 2, target &#x3D; 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：houses = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], cost = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]], m = <span class="number">4</span>, n = <span class="number">3</span>, target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：房子已经被涂色并组成了 <span class="number">4</span> 个街区，分别是 [&#123;<span class="number">3</span>&#125;,&#123;<span class="number">1</span>&#125;,&#123;<span class="number">2</span>&#125;,&#123;<span class="number">3</span>&#125;] ，无法形成 target = <span class="number">3</span> 个街区。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">m &#x3D;&#x3D; houses.length &#x3D;&#x3D; cost.length</span><br><span class="line">n &#x3D;&#x3D; cost[i].length</span><br><span class="line">1 &lt;&#x3D; m &lt;&#x3D; 100</span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 20</span><br><span class="line">1 &lt;&#x3D; target &lt;&#x3D; m</span><br><span class="line">0 &lt;&#x3D; houses[i] &lt;&#x3D; n</span><br><span class="line">1 &lt;&#x3D; cost[i][j] &lt;&#x3D; 10^4</span><br></pre></td></tr></table></figure>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p><code>DP</code>思想。</p>
<p>为什么会想到用<code>dp</code>呢?</p>
<blockquote>
<p>可以看到房子染色是一个接一个，有一个逐步染色的过程，一旦发现一个复杂的操作可以逐步进行，那么可以考虑<code>DP</code>。即<code>dp[第i步] = 某些运算(取最大或者最小等等操作){dp[第i-1步]...+当前操作对结果的影响}</code></p>
</blockquote>
<p><code>DP</code>的状态如何描述呢?</p>
<blockquote>
<p>选取染色的颜色以及有几个街区两个状态</p>
<p><code>dp[i][j]</code>表示当前选取颜色<code>i</code>并且有<code>j</code>个街区</p>
</blockquote>
<p>加上上面<code>步数</code>这个状态变量,<code>dp</code>完整的描述是<code>dp[k][i][j]</code>（第<code>k</code>步，选取颜色<code>i</code>，有<code>j</code>个街区）</p>
<p><code>DP</code>的状态如何转换呢?</p>
<blockquote>
<p>在找<code>DP</code>的状态转移方程时，可以想想当前的状态与之前的哪些状态相关</p>
<p>这里<code>dp[k][i][j]</code>与<code>dp[k-1][...][...]</code>的状态有关</p>
</blockquote>
<p>对状态进行分类，每一类状态的状态转移方程是相同的。比如:</p>
<blockquote>
<p>要求解<code>dp[k][i][j]</code> 那么<code>dp[k-1][i][...]</code>的转移方式是一种</p>
<p><code>dp[k][i][j]</code>与<code>dp[k-1][...][j-1]</code>的转移方式是另一种</p>
</blockquote>
<p>通过对<code>DP</code>的分析后，合理地设置初始条件就可以解出题目了（设置初始条件也有很多学问）。</p>
<h4 id="实现示例-3"><a href="#实现示例-3" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; houses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; cost, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> NIL = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(target+<span class="number">1</span>,NIL))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w=<span class="number">1</span>;w&lt;=m;w++)&#123;	<span class="comment">// 第w步</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; tdp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; (n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(target+<span class="number">1</span>,NIL));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;	<span class="comment">// 选取第i中颜色</span></span><br><span class="line">                <span class="keyword">int</span> tcnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(houses[w<span class="number">-1</span>] &amp;&amp; i!= houses[w<span class="number">-1</span>]) <span class="keyword">continue</span>;	<span class="comment">// 已经染过色了，只能选取本身地颜色</span></span><br><span class="line">                <span class="keyword">if</span>(houses[w<span class="number">-1</span>])&#123;</span><br><span class="line">                    tcnt = <span class="number">0</span>;	<span class="comment">// 已经染过色了,而且选取本身的颜色，当前cost为0</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tcnt = cost[w<span class="number">-1</span>][i<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;	<span class="comment">// 前一个房子的颜色</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=target;k++)&#123;	<span class="comment">// 有k个街区</span></span><br><span class="line">                        <span class="keyword">if</span>(i==j)&#123;	<span class="comment">// 当前选取地原色与前一个元素相同(街区数目不变)</span></span><br><span class="line">                            tdp[i][k] = <span class="built_in">min</span>(tdp[i][k],dp[j][k]+tcnt);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;	<span class="comment">// 当前选取地原色与前一个元素不同(街区数目加1)</span></span><br><span class="line">                            <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                            tdp[i][k] = <span class="built_in">min</span>(tdp[i][k],dp[j][k<span class="number">-1</span>]+tcnt);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = tdp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = NIL;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            res = <span class="built_in">min</span>(res,dp[i][target]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res==NIL) <span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">// 无法找到满足条件地染色方案</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，我的实现代码中采用了滚动数组进行优化，所以状态表示看上去好像是二维的，其实是因为采用滚动数组的原因，本质来说还是三维的状态。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>难度不大，第四题的在设置<code>tcnt</code>（当前选取的元素造成的<code>cost</code>）出现的一点点问题，花了一点时间调试，初始条件的设置也花了一点时间思考，其他地方按照<code>DP</code>思路写就行。</p>
<p>第三题我觉得这个题目描述不是很好，好在题目不难。而且前面我也提到过这个是从<a href="https://blog.csdn.net/Solstice" target="_blank" rel="noopener">陈硕</a>写的开源网络库<a href="https://github.com/chenshuo/muduo" target="_blank" rel="noopener"><code>muduo</code></a>中的<code>buffer</code>的设计中获取到的灵感,这个也算是一点点的学以致用吧，哈哈。</p>
<p>最后咧，还是那句话，刷题本身用处不大（面试时可能有点用），但是起码让你保持对你熟悉地编程语言地熟悉度，也许能从题目中获取一些解决类似的生活中、学习中、工作中的问题也说不定咧。</p>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣周赛202</title>
    <url>/2020/08/16/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B202/</url>
    <content><![CDATA[<p>这篇文章主要记录一下第202场力扣周赛的题目解答。以下是四个题目:</p>
<ol>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-202/problems/three-consecutive-odds/" target="_blank" rel="noopener">存在连续三个奇数的数组</a>：3分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-202/problems/minimum-operations-to-make-array-equal/" target="_blank" rel="noopener">使数组中所有元素相等的最小操作数</a>：4分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-202/problems/magnetic-force-between-two-balls/" target="_blank" rel="noopener">两球之间的磁力</a>：5分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-202/problems/minimum-number-of-days-to-eat-n-oranges/" target="_blank" rel="noopener">吃掉 N 个橘子的最少天数</a>：6分</li>
</ol>
<a id="more"></a>
<h3 id="存在连续三个奇数的数组"><a href="#存在连续三个奇数的数组" class="headerlink" title="存在连续三个奇数的数组"></a><a href="https://leetcode-cn.com/contest/weekly-contest-202/problems/three-consecutive-odds/" target="_blank" rel="noopener">存在连续三个奇数的数组</a></h3><p>题目意思是，如果有三个相连元素都为奇数，返回true，否则返回false。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>暴力枚举。</p>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">threeConsecutiveOdds</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;(i+<span class="number">3</span>)&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]%<span class="number">2</span> &amp;&amp; arr[i+<span class="number">1</span>]%<span class="number">2</span> &amp;&amp; arr[i+<span class="number">2</span>]%<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="使数组中所有元素相等的最小操作数"><a href="#使数组中所有元素相等的最小操作数" class="headerlink" title="使数组中所有元素相等的最小操作数"></a><a href="https://leetcode-cn.com/contest/weekly-contest-202/problems/minimum-operations-to-make-array-equal/" target="_blank" rel="noopener">使数组中所有元素相等的最小操作数</a></h3><p>题目意思是，给定的数列中，让所有数都变得相同，而且一次操作会改变两个数。</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>最后变成的数肯定都是<code>n</code>.那么每个数变成<code>n</code>需要操作多少次咧?每次操作可以让两个数更靠近<code>n</code>.因此，可以求每个数到<code>n</code>的距离之和(设为<code>s</code>),每次操作可以减少2，那么结果是<code>s/2</code>.</p>
<h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            res += <span class="built_in">abs</span>(<span class="number">2</span>*i+<span class="number">1</span>-n);</span><br><span class="line">        &#125;</span><br><span class="line">        res/=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>仔细分析一下，可以得出一个表达式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tn = n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> tn*(n-tn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个题目还是挺容易的。仔细分析一下也可以很容易地得到上述表达式。</p>
<h3 id="两球之间的磁力"><a href="#两球之间的磁力" class="headerlink" title="两球之间的磁力"></a><a href="https://leetcode-cn.com/contest/weekly-contest-202/problems/magnetic-force-between-two-balls/" target="_blank" rel="noopener">两球之间的磁力</a></h3><p>题意就是: 给定一些位置，给定一些磁石，在位置上放置磁石，让任意磁石之间的最短距离最大。</p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>二分+贪心。</p>
<p>这个题目在之前的周赛中也出现过类似，基本题意是让“最小距离最大”，”让最大距离最小”类似的问题。都是通过二分来求解的。这种题目还是挺常见的。</p>
<h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dis=nums[i]-pre;</span><br><span class="line">            <span class="keyword">if</span>(dis&gt;=m)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                pre = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pos, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        sort(pos.<span class="built_in">begin</span>(),pos.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = pos.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> r = pos[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;	<span class="comment">// 二分</span></span><br><span class="line">            <span class="keyword">int</span> mid = (r-l)/<span class="number">2</span>+l;</span><br><span class="line">            <span class="keyword">if</span>(check(pos,mid)&lt;m) r = mid;	<span class="comment">// 二分条件</span></span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于这类题目，我贴两个链接:</p>
<ol>
<li><p><a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">410分割数组的最大值</a></p>
</li>
<li><p><a href="https://xyqkoala.github.io/2020/06/14/力扣周赛193/" target="_blank" rel="noopener">力扣周赛193题解</a></p>
</li>
</ol>
<p>第2个链接中有关于二分的简要说明，也包含了如何正确地使用二分做了总结。二分还是非常重要的，之前面试的时候遇到的最多的就是二分的题目，希望能引起重视。</p>
<h3 id="吃掉-N-个橘子的最少天数"><a href="#吃掉-N-个橘子的最少天数" class="headerlink" title="吃掉 N 个橘子的最少天数"></a><a href="https://leetcode-cn.com/contest/weekly-contest-202/problems/minimum-number-of-days-to-eat-n-oranges/" target="_blank" rel="noopener">吃掉 N 个橘子的最少天数</a></h3><p>题意就是将N变为0的操作次数。</p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p><code>DFS</code>+记忆化递归。</p>
<p>总的来说，每次<code>n</code>有三种变化方式:</p>
<ol>
<li>$n-1$</li>
<li>$n/2$</li>
<li>$n/3$</li>
</ol>
<p>明显采用方式1，n的减少速度最慢。但是不能说，能够除3就除3，能够除2就除2，否则-1。这里当n为10时，就是一个反例。但是我们可以通过有限次数的操作先将n变成3或者2的倍数，再进行除法。这样就有了下面的记忆化递归。</p>
<h4 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n,<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp.<span class="built_in">find</span>(n) != dp.<span class="built_in">end</span>()) <span class="keyword">return</span> dp[n];</span><br><span class="line">        dp[n] = n;</span><br><span class="line">        dp[n] = <span class="built_in">min</span>(dp[n],(n%<span class="number">2</span>)+<span class="number">1</span>+dfs((n-(n%<span class="number">2</span>))/<span class="number">2</span>,dp));	<span class="comment">// 先变为2的倍数，再除2</span></span><br><span class="line">        dp[n] = <span class="built_in">min</span>(dp[n],(n%<span class="number">3</span>)+<span class="number">1</span>+dfs((n-(n%<span class="number">3</span>))/<span class="number">3</span>,dp));	<span class="comment">// 先变为3的倍数，再除3</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; dp;	<span class="comment">// 记忆化</span></span><br><span class="line">        <span class="keyword">return</span> dfs(n,dp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里我把我TLE的代码也贴出来:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span> <span class="comment">// TLE的代码</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n,<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp.<span class="built_in">find</span>(n) != dp.<span class="built_in">end</span>()) <span class="keyword">return</span> dp[n];</span><br><span class="line">        dp[n] = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>) dp[n] = <span class="built_in">min</span>(dp[n],<span class="number">1</span>+dfs(n/<span class="number">2</span>,dp));</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">3</span>==<span class="number">0</span>) dp[n] = <span class="built_in">min</span>(dp[n],<span class="number">1</span>+dfs(n/<span class="number">3</span>,dp));</span><br><span class="line">        dp[n] = <span class="built_in">min</span>(dp[n],<span class="number">1</span>+dfs(n<span class="number">-1</span>,dp));	<span class="comment">// 这里使得复杂度为O(n)</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; dp;</span><br><span class="line">        <span class="keyword">return</span> dfs(n,dp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面TLE的代码是完全按照题意写的。仔细分析一下就可以将<code>-1</code>这种操作方式给省略掉。比如</p>
<blockquote>
<p>dp[n] = n</p>
</blockquote>
<p>第一种操作的实现隐藏在下面代码中(以除以2为例):</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[n] = <span class="built_in">min</span>(dp[n],(n%<span class="number">2</span>)+<span class="number">1</span>+dfs((n-(n%<span class="number">2</span>))/<span class="number">2</span>,dp));	<span class="comment">// 先变为2的倍数，再除2</span></span><br></pre></td></tr></table></figure>
<p>这里用先减去<code>n%2</code>变成2的倍数，再执行除2.把除2放在一边，减去<code>n%2</code>操作就包含了方式一的减1操作了，因此这样的代码是正确的、同时又避免了每次减1的O(n)复杂度的代码了。</p>
<p>这样优化的代码我遇到地还比较少，TLE了一次。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>题目还是挺简单的，难度不大，好多高手在10分钟以内就搞定了，真的厉害👍。</p>
<ol>
<li>暴力枚举</li>
<li>数学</li>
<li>二分+贪心</li>
<li>记忆化递归</li>
</ol>
<p>第1、2题很容易，按照题意求解即可。第3题有好多类似的二分题目，见过的话也能很快搞定。第4题的记忆化递归要稍微的分析一下，代码难度小，边界条件也很容易，难度不大。第4题TLE了一次。</p>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>记忆化递归</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣周赛201</title>
    <url>/2020/08/10/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B201/</url>
    <content><![CDATA[<p>这篇文章主要记录一下第201场力扣周赛的题目解答。以下是四个题目:</p>
<ol>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-201/problems/make-the-string-great/" target="_blank" rel="noopener">整理字符串</a> : 3分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-201/problems/find-kth-bit-in-nth-binary-string/" target="_blank" rel="noopener">找出第 N 个二进制字符串中的第 K 位</a>: 4分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-201/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/" target="_blank" rel="noopener">和为目标值的最大数目不重叠非空子数组数目</a>：6分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-201/problems/minimum-cost-to-cut-a-stick/" target="_blank" rel="noopener">切棍子的最小成本</a>：7分</li>
</ol>
<a id="more"></a>
<h3 id="整理字符串"><a href="#整理字符串" class="headerlink" title="整理字符串"></a><a href="https://leetcode-cn.com/contest/weekly-contest-201/problems/make-the-string-great/" target="_blank" rel="noopener">整理字符串</a></h3><p>题目的意思是: 相连的两个字母如果分别是同一个字母的大小写形式，那么这两个字母要删除，而且要进行删除操作直到不能删除为止。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>栈。用栈保存状态。</p>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">makeGood</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// stack&lt;char&gt; stk;</span></span><br><span class="line">        <span class="keyword">auto</span> check=[](<span class="keyword">char</span> c)&#123;	<span class="comment">// 这个函数是判断字母是否为大写</span></span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; t;</span><br><span class="line">            <span class="keyword">if</span>(c&lt;=<span class="string">'Z'</span> &amp;&amp; c&gt;=<span class="string">'A'</span>) &#123;</span><br><span class="line">                t.first = <span class="number">-1</span>;</span><br><span class="line">                t.second = c-<span class="string">'A'</span>+<span class="string">'a'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                t.first = <span class="number">1</span>;</span><br><span class="line">                t.second = c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.empty())&#123;</span><br><span class="line">                res.push_back(item);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> lr = check(res.back());</span><br><span class="line">            <span class="keyword">auto</span> rr = check(item);</span><br><span class="line">            <span class="keyword">if</span>(lr.first!=rr.first &amp;&amp; lr.second == rr.second)&#123;	<span class="comment">// 两字母大小写形式不同 &amp;&amp; 是同一个字母 -&gt; 删除两个字母</span></span><br><span class="line">                res.pop_back();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.push_back(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个题目难度不大，在比赛的过程中我看掉了条件:要是相同字母的条件，一直WA。心态崩了。。。</p>
<h3 id="找出第-N-个二进制字符串中的第-K-位"><a href="#找出第-N-个二进制字符串中的第-K-位" class="headerlink" title="找出第 N 个二进制字符串中的第 K 位"></a><a href="https://leetcode-cn.com/contest/weekly-contest-201/problems/find-kth-bit-in-nth-binary-string/" target="_blank" rel="noopener">找出第 N 个二进制字符串中的第 K 位</a></h3><p>题目的意思已经描述地很清楚了。就是要求一个生成的字符串的第k位字符。</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><code>DFS</code>,我们可以从字符串的生成规则中看到:字符串具有“对称性”(左半部分与右半部分具有类似的结构)。因此，如果k位于左半部分中，那么问题的规模就减小了一半。如果在右半部分中，我们可以从左半部分的某个对应位置来简化问题规模。</p>
<h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">bool</span> f)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> f;	<span class="comment">// 递归基</span></span><br><span class="line">        <span class="keyword">int</span> cnt = (<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> tcnt = cnt/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=tcnt) <span class="keyword">return</span> dfs(n<span class="number">-1</span>,k,f);	<span class="comment">// 位于正中间</span></span><br><span class="line">        <span class="keyword">if</span>(k==(tcnt+<span class="number">1</span>)) <span class="keyword">return</span> !f;</span><br><span class="line">        k = <span class="number">2</span>*tcnt+<span class="number">2</span>-k;	<span class="comment">// 右侧k转化到左侧的对应位置</span></span><br><span class="line">        <span class="keyword">return</span> dfs(n<span class="number">-1</span>,k,!f);	<span class="comment">// 递归</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(n,k,f)+<span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="和为目标值的最大数目不重叠非空子数组数目"><a href="#和为目标值的最大数目不重叠非空子数组数目" class="headerlink" title="和为目标值的最大数目不重叠非空子数组数目"></a><a href="https://leetcode-cn.com/contest/weekly-contest-201/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/" target="_blank" rel="noopener">和为目标值的最大数目不重叠非空子数组数目</a></h3><p>题意是说，找到一些子数组，这些子数组的和都为指定的<code>target</code>,而且这些子数组不重叠，求这些子数组的个数的最大值。</p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p><code>DP+前缀和+hashmap</code></p>
<p>用<code>前缀和+hashmap</code>来找到目标和为<code>target</code>的子数组，用<code>dp</code>来保存状态。</p>
<ol>
<li><code>DP</code>思想</li>
</ol>
<blockquote>
<p><code>dp[i+1]</code>与<code>dp[i]</code>的关系</p>
<p>$dp[i+1] = max(dp[i],dp[j]+1),(\sum_{k=j+1}^{k\le(i+1)}arr[k] = target)$</p>
<p>如果有多个索引$j$满足条件呢,只需要保存离$i+1$最近的$j$即可，因为:</p>
<p>$dp[i]\ge dp[j],若(i\ge j)$</p>
</blockquote>
<ol>
<li>​    <code>前缀和+hashmap</code>思想</li>
</ol>
<blockquote>
<p>上面的<code>DP</code>的状态转移方程的<code>j</code>如何找到在内呢?</p>
<p>朴素的办法是从$i+1$前向累加，找到一个和为<code>target</code>的子数组。</p>
<p>这样的话，复杂度为$O(n^2)$,根据数据范围，肯定会超时，这里我们就可以用到<code>前缀和+hashmap</code>了。</p>
<p>具体来说:哈希表中保存（前缀和 -&gt; 索引）键值对。如果当前的前缀和为<code>sum</code>,那么我们只需要判断哈希表中是否存在<code>前缀和</code>(key)为<code>sum-target</code>的键值对，有的话，索引(值)就是上面<code>DP</code>的状态转移方程的<code>j</code>。</p>
</blockquote>
<h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNonOverlapping</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; t;	<span class="comment">// 前缀和 -&gt; 索引 的hashmap</span></span><br><span class="line">        t[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tcnt = <span class="number">0</span>;	<span class="comment">// 保存前缀和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i+<span class="number">1</span>] = dp[i];</span><br><span class="line">            tcnt+=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(t.find(tcnt-target)!=t.end())&#123;	<span class="comment">// 是否存在前缀和为tcnt - target的键值对</span></span><br><span class="line">                dp[i+<span class="number">1</span>] = max(dp[i+<span class="number">1</span>],dp[t[tcnt-target]]+<span class="number">1</span>);	<span class="comment">// 状态转移</span></span><br><span class="line">            &#125;</span><br><span class="line">            t[tcnt] = i+<span class="number">1</span>;	<span class="comment">// 更新hashmap</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个题目还是很不错的，主思路是<code>DP</code>,然后考虑到要快速的状态转移，使用<code>前缀和+hashmap</code>。</p>
<h3 id="切棍子的最小成本"><a href="#切棍子的最小成本" class="headerlink" title="切棍子的最小成本"></a><a href="https://leetcode-cn.com/contest/weekly-contest-201/problems/minimum-cost-to-cut-a-stick/" target="_blank" rel="noopener">切棍子的最小成本</a></h3><p>题意是：一段棍子，总长<code>n</code>切割一次的代价是<code>n</code>,求在<code>cuts</code>位置切割后的最小代价(切割顺序任意)。</p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p><code>DP</code>。</p>
<p>这个就是典型的区间<code>DP</code>问题，解法同<a href="https://leetcode-cn.com/problems/minimum-cost-to-merge-stones/" target="_blank" rel="noopener">合并石头的最低成本</a>。</p>
<p>这里有关于<a href="https://oi-wiki.org/dp/interval/" target="_blank" rel="noopener">区间dp</a>的解法。</p>
<h4 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cuts)</span> </span>&#123;</span><br><span class="line">        sort(cuts.<span class="built_in">begin</span>(),cuts.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        nums.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:cuts)&#123;nums.push_back(item);&#125;	<span class="comment">// 每段长</span></span><br><span class="line">        nums.push_back(n);</span><br><span class="line">        <span class="keyword">int</span> nil = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> tn = cuts.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(tn,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(tn,nil))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;=tn;len++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;(i+len)&lt;=tn;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(len==<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][i] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> j = i+len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j],nums[j+<span class="number">1</span>]-nums[i]+dp[i][k]+dp[k+<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][tn<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最近周赛的难度有所提高，总的来说题目难度不算很大，没有出现那种不知道思路的题目。题目的主要考察点是:</p>
<ol>
<li>数据结构栈</li>
</ol>
<blockquote>
<p>看漏了字母要相同这个条件，WA了5次，一度天真的以为题目的评测机有问题。。。。</p>
</blockquote>
<ol>
<li><code>DFS</code></li>
</ol>
<blockquote>
<p>divide and conquer,降低问题的规模</p>
</blockquote>
<ol>
<li><code>DP+前缀和+hashmap</code></li>
</ol>
<blockquote>
<p><code>前缀和+hashmap</code>找子数组和，<code>DP</code>是主思路</p>
</blockquote>
<ol>
<li><code>区间dp</code></li>
</ol>
<blockquote>
<p>旧瓶装新酒，石子合并问题</p>
</blockquote>
<p>还是那句话，多写写代码，保持对代码的敏锐。</p>
<p>最后，如果对题解有疑问或者有更好的解法，欢迎来邮件，一定知无不言，言无不尽。</p>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣周赛203</title>
    <url>/2020/08/23/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B203/</url>
    <content><![CDATA[<p>这篇文章主要记录一下第203场力扣周赛的题目解答。以下是四个题目:</p>
<ol>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-203/problems/most-visited-sector-in-a-circular-track/" target="_blank" rel="noopener">圆形赛道上经过次数最多的扇区</a>: 3分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-203/problems/maximum-number-of-coins-you-can-get/" target="_blank" rel="noopener">你可以获得的最大硬币数目</a>: 4分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-203/problems/find-latest-group-of-size-m/" target="_blank" rel="noopener">查找大小为 M 的最新分组</a>: 6分</li>
<li><a href="石子游戏 V">石子游戏 V</a>：7分</li>
</ol>
<a id="more"></a>
<h3 id="圆形赛道上经过次数最多的扇区"><a href="#圆形赛道上经过次数最多的扇区" class="headerlink" title="圆形赛道上经过次数最多的扇区"></a><a href="https://leetcode-cn.com/contest/weekly-contest-203/problems/most-visited-sector-in-a-circular-track/" target="_blank" rel="noopener">圆形赛道上经过次数最多的扇区</a></h3><p>题目的意思就是沿着一个圆形的扇区跑道赛跑，从初始位置到结束位置中，哪些扇区被经过的次数最多。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>从位置<code>s</code>到结束位置<code>d</code>,由于扇区构成一个环，那么，<code>s</code>到<code>d</code>之间的所有扇区的经过次数都比其他位置多1。</p>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mostVisited</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rounds)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> s = rounds[<span class="number">0</span>]<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> d = rounds.back()%n;</span><br><span class="line">        <span class="keyword">while</span>(s!=d)&#123;	<span class="comment">// s~d之间的所有扇区</span></span><br><span class="line">            res.push_back(s+<span class="number">1</span>);</span><br><span class="line">            s=(s+<span class="number">1</span>)%n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123; dp[i]=i+<span class="number">1</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> dp;	<span class="comment">// 所有扇区的经过次数都相等</span></span><br><span class="line">        sort(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="你可以获得的最大硬币数目"><a href="#你可以获得的最大硬币数目" class="headerlink" title="你可以获得的最大硬币数目"></a><a href="https://leetcode-cn.com/contest/weekly-contest-203/problems/maximum-number-of-coins-you-can-get/" target="_blank" rel="noopener">你可以获得的最大硬币数目</a></h3><p>题意就是每次操作只能选取次大的值，求可能的最大得分。</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>贪心。</p>
<p>尽可能地选取较大值。那么可以采用的策略是：</p>
<p>1号取最大值，2号取次大值，3号取所有数最小值。</p>
<h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        sort(piles.<span class="built_in">begin</span>(),piles.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> n = piles.<span class="built_in">size</span>()/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=<span class="number">1</span>)&#123;</span><br><span class="line">            piles.pop_back();</span><br><span class="line">            res+=piles.back();	<span class="comment">// 选取次大值</span></span><br><span class="line">            piles.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="查找大小为-M-的最新分组"><a href="#查找大小为-M-的最新分组" class="headerlink" title="查找大小为 M 的最新分组"></a><a href="https://leetcode-cn.com/contest/weekly-contest-203/problems/find-latest-group-of-size-m/" target="_blank" rel="noopener">查找大小为 M 的最新分组</a></h3><p>题目意思是，每轮操作后，如果有连续1的个数为<code>m</code>,那么这轮“有效”，求在所有“有效”的轮数中的最大值。</p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>我们需要动态维护连续1的个数，同时每一次操作都可能破环前面，或者后面的连续的个数。</p>
<p>那么可以用一个hash表来维护连续1个数的种类以及出现次数。</p>
<blockquote>
<p>map : key (连续key个1) -&gt; value(出现了value次）</p>
</blockquote>
<p>同时，我们需要高效地处理左右两侧连续1的合并问题。</p>
<p>用一个有序的map维护。</p>
<blockquote>
<p>ordered map: key （连续1的初始位置）-&gt; value（连续1的个数）</p>
</blockquote>
<p>每次操作包含以下部分:</p>
<ol>
<li>插入ordered map</li>
<li>合并当前位置与之后的位置(能合并就合并)</li>
<li>合并当前位置与之前的位置(能合并就合并)</li>
</ol>
<p>合并操作:</p>
<p>第一更新ordered map，第二更新hash map.</p>
<h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分+哈希求解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLatestStep</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; t;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; tt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> pos = arr[i];</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                t[pos] = <span class="number">1</span>;</span><br><span class="line">                tt[<span class="number">1</span>]++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">auto</span> ite = t.upper_bound(pos);</span><br><span class="line">                <span class="keyword">if</span>(ite!=t.<span class="built_in">end</span>() &amp;&amp; (ite-&gt;first == pos+<span class="number">1</span>))&#123;	<span class="comment">// 合并当前位置与后面的位置</span></span><br><span class="line">                    cnt+=ite-&gt;second;</span><br><span class="line">                    tt[ite-&gt;second]--;</span><br><span class="line">                    t.erase(ite);	<span class="comment">// 删除该位置(没有必要)</span></span><br><span class="line">                    t[pos]=cnt;</span><br><span class="line">                    tt[cnt]++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    t[pos]=cnt;</span><br><span class="line">                    tt[cnt]++;</span><br><span class="line">                &#125;</span><br><span class="line">                ite = t.lower_bound(pos);</span><br><span class="line">                <span class="keyword">if</span>(ite!=t.<span class="built_in">begin</span>())&#123;	<span class="comment">// 合并当前位置与前面的位置</span></span><br><span class="line">                    --ite;</span><br><span class="line">                    <span class="keyword">if</span>((ite-&gt;first + ite-&gt;second) ==pos)&#123;</span><br><span class="line">                        tt[ite-&gt;second]--;</span><br><span class="line">                        tt[cnt]--;</span><br><span class="line">                        ite-&gt;second +=cnt;</span><br><span class="line">                        tt[ite-&gt;second]++;</span><br><span class="line">                        t.erase(pos);	<span class="comment">// 删除该位置(没有必要)</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(tt[m]) res= i+<span class="number">1</span>;	<span class="comment">// 存在有m个1的连续子数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更新一下，这里我看到有人用并查集了，我尝试写了一下，可以通过，有兴趣的可以看看。仅供参考。如果有更好的解法，可以联系我(左侧有邮箱地址)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并查集求解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;t,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[x] != x) t[x] = find(t,t[x]);</span><br><span class="line">        <span class="keyword">return</span> t[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLatestStep</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">t</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) t[i] = i;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; tt;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> item = arr[i]<span class="number">-1</span>;</span><br><span class="line">            dp[item] = <span class="number">1</span>;</span><br><span class="line">            tt[<span class="number">1</span>]++;</span><br><span class="line">            <span class="keyword">if</span>((item+<span class="number">1</span>)&lt;n &amp;&amp; dp[item+<span class="number">1</span>])&#123;	<span class="comment">// 与后端合并</span></span><br><span class="line">                <span class="keyword">int</span> bcnt = dp[find(t,item+<span class="number">1</span>)];</span><br><span class="line">                tt[bcnt]--;</span><br><span class="line">                tt[<span class="number">1</span>]--;</span><br><span class="line">                t[find(t,item+<span class="number">1</span>)] = item;</span><br><span class="line">                dp[item] +=bcnt;</span><br><span class="line">                tt[dp[item]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(item &amp;&amp; dp[item<span class="number">-1</span>])&#123;	<span class="comment">// 与前端合并</span></span><br><span class="line">                <span class="keyword">int</span> pcnt = dp[find(t,item<span class="number">-1</span>)];</span><br><span class="line">                tt[pcnt]--;</span><br><span class="line">                tt[dp[item]]--;</span><br><span class="line">                t[find(t,item)] = t[find(t,item<span class="number">-1</span>)];</span><br><span class="line">                dp[find(t,item<span class="number">-1</span>)]+=dp[item];</span><br><span class="line">                tt[dp[find(t,item<span class="number">-1</span>)]]++;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tt[m]) res = i+<span class="number">1</span>;	<span class="comment">// 存在有m个1的连续子数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="石子游戏-V"><a href="#石子游戏-V" class="headerlink" title="石子游戏 V"></a><a href="石子游戏 V">石子游戏 V</a></h3><p>题意就是每次你能够选取得到一段连续的和，这段和不能超过另一区间。而且只能分割成两个区间。</p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>区间DP。记忆化递归。</p>
<p>状态表示:$dp[i][j]$，区间$[i,j]$能够获得的最大得分。</p>
<p>状态转移:$dp[i][j]$分割成（$dp[i][k]$与$dp[k+1][j]$） 在这两种可能的状态上做转移。</p>
<h4 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;dp,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;sif)</span></span>&#123;	<span class="comment">// dp[i][j]</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j] != <span class="number">-1</span>) <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        <span class="keyword">int</span> sum = sif[j+<span class="number">1</span>]-sif[i];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=i;l&lt;j;l++)&#123;</span><br><span class="line">            cnt = sif[l+<span class="number">1</span>]-sif[i];</span><br><span class="line">            <span class="keyword">if</span>(cnt&lt;=(sum-cnt))&#123;	<span class="comment">// 可以选择区间[i,l]</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j],cnt+dfs(i,l,dp,sif));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;=(sum-cnt))&#123;<span class="comment">// 可以选择区间[l+1,j]</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j],sum-cnt+dfs(l+<span class="number">1</span>,j,dp,sif));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stoneGameV</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; sv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = sv.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">-1</span>))</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sif</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            sif[i]=sif[i<span class="number">-1</span>]+sv[i<span class="number">-1</span>];	<span class="comment">// 前缀和</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,n<span class="number">-1</span>,dp,sif);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里把我比赛过程中写的TLE的代码也列出来:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TLE</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stoneGameV</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; sv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = sv.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sif</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            sif[i]=sif[i<span class="number">-1</span>]+sv[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;(i+len)&lt;=n;i++)&#123;	<span class="comment">// 这里计算了太多无用的状态</span></span><br><span class="line">                <span class="keyword">int</span> j = i+len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">int</span> sumij = sif[j+<span class="number">1</span>]-sif[i];</span><br><span class="line">                <span class="keyword">int</span> sumik = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)&#123;</span><br><span class="line">                    sumik+=sv[k];</span><br><span class="line">                    <span class="keyword">int</span> sumkj = sumij-sumik;</span><br><span class="line">                    <span class="keyword">if</span>(sumik&gt;sumkj)&#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">max</span>(dp[i][j],sumkj+dp[k+<span class="number">1</span>][j]);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sumik&lt;sumkj)&#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">max</span>(dp[i][j],sumik+dp[i][k]);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">max</span>(dp[i][j],sumik+<span class="built_in">max</span>(dp[i][k],dp[k+<span class="number">1</span>][j]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码的复杂度为$O(n^3)$,超时。中间计算了太多的无用状态，导致超时。</p>
<p>更新一下，这里有人讨论了这个类似$O(n^3)$的解法，发现使用静态数组(提前分配内存)可以AC，这就尴尬了😅。。。测试数据可能不太强吧。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>题1读题有点麻烦，难度不大，当时每给结果排序，WA了一次。心态有点差。</li>
<li>很快想到了贪心思路</li>
<li>思路没啥毛病，在处理边界条件上花了点时间</li>
<li>无脑地写了个$O(n^3)$的解法，TLE一波。这个题目本身是不难的。</li>
</ol>
<p>总的来说，这场比赛第3题有点意思，其他题目都中规中矩。还是得多练练，同时心态也很重要，第一题WA了一次自己就有点爆炸了，ohhhhhh。继续努力吧。</p>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>记忆化递归</tag>
        <tag>区间合并</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣每日打卡20200506</title>
    <url>/2020/05/06/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A120200506/</url>
    <content><![CDATA[<p>这篇文章是关于<code>力扣每日打卡</code>的题目的一点点记录。</p>
<p>题目: <a href="https://leetcode-cn.com/problems/minimum-cost-for-tickets/" target="_blank" rel="noopener">最低票价</a></p>
<p>难度：中</p>
<a id="more"></a>
<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。</p>
<p>火车票有三种不同的销售方式：</p>
<p>一张为期一天的通行证售价为 costs[0] 美元；<br>一张为期七天的通行证售价为 costs[1] 美元；<br>一张为期三十天的通行证售价为 costs[2] 美元。<br>通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。</p>
<p>返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：days &#x3D; [1,4,6,7,8,20], costs &#x3D; [2,7,15]</span><br><span class="line">输出：11</span><br><span class="line">解释： </span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：</span><br><span class="line">在第 1 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 1 天生效。</span><br><span class="line">在第 3 天，你花了 costs[1] &#x3D; $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。</span><br><span class="line">在第 20 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 20 天生效。</span><br><span class="line">你总共花了 $11，并完成了你计划的每一天旅行。</span><br><span class="line"></span><br><span class="line">输入：days &#x3D; [1,2,3,4,5,6,7,8,9,10,30,31], costs &#x3D; [2,7,15]</span><br><span class="line">输出：17</span><br><span class="line">解释：</span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： </span><br><span class="line">在第 1 天，你花了 costs[2] &#x3D; $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。</span><br><span class="line">在第 31 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 </span><br><span class="line">你总共花了 $17，并完成了你计划的每一天旅行。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1. 1 &lt;&#x3D; days.length &lt;&#x3D; 365</span><br><span class="line">2. 1 &lt;&#x3D; days[i] &lt;&#x3D; 365</span><br><span class="line">3. days 按顺序严格递增</span><br><span class="line">4. costs.length &#x3D;&#x3D; 3</span><br><span class="line">5. 1 &lt;&#x3D; costs[i] &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><code>days</code>数组是严格递增的，那么在某个位置<code>i</code>（下标）,其天数信息为<code>day[i]</code>，有三种可选的计划方案:</p>
<ol>
<li>选取<code>为期1天</code>的通行证，那么在<code>[days[i],days[i]+1-1]</code>中的旅游不需要通行证，直接跳转到<strong>大于等于</strong><code>day[i]+1</code>处，设此处小标为<code>j</code>，那么有关系<code>dp[i] = dp[i]+1天通行证的代价</code></li>
<li>选取<code>为期7天</code>的通行证，同理在<code>[days[i],days[i]+7-1]</code>中的旅游不需要通行证,直接跳转到<strong>大于等于</strong><code>day[i]+7</code>处，设此处小标为<code>j</code>，那么有关系<code>dp[i] = dp[i]+7天通行证的代价</code></li>
<li>选取<code>为期30天</code>的通行证,同理</li>
</ol>
<p>只需取上面三种可能中的较小值即可。</p>
<p>初始条件设置当位置<code>i</code>为<code>n</code>（n为<code>days</code>的元素个数）时，代价为0。</p>
<p>按照上面的分析可以得出要求的结果为<code>dp[0]</code></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;days,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;costs,<span class="keyword">int</span> idx,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;dir,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = days.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(dp[idx] != <span class="number">-1</span>) <span class="keyword">return</span> dp[idx];   <span class="comment">// memo</span></span><br><span class="line">        dp[idx] = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tcost = costs[i];   <span class="comment">// 当前选取不同类别通行证的代价</span></span><br><span class="line">            <span class="keyword">int</span> rangeR = days[idx]+dir[i]<span class="number">-1</span>; <span class="comment">// 通行证的覆盖范围[idx,rangeR]</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 二分查找</span></span><br><span class="line">            <span class="comment">// 通行证未覆盖的最小下标</span></span><br><span class="line">            <span class="keyword">int</span> l = upper_bound(days.<span class="built_in">begin</span>(),days.<span class="built_in">end</span>(),rangeR)-days.<span class="built_in">begin</span>();</span><br><span class="line">            dp[idx] = <span class="built_in">min</span>(dp[idx],dfs(days,costs,l,dir,dp)+tcost);  <span class="comment">// 状态转移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; days, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dir = &#123;<span class="number">1</span>,<span class="number">7</span>,<span class="number">30</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = days.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        dp[n] = <span class="number">0</span>;  <span class="comment">// 初始化条件</span></span><br><span class="line">        <span class="keyword">return</span> dfs(days,costs,idx,dir,dp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>主方向：<code>dp</code></li>
<li>状态如何转移，上一或者下一状态的位置如何确定</li>
<li>初始条件是什么</li>
</ol>
<p>官方题解以及其他用户的题解也是相当的不错，都可以用自己熟悉的语言实现一下看看。</p>
<p>最后附上一首词:</p>
<center>青杏儿</center>

<center>[金]赵秉文</center>

<center>风雨替花愁。风雨罢，花也应休。劝君莫惜花前醉，今年花谢，明年花谢，白了人头。</center>

<center>乘兴两三瓯。拣溪山好处追游。但教有酒身无事，有花也好，无花也好，选甚春秋。</center>

<center></center>]]></content>
      <categories>
        <category>力扣打卡</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>力扣</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣每日打卡20200507</title>
    <url>/2020/05/07/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A120200507/</url>
    <content><![CDATA[<p>这篇文章是关于<code>力扣每日打卡</code>的题目的一点点记录。</p>
<p>题目: <a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">另一个树的子树</a></p>
<p>难度：易</p>
<a id="more"></a>
<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定的树 s:</span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line"> 给定的树t:</span><br><span class="line">   4 </span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line"> 返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</span><br><span class="line"> </span><br><span class="line"> 给定的树 s：</span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line">    &#x2F;</span><br><span class="line">   0</span><br><span class="line">给定的树 t：</span><br><span class="line">   4</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line"> 返回 false。</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><code>t</code>要是<code>s</code>的子树，只能是下面的三种情形:</p>
<ol>
<li><code>t</code>是<code>s</code>的左子树的子树</li>
<li><code>t</code>是<code>s</code>的右子树的子树</li>
<li><code>t</code>与<code>s</code>相同</li>
</ol>
<p>上面1、2两点可以通过递归调用<code>isSubTree</code>实现，第3点可以通过写一个辅助函数<code>is_same</code>实现，同时<code>is_same</code>函数同样是递归结构。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_same</span><span class="params">(TreeNode *s,TreeNode *t)</span></span>&#123;  <span class="comment">// 相同的树结构</span></span><br><span class="line">        <span class="keyword">if</span>(s==t &amp;&amp; s==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s-&gt;val != t-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> is_same(s-&gt;left,t-&gt;left) &amp;&amp; is_same(s-&gt;right,t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(isSubtree(s-&gt;left,t)) <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">// t是s的左子树的子树</span></span><br><span class="line">        <span class="keyword">if</span>(isSubtree(s-&gt;right,t)) <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">// t是s的右子树的子树</span></span><br><span class="line">        <span class="keyword">return</span> is_same(s,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>要点是递归</li>
<li>分析递归基</li>
</ol>
<p>总的来说该题难度很小，只需要细致地分析其递归基就能很快地写出<code>bug free</code>的代码。</p>
]]></content>
      <categories>
        <category>力扣打卡</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>力扣</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>画饼计划</title>
    <url>/2020/08/06/%E7%94%BB%E9%A5%BC%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p>学习计算机相关的知识总是有点不成体系。”学过”的知识容易忘记，而且很难将自己学到的理论转化为代码。最重要的仍然是实践，但是如果理论不强的话，写出的代码也不会是非常优雅、易懂的。所以自己想给自己画一个大饼，让自己能够补充相关的基础知识。</p>
<a id="more"></a>
<p>先来看一下需要补充哪些基础知识呢?</p>
<ul>
<li>操作系统</li>
<li>数据结构与算法</li>
<li>计算机网络</li>
</ul>
<p>除了上面三个大类以外，比如说编程语言这样的基础工具也是必要的。目前来说，相对熟悉一点的就是<code>c++</code>了。与语言相关的东西也比较多:</p>
<ol>
<li>语法</li>
<li>标准库</li>
<li>编译工具</li>
</ol>
<p>上面这些是作为一个程序员必须要不断熟悉、提高的。自己学习的时候虽然有记录，但是都没有对记录做相应的总结，真是遗憾。这里先给自己立下一个flag：坚持写总结的博文。</p>
<p>下面是真正的画饼时刻了:</p>
<h4 id="操作系统相关"><a href="#操作系统相关" class="headerlink" title="操作系统相关:"></a>操作系统相关:</h4><ul>
<li><p>CSAPP</p>
<ul>
<li><a href="http://csapp.cs.cmu.edu/3e/home.html" target="_blank" rel="noopener">网站</a></li>
<li>读书笔记</li>
<li>习题（习题是非常有价值的）</li>
<li>Lab</li>
</ul>
</li>
<li><p>OSTEP</p>
<ul>
<li><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/" target="_blank" rel="noopener">网站</a></li>
<li>习题</li>
<li>项目</li>
</ul>
</li>
</ul>
<p>另外，<a href="https://wiki.osdev.org/Main_Page" target="_blank" rel="noopener">网站</a>中有大量与开发操作系统相关的资料，也可以参考参考。</p>
<h4 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h4><p>数据结构与算法这个是特别重要的，也是特别注重实践的部分。这部分的话没什么可以说的，多做做题目才能融汇贯通。这里只列举几个自己常使用的做题网站。</p>
<ul>
<li><p><a href="https://oi-wiki.org/" target="_blank" rel="noopener">OIwiki</a>: 基本罗列了所有的知识点，尽管有些部分不容易理解</p>
</li>
<li><p><a href="https://leetcode-cn.com/problemset/all/" target="_blank" rel="noopener">力扣</a>: 面向面试的刷题社区</p>
</li>
<li><a href="https://codeforces.ml/" target="_blank" rel="noopener">codeforcres</a>: 虽然是面向竞赛，但是有的题目难度是可以用来作为训练使用的。</li>
<li><a href="https://atcoder.jp/home" target="_blank" rel="noopener">atcoder</a>：个人觉得题目质量高，废话少</li>
</ul>
<h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><p>计算机网络的知识比较多，也比较麻烦。</p>
<ul>
<li>书籍《TCP/IP详解:卷Ⅰ》</li>
<li>书籍《Linux高性能服务器编程》</li>
<li>陈硕的《<a href="https://blog.csdn.net/Solstice/article/details/8493251" target="_blank" rel="noopener">Linux 多线程服务端编程：使用 muduo C++ 网络库</a>》</li>
</ul>
<blockquote>
<p>这本书我零零散散地看了一点，感觉写的特别好，不过有些东西不大懂，有点一知半解，通过《Linux高性能服务器编程》可以补充一些东西。</p>
</blockquote>
<p>最后，在这里先提醒自己一下，不要贪多。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>画饼</tag>
      </tags>
  </entry>
  <entry>
    <title>宏中的do_while</title>
    <url>/2020/08/19/%E5%AE%8F%E4%B8%AD%E7%9A%84do-while/</url>
    <content><![CDATA[<p>这篇小记是记录一下关于<code>c/c++</code>宏中使用<code>do{}while()</code>的问题。基本翻译自<a href="https://www.pixelstech.net/article/1390482950" target="_blank" rel="noopener">文章</a>.</p>
<p>关于宏的使用问题，这里不想详细地叙述，但是关于宏，只需知道:</p>
<ol>
<li>宏只是字符串的简单替换</li>
<li>宏有较多副作用</li>
</ol>
<p>宏的使用尽管有很多的缺陷，但是宏仍然是一个编码的重要技巧。这里只说一下关于很多代码库的宏中使用了<code>c/c++</code>的<code>do...while()</code>循环。</p>
<a id="more"></a>
<h4 id="问1-为什么要在宏使用do-while"><a href="#问1-为什么要在宏使用do-while" class="headerlink" title="问1 : 为什么要在宏使用do...while()?"></a>问1 : 为什么要在宏使用<code>do...while()</code>?</h4><blockquote>
<p>do{…}while(0) is the only construct in C that lets you define macros that always work the same way, so that a semicolon after your macro always has the same effect, regardless of how the macro is used (with particularly emphasis on the issue of nesting the macro in a if without curly-brackets).</p>
<p>do{…}while(0)在C中是唯一的构造程序，让你定义的宏总是以相同的方式工作，这样不管怎么使用宏（尤其在没有用大括号包围调用宏的语句），宏后面的分号也是相同的效果。</p>
</blockquote>
<p>来自前linux内核工程师 Robert Love的解释。</p>
<h4 id="问2-如果不按照do-while-的形式来写宏，有什么后果吗"><a href="#问2-如果不按照do-while-的形式来写宏，有什么后果吗" class="headerlink" title="问2 : 如果不按照do...while()的形式来写宏，有什么后果吗?"></a>问2 : 如果不按照<code>do...while()</code>的形式来写宏，有什么后果吗?</h4><p>我们按照普通的形式来写一个函数宏,这个宏中会调用两个函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> baz(x) foo(x);bar(x)</span></span><br></pre></td></tr></table></figure>
<p>这样的形式（将一个函数扩展为多个函数，或者多个语句）在<code>if</code>语句中使用时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!feral)</span><br><span class="line">    baz(x);</span><br></pre></td></tr></table></figure>
<p>替换为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!feral)</span><br><span class="line">	foo(x);</span><br><span class="line">    bar(x);</span><br></pre></td></tr></table></figure>
<p>这样就与我们的调用意图不一致了。我们的本意是:</p>
<p>在<code>!feral</code>时，调用<code>foo(x);bar(x)</code>这个整体，当时上面的替换结果含义就不同了。</p>
<p>如果使用<code>do..while()</code>改写就是如下形式:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> baz(x) do&#123;foo(x);bar(x);&#125;while(0)</span></span><br></pre></td></tr></table></figure>
<p>得到替换后代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!feral)</span><br><span class="line">    <span class="keyword">do</span>&#123;foo();bar(x);&#125;<span class="keyword">while</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>与想要的结果(<code>foo(x)</code>与<code>bar(x)</code>作为一个整体调用)一致。没有歧义产生。</p>
<h4 id="问3：改用-包起来行不行？"><a href="#问3：改用-包起来行不行？" class="headerlink" title="问3：改用{}包起来行不行？"></a>问3：改用<code>{}</code>包起来行不行？</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> baz(x) &#123;foo(x);bar(x);&#125;</span></span><br></pre></td></tr></table></figure>
<p>将原始代码替换成:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!feral)</span><br><span class="line">	&#123;foo(x);bar(x);&#125;;</span><br></pre></td></tr></table></figure>
<p>编译错误。</p>
<h4 id="问4：为什么不使用while-的形式"><a href="#问4：为什么不使用while-的形式" class="headerlink" title="问4：为什么不使用while(){}的形式?"></a>问4：为什么不使用<code>while(){}</code>的形式?</h4><p>使用<code>while(...){...}</code>的形式与使用<code>{}</code>效果是一致的，同样无法编译成功。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>In conclusion, macros in Linux and other codebases wrap their logic in do/while(0) because it ensures the macro always behaves the same, regardless of how semicolons and curly-brackets are used in the invoking code.</p>
</blockquote>
<p>在宏中使用<code>do{}while(0)</code>的形式来将多个语句组合是一种编写宏的优秀的小技巧。目的是为了避免出现宏替换的副作用，让宏的行为保持一致。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>[1]. <a href="https://www.pixelstech.net/article/1390482950" target="_blank" rel="noopener">https://www.pixelstech.net/article/1390482950</a></p>
<p>[2]. <a href="https://www.cnblogs.com/lanxuezaipiao/p/3535626.html" target="_blank" rel="noopener"><code>do{}while(0)</code>在宏定义中的作用</a></p>
<p>[3]. <a href="https://zhuanlan.zhihu.com/p/22460835" target="_blank" rel="noopener">从零开始的 JSON 库教程</a>(宏大量使用<code>do{}while(0)</code>)</p>
]]></content>
      <categories>
        <category>代码技巧</category>
      </categories>
      <tags>
        <tag>宏</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次失败的面试</title>
    <url>/2020/08/18/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>最近收到了国内的一家互联网公司的面试邀请，参与了面试。大概率是过不了，特来记录一下，总结一下经验教训，也是提醒自己，让自己明白自己的问题在哪儿。</p>
<a id="more"></a>
<p>这次面试是在我之前投递简历后的第二次面试，第一次面试倒在了技术面试的第二轮。这次是一面、二面一起面试，耗时两个半小时。。。真的长。</p>
<p>这次一面提前5分钟进入视频中，没想到面试官也早早地到了。上来非常直接，向我直接说了我在<code>力扣</code>上的排名情况，也聊了一些关于刷题的情况，这个面试官人特别好，全程非常热心地与我交流，完全没有架子，毫不夸张地说，这是我见过地最友善的面试官了。比如我们吐槽<code>codeforces</code>的题意描述很怪异，<code>atcoder</code>的题目描述更加简洁，有些题目质量也非常高。刚开始完全是聊天。</p>
<p>进入面试时间后，让我自我介绍，花了几分钟介绍后，就开始写代码了，完全没有任何的拖沓，面试官给人干脆利落的感觉，当然这里自己也有点心虚，怕面试官出很难的题，那就尴尬了。好在面试官出题的水平极高，以一个简单的<code>快速幂</code>开始，然后开展高精度的加法与乘法，期间面试官不断地与我一起讨论一些延申问题，聊天过程非常愉快，也很轻松。实现的过程中也遇到了一些问题，其中算法实现的问题也很快定位解决了，面试官也对自己代码能力也十分肯定，自己当时非常开心(有人认可自己写的垃圾代码，泪目啊)，然后面试官与我聊了一些关于数据结构与算法的一些学习经验，全程讨论技术知识。面试官也纠正了一些关于我对复杂度理论的错误认识，非常有能力的一位技术人。全程在聊算法的知识，比如计算机操作系统、网络以及数据库相关的知识完全没有提及，这个面试官独树一帜。手写的代码也基本符合面试官的要求，很轻松的就完成了这个技术一面。</p>
<p>这个技术一面的面试官让我看到了这个面试官对于技术的热情，聊天中完全没有吹嘘的成分，感觉是朋友之间的聊天，体验非常棒。无论是讨论算法的实现，还是算法的优化，面试官都非常热心，真的是一位优秀的工程师，对于我的一些小问题也提出了修改意见，人非常不错，点赞👍。</p>
<p>一面结束后，一面的面试官去叫了二面的面试官，自此，我的好运结束了，我将迎接无尽的尴尬。。。。</p>
<p>面试流程仍然是先做自我介绍，然后问一下项目相关的。因为自己本身用的技术非常偏，全程尬聊。</p>
<p>在聊项目的过程中，自己的语言组织能力很差，很多东西都没有表达清楚，对于面试官的提问也回答地差强人意。其中聊到了智能指针，c++面向对象与面向过程的选择。后来面试官出了一道概率论的题目，这道题目我死活没有弄懂是啥意思，在那里与面试官尬聊。。。后来面试官出了一道场景代码题，这个题同样让面试变得尴尬。我对面试官给的题目倒是了解了，但是可能思考的方向上存在巨大差异，我的回答让面试官非常不满意，始终没有搞懂面试要考察的点，非常差劲。最后面试官结束了这场尴尬的面试。</p>
<p>第二轮的面试真的让我感到自己表达能力的不足，无论是抓住面试官要的重点，还是将自己的经历有条理的梳理，自己都做得不够，这场面试虽然有点不走寻常路，但是也提醒自己：将自己所做的事情清晰的表达出来也是一件非常重要的事情。同时不要仅仅只关注代码，代码只是占据工作时间的一小部分，更多的时间是在寻找问题以及解决问题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>基本的代码能力是基本要求</li>
<li>强大的调试能力是工作中的重要技能</li>
<li>良好的表达能力也是非常非常重要的</li>
</ol>
<p>虽然第一面的体验非常好，那是因为一面的面试官只关注了代码，二面的面试官更看重业务能力。这两种能力在工作中的重要性是不言而喻的，代码只是最最基本的要求，业务能力(调试、代码组织能力、沟通能力等等)才是更为重要的。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
