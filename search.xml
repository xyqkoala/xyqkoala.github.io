<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/30/hello-world/</url>
    <content><![CDATA[<p>这篇文章主要用来测试自己的博客。检测搭建的博客是否有问题。</p>
<p>主要测试排版以及数学公式的使用。</p>
<a id="more"></a>
<h4 id="cpp代码块"><a href="#cpp代码块" class="headerlink" title="cpp代码块"></a><code>cpp</code>代码块</h4><p>下面测试一下博客的代码块功能，不关注语法高亮。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello,World!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mathjax公式块"><a href="#mathjax公式块" class="headerlink" title="mathjax公式块"></a><code>mathjax</code>公式块</h4><h5 id="行间公式"><a href="#行间公式" class="headerlink" title="行间公式"></a>行间公式</h5><p>测试在<code>markdown</code>文档中插入独占一行的公式。</p>
<script type="math/tex; mode=display">
\frac{x}{y} = cos(x_{1}+x_{1}^{2})</script><h5 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h5><p>测试在<code>markdown</code>文档中嵌入文章内的公式。</p>
<p>公式前 $\frac{x}{y} = cos(x_{1}+x_{1}^{2})$ 公式后。</p>
<h4 id="rust代码块"><a href="#rust代码块" class="headerlink" title="rust代码块"></a><code>rust</code>代码块</h4><p>下面测试以下<code>rust</code>代码的代码块。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,<span class="string">"Hello,World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣周赛186</title>
    <url>/2020/04/30/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B186/</url>
    <content><![CDATA[<p>鄙文章是第186场周赛的题目解答。题目个数仍然是四个。四个小题的分数分别是：</p>
<ol>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/maximum-score-after-splitting-a-string/" target="_blank" rel="noopener">分割字符串的最大得分</a> : 3 分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/maximum-points-you-can-obtain-from-cards/" target="_blank" rel="noopener">可获得的最大点数</a> :  4分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/diagonal-traverse-ii/" target="_blank" rel="noopener">对角线遍历 II</a> : 5分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/constrained-subsequence-sum/" target="_blank" rel="noopener">带限制的子序列和</a> : 6分</li>
</ol>
<a id="more"></a>
<h3 id="分割字符串的最大得分"><a href="#分割字符串的最大得分" class="headerlink" title="分割字符串的最大得分"></a><a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/maximum-score-after-splitting-a-string/" target="_blank" rel="noopener">分割字符串的最大得分</a></h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给你一个由若干 0 和 1 组成的字符串 <code>s</code> ，请你计算并返回将该字符串分割成两个 <strong>非空</strong> 子字符串（即 <strong>左</strong> 子字符串和 <strong>右</strong> 子字符串）所能获得的最大得分。</p>
<p>「分割字符串的得分」为 <strong>左</strong> 子字符串中 <strong>0</strong> 的数量加上 <strong>右</strong> 子字符串中 <strong>1</strong> 的数量。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;011101&quot;</span><br><span class="line">输出：5 </span><br><span class="line">解释：</span><br><span class="line">将字符串 s 划分为两个非空子字符串的可行方案有：</span><br><span class="line">左子字符串 &#x3D; &quot;0&quot; 且 右子字符串 &#x3D; &quot;11101&quot;，得分 &#x3D; 1 + 4 &#x3D; 5 </span><br><span class="line">左子字符串 &#x3D; &quot;01&quot; 且 右子字符串 &#x3D; &quot;1101&quot;，得分 &#x3D; 1 + 3 &#x3D; 4 </span><br><span class="line">左子字符串 &#x3D; &quot;011&quot; 且 右子字符串 &#x3D; &quot;101&quot;，得分 &#x3D; 1 + 2 &#x3D; 3 </span><br><span class="line">左子字符串 &#x3D; &quot;0111&quot; 且 右子字符串 &#x3D; &quot;01&quot;，得分 &#x3D; 1 + 1 &#x3D; 2 </span><br><span class="line">左子字符串 &#x3D; &quot;01110&quot; 且 右子字符串 &#x3D; &quot;1&quot;，得分 &#x3D; 2 + 1 &#x3D; 3</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;00111&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：当 左子字符串 &#x3D; &quot;00&quot; 且 右子字符串 &#x3D; &quot;111&quot; 时，我们得到最大得分 &#x3D; 2 + 3 &#x3D; 5</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;1111&quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>要找到一个分割点，这个分割点将字符串<code>s</code>分为两个<strong>非空</strong>的子串。按照题目要求遍历所有的可能分割点，求每个分割点的得分并取最大值。</p>
<h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(item ==<span class="string">'1'</span>) cnt++;	<span class="comment">// 整个串中'1'的个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> tcnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n<span class="number">-1</span>);i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'1'</span>) tcnt+=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 左串'0'的个数为(i+1-tcnt)</span></span><br><span class="line">            <span class="comment">// 右串'1'的个数为(cnt-tcnt)</span></span><br><span class="line">            res = <span class="built_in">max</span>(res,i+<span class="number">1</span>-tcnt+cnt-tcnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="可获得的最大点数"><a href="#可获得的最大点数" class="headerlink" title="可获得的最大点数"></a><a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/maximum-points-you-can-obtain-from-cards/" target="_blank" rel="noopener">可获得的最大点数</a></h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>几张卡牌 <strong>排成一行</strong>，每张卡牌都有一个对应的点数。点数由整数数组 <code>cardPoints</code> 给出。</p>
<p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 <code>k</code> 张卡牌。</p>
<p>你的点数就是你拿到手中的所有卡牌的点数之和。</p>
<p>给你一个整数数组 <code>cardPoints</code> 和整数 <code>k</code>，请你返回可以获得的最大点数。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：cardPoints &#x3D; [1,2,3,4,5,6,1], k &#x3D; 3</span><br><span class="line">输出：12</span><br><span class="line">解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 &#x3D; 12 。</span><br><span class="line"></span><br><span class="line">输入：cardPoints &#x3D; [2,2,2], k &#x3D; 2</span><br><span class="line">输出：4</span><br><span class="line">解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。</span><br><span class="line"></span><br><span class="line">输入：cardPoints &#x3D; [9,7,7,9,7,7,9], k &#x3D; 7</span><br><span class="line">输出：55</span><br><span class="line">解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。</span><br></pre></td></tr></table></figure>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>由于只能从两端取元素，最终只能是左侧取$cnt(0 \le cnt \le k)$个元素，右侧取$k-cnt$个元素，枚举$cnt$的所有可能取值，并更新最大得分。</p>
<h4 id="实现示例-1"><a href="#实现示例-1" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cp, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = cp.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-k;i&lt;n;i++)&#123;</span><br><span class="line">            r+=cp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;<span class="comment">// 左侧取(i+1)个元素</span></span><br><span class="line">            l+=cp[i];   <span class="comment">// 左侧得分</span></span><br><span class="line">            r-=cp[n-k+i];   <span class="comment">// 右侧得分</span></span><br><span class="line">            res = max(res,l+r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="对角线遍历-II"><a href="#对角线遍历-II" class="headerlink" title="对角线遍历 II"></a><a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/diagonal-traverse-ii/" target="_blank" rel="noopener">对角线遍历 II</a></h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>给你一个列表 <code>nums</code> ，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 <code>nums</code> 中对角线上的整数。</p>
<p><img src="/2020/04/30/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B186/sample_1_1784.png" alt="11"></p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,4,2,7,5,3,8,6,9]</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]</span><br><span class="line">输出：[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [[1,2,3],[4],[5,6,7],[8],[9,10,11]]</span><br><span class="line">输出：[1,4,2,5,3,8,6,9,7,10,11]</span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>元素的访问顺序是按照位置(0,0)的<code>bfs</code>遍历来的，并且下面的元素优先。因此按照<code>bfs</code>的思路遍历即可。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dir =&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">deque</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; que;</span><br><span class="line">        que.push_back(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        res.push_back(nums[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> m = nums.size();</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> tm = que.size();</span><br><span class="line">            <span class="keyword">while</span>(tm--)&#123;</span><br><span class="line">                <span class="keyword">auto</span> p = que.front();</span><br><span class="line">                que.pop_front();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = p.first+dir[i][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y = p.second+dir[i][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(x&gt;=m || y&gt;=nums[x].size() || nums[x][y]==<span class="number">0</span>)&#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line">                    que.push_back(&#123;x,y&#125;);</span><br><span class="line">                    res.push_back(nums[x][y]);</span><br><span class="line">                    nums[x][y] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="带限制的子序列和"><a href="#带限制的子序列和" class="headerlink" title="带限制的子序列和"></a><a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/constrained-subsequence-sum/" target="_blank" rel="noopener">带限制的子序列和</a></h3><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回 <strong>非空</strong> 子序列元素和的最大值，子序列需要满足：子序列中每两个 <strong>相邻</strong> 的整数 <code>nums[i]</code> 和 <code>nums[j]</code> ，它们在原数组中的下标 <code>i</code> 和 <code>j</code> 满足 <code>i &lt; j</code> 且 <code>j - i &lt;= k</code> 。</p>
<p>数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [10,2,-10,5,20], k &#x3D; 2</span><br><span class="line">输出：37</span><br><span class="line">解释：子序列为 [10, 2, 5, 20] 。</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [-1,-2,-3], k &#x3D; 1</span><br><span class="line">输出：-1</span><br><span class="line">解释：子序列必须是非空的，所以我们选择最大的数字。</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [10,-2,-10,-5,20], k &#x3D; 2</span><br><span class="line">输出：23</span><br><span class="line">解释：子序列为 [10, -2, -5, 20] 。</span><br></pre></td></tr></table></figure>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>设前$n$个元素的结果为$dp[n]$（包含第$n$个元素）,思考以下$dp[n]$与$dp[1],dp[2]…dp[n-1]$之间的递推关系。</p>
<p>明显可以得到：$dp[n] = max(dp[n-k]…dp[n-1])+nums[n-1]$。因此通过朴素的$dp$思路可以求得结果。但是提交会超时，那么，如何优化呢？</p>
<p>由上面的$dp$的递推方程可以看到，只要能快速获得前$k$个元素的最大值,那么$dp[n]$就可以很快的得到。</p>
<p>获得一个区间内的最大元素可以使用<code>线段树</code>来实现。</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegTree</span>&#123;</span>	<span class="comment">// 线段树</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree;</span><br><span class="line">    SegTree(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        t=nums;</span><br><span class="line">        <span class="keyword">int</span> n =t.<span class="built_in">size</span>();</span><br><span class="line">        tree=<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span> * n+<span class="number">1</span>,<span class="number">-1e5</span><span class="number">-1</span>);</span><br><span class="line">        buildTree(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = t.<span class="built_in">size</span>();</span><br><span class="line">        updateTree(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,i,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n =t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> query(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e,<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;e) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(s==e)&#123;</span><br><span class="line">            tree[node]=t[s];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (s+e)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> l_n = <span class="number">2</span> * node +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r_n = <span class="number">2</span> * node +<span class="number">2</span>;</span><br><span class="line">        buildTree(s,m,l_n);</span><br><span class="line">        buildTree(m+<span class="number">1</span>,e,r_n);</span><br><span class="line">        tree[node]= <span class="built_in">max</span>(tree[l_n],tree[r_n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateTree</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e,<span class="keyword">int</span> node,<span class="keyword">int</span> idx,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==e)&#123;</span><br><span class="line">            tree[node]=<span class="built_in">max</span>(tree[node],val);</span><br><span class="line">            t[idx]=val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (s+e)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> l_n=<span class="number">2</span>*node+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r_n = <span class="number">2</span> * node+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx&gt;=s &amp;&amp; idx &lt;= m)&#123;</span><br><span class="line">            updateTree(s,m,l_n,idx,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            updateTree(m+<span class="number">1</span>,e,r_n,idx,val);</span><br><span class="line">        &#125;</span><br><span class="line">        tree[node]= <span class="built_in">max</span>(tree[l_n],tree[r_n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e,<span class="keyword">int</span> node,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;s||l&gt;e) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s&gt;=l&amp;&amp;e&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">return</span> tree[node];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (s+e)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> l_n = <span class="number">2</span> * node +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r_n = <span class="number">2</span> * node +<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> ls = query(s, m,l_n,l, r);</span><br><span class="line">        <span class="keyword">int</span> rs = query(m+<span class="number">1</span>,e,r_n,l,r);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ls,rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">constrainedSubsetSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> tree = SegTree(nums);</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        tree.update(<span class="number">0</span>,nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="built_in">max</span>(i-k,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> item = <span class="built_in">max</span>(<span class="number">0</span>,tree.sumRange(l,i<span class="number">-1</span>));</span><br><span class="line">            res = <span class="built_in">max</span>(res,item+nums[i]);</span><br><span class="line">            tree.update(i,item+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>题目本身难度不算太大，但自己对线段树的写法还不是特别熟练，因此在第4题上遇到了一点问题。第3题也超时了一次，总的来说是做题要保持做题的手感，不然很难写出bug free的代码。</p>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣周赛190</title>
    <url>/2020/05/24/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B190/</url>
    <content><![CDATA[<p>这篇文章主要记录一下第190场周赛的题目解答。以下是四个题目:</p>
<ol>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/" target="_blank" rel="noopener">检查单词是否为句中其他单词的前缀</a>: 3分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/maximum-number-of-vowels-in-a-substring-of-given-length/" target="_blank" rel="noopener">定长子串中元音的最大数目</a>: 4分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/pseudo-palindromic-paths-in-a-binary-tree/" target="_blank" rel="noopener">二叉树中的伪回文路径</a>: 5分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/max-dot-product-of-two-subsequences/" target="_blank" rel="noopener">两个子序列的最大点积</a>: 6分</li>
</ol>
<a id="more"></a>
<h3 id="检查单词是否为句中其他单词的前缀"><a href="#检查单词是否为句中其他单词的前缀" class="headerlink" title="检查单词是否为句中其他单词的前缀"></a><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/" target="_blank" rel="noopener">检查单词是否为句中其他单词的前缀</a></h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给你一个字符串 <code>sentence</code> 作为句子并指定检索词为 <code>searchWord</code> ，其中句子由若干用 <strong>单个空格</strong> 分隔的单词组成。</p>
<p>请你检查检索词 <code>searchWord</code> 是否为句子 <code>sentence</code> 中任意单词的前缀。</p>
<ul>
<li>如果 <code>searchWord</code> 是某一个单词的前缀，则返回句子 <code>sentence</code> 中该单词所对应的下标（<strong>下标从 1 开始</strong>）。</li>
<li>如果 <code>searchWord</code> 是多个单词的前缀，则返回匹配的第一个单词的下标（<strong>最小下标</strong>）。</li>
<li>如果 <code>searchWord</code> 不是任何单词的前缀，则返回 <strong>-1</strong> 。</li>
</ul>
<p>字符串 <code>S</code> 的 「前缀」是 <code>S</code> 的任何前导连续子字符串。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：sentence &#x3D; &quot;i love eating burger&quot;, searchWord &#x3D; &quot;burg&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：&quot;burg&quot; 是 &quot;burger&quot; 的前缀，而 &quot;burger&quot; 是句子中第 4 个单词。</span><br><span class="line"></span><br><span class="line">输入：sentence &#x3D; &quot;this problem is an easy problem&quot;, searchWord &#x3D; &quot;pro&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：&quot;pro&quot; 是 &quot;problem&quot; 的前缀，而 &quot;problem&quot; 是句子中第 2 个也是第 6 个单词，但是应该返回最小下标 2 。</span><br><span class="line"></span><br><span class="line">输入：sentence &#x3D; &quot;i am tired&quot;, searchWord &#x3D; &quot;you&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：&quot;you&quot; 不是句子中任何单词的前缀。</span><br><span class="line"></span><br><span class="line">输入：sentence &#x3D; &quot;i use triple pillow&quot;, searchWord &#x3D; &quot;pill&quot;</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">输入：sentence &#x3D; &quot;hello from the other side&quot;, searchWord &#x3D; &quot;they&quot;</span><br><span class="line">输出：-1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; sentence.length &lt;&#x3D; 100</span><br><span class="line">1 &lt;&#x3D; searchWord.length &lt;&#x3D; 10</span><br><span class="line">sentence 由小写英文字母和空格组成。</span><br><span class="line">searchWord 由小写英文字母组成。</span><br><span class="line">前缀就是紧密附着于词根的语素，中间不能插入其它成分，并且它的位置是固定的——-位于词根之前。（引用自 前缀_百度百科 ）</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>按照题目要求模拟：</p>
<ol>
<li>获取字符串中的单词</li>
<li>判断<code>serachWord</code>是不是单词的前缀</li>
</ol>
<h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">isPrefixOfWord</span><span class="params">(<span class="built_in">string</span> sentence, <span class="built_in">string</span> searchWord)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> temp;	<span class="comment">// 单词</span></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">1</span>;	<span class="comment">// 单词的下标</span></span><br><span class="line">        <span class="keyword">int</span> n = sentence.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==n || sentence[i]==<span class="string">' '</span>)&#123;	<span class="comment">// 一个新单词产生</span></span><br><span class="line">                <span class="keyword">if</span>(temp==<span class="string">""</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 判断searchWord是不是单词的前缀</span></span><br><span class="line">                <span class="keyword">if</span>(temp.substr(<span class="number">0</span>,searchWord.<span class="built_in">size</span>()) == searchWord)&#123;	</span><br><span class="line">                    <span class="keyword">return</span> idx;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = <span class="string">""</span>;</span><br><span class="line">                idx+=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp+=sentence[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="定长子串中元音的最大数目"><a href="#定长子串中元音的最大数目" class="headerlink" title="定长子串中元音的最大数目"></a><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/maximum-number-of-vowels-in-a-substring-of-given-length/" target="_blank" rel="noopener">定长子串中元音的最大数目</a></h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>给你字符串 <code>s</code> 和整数 <code>k</code> 。</p>
<p>请返回字符串 <code>s</code> 中长度为 <code>k</code> 的单个子字符串中可能包含的最大元音字母数。</p>
<p>英文中的 <strong>元音字母</strong> 为（<code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>）。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abciiidef&quot;, k &#x3D; 3</span><br><span class="line">输出：3</span><br><span class="line">解释：子字符串 &quot;iii&quot; 包含 3 个元音字母。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aeiou&quot;, k &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line">解释：任意长度为 2 的子字符串都包含 2 个元音字母。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;leetcode&quot;, k &#x3D; 3</span><br><span class="line">输出：2</span><br><span class="line">解释：&quot;lee&quot;、&quot;eet&quot; 和 &quot;ode&quot; 都包含 2 个元音字母。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;rhythms&quot;, k &#x3D; 4</span><br><span class="line">输出：0</span><br><span class="line">解释：字符串 s 中不含任何元音字母。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;tryhard&quot;, k &#x3D; 4</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; s.length &lt;&#x3D; 10^5</span><br><span class="line">s 由小写英文字母组成</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; s.length</span><br></pre></td></tr></table></figure>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><code>k</code>是窗口的大小，用滑动窗口来模拟即可。</p>
<h4 id="实现示例-1"><a href="#实现示例-1" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxVowels</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;	<span class="comment">// 保存窗口内中的元音字符个数</span></span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:<span class="string">"aeiou"</span>)&#123;</span><br><span class="line">            t.insert(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cnt+=t.count(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=k)&#123;	<span class="comment">// 弹出窗口的队尾</span></span><br><span class="line">                cnt-=t.count(s[i-k]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=(k<span class="number">-1</span>))&#123;	<span class="comment">// 更新res</span></span><br><span class="line">                res = <span class="built_in">max</span>(res,cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树中的伪回文路径"><a href="#二叉树中的伪回文路径" class="headerlink" title="二叉树中的伪回文路径"></a><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/pseudo-palindromic-paths-in-a-binary-tree/" target="_blank" rel="noopener">二叉树中的伪回文路径</a></h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「<strong>伪回文</strong>」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。</p>
<p>请你返回从根到叶子节点的所有路径中 <strong>伪回文</strong> 路径的数目。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p><img src="/2020/05/24/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B190/palindromic_paths_1.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,null,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span> </span><br><span class="line">解释：上图为给定的二叉树。总共有 <span class="number">3</span> 条从根到叶子的路径：红色路径 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>] ，绿色路径 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>] 和路径 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>] 。</span><br><span class="line">     在这些路径中，只有红色和绿色的路径是伪回文路径，因为红色路径 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>] 存在回文排列 [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>] ，绿色路径 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>] 存在回文排列 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 。</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/24/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B190/palindromic_paths_2.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [2,1,1,1,3,null,null,null,null,null,1]</span><br><span class="line">输出：1 </span><br><span class="line">解释：上图为给定二叉树。总共有 3 条从根到叶子的路径：绿色路径 [2,1,1] ，路径 [2,1,3,1] 和路径 [2,1] 。</span><br><span class="line">     这些路径中只有绿色路径是伪回文路径，因为 [2,1,1] 存在回文排列 [1,2,1] 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [9]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>由题意可得:</p>
<ol>
<li>只用判断叶子节点</li>
<li>要保存从根节点到叶子节点的所有值能否构成回文</li>
</ol>
<p>用<code>dfs</code>来遍历整棵树，同时采用前序遍历的方式，而且要保存从根到当前节点中包含的所有数字，当是叶子节点时，判断保存的所有数字能否构成回文字符串。</p>
<p>问:那么到底该怎么判断一个数字集合能否构成回文字符串呢?</p>
<blockquote>
<p>观察得到回文字符串左右两端对称，那么除中间元素以外的所有元素的次数必然是偶数。</p>
<p>因此，如果能构成回文串，那么每种元素的出现次数必然是偶数个或者仅有一种元素出现奇数次。只需求解出现次数为奇数的元素种类的个数。</p>
<p>例如:</p>
<p>1出现5 次，2 出现2次，3出现4次</p>
<p>那么可以构成回文串，因为出现奇数次的元素只有1，因此可以构成。</p>
<p>1出现5 次，2 出现2次，3出现3次</p>
<p>那么不能构成回文串，因为出现奇数次的元素有1，3，因此不能构成。</p>
</blockquote>
<p>问: 是否需要保存每个元素的具体出现次数呢？</p>
<blockquote>
<p>不需要，在上面的讨论中，我们只用到了每个元素出现次数的奇偶性，因此可以用一个二进制数表述。</p>
<p>比如说:</p>
<p>001001011表示</p>
<p>987654321中1，2，4，7出现了奇数，其他出现了偶数次</p>
</blockquote>
<h4 id="实现示例-2"><a href="#实现示例-2" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 求[1,9]中包含奇数个元素的种类数。</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> &amp;mask)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = mask;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            res+=n&amp;<span class="number">1</span>;</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res &lt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> &amp;mask,<span class="keyword">int</span> &amp;res,TreeNode *root)</span></span>&#123;</span><br><span class="line">        mask ^= (<span class="number">1</span>&lt;&lt;(root-&gt;val<span class="number">-1</span>)); <span class="comment">// 当前元素的出现次数+1(奇偶数改变)</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; check(mask))&#123;res+=<span class="number">1</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123; dfs(mask,res,root-&gt;left);&#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123; dfs(mask,res,root-&gt;right);&#125;</span><br><span class="line">        mask ^= (<span class="number">1</span>&lt;&lt;(root-&gt;val<span class="number">-1</span>));	<span class="comment">// 回溯</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pseudoPalindromicPaths</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">        dfs(mask,res,root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最初的写法是用一个数组保存每个元素的出现次数，处理方式基本是相同的，用<code>bitmask</code>应该更省内存，运行速度也更快一些。下面是直接用数组来保存每个元素的出现次数的代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:dp)&#123;</span><br><span class="line">            res += item%<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res&lt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;dp,<span class="keyword">int</span> &amp;res,TreeNode *root)</span></span>&#123;</span><br><span class="line">        dp[root-&gt;val]+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; check(dp))&#123;</span><br><span class="line">            res+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            dfs(dp,res,root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            dfs(dp,res,root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[root-&gt;val]-=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pseudoPalindromicPaths</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">10</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dfs(dp,res,root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="两个子序列的最大点积"><a href="#两个子序列的最大点积" class="headerlink" title="两个子序列的最大点积"></a><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/max-dot-product-of-two-subsequences/" target="_blank" rel="noopener">两个子序列的最大点积</a></h3><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>给你两个数组 <code>nums1</code> 和 <code>nums2</code> 。</p>
<p>请你返回 <code>nums1</code> 和 <code>nums2</code> 中两个长度相同的 <strong>非空</strong> 子序列的最大点积。</p>
<p>数组的非空子序列是通过删除原数组中某些元素（可能一个也不删除）后剩余数字组成的序列，但不能改变数字间相对顺序。比方说，<code>[2,3,5]</code> 是 <code>[1,2,3,4,5]</code> 的一个子序列而 <code>[1,5,3]</code> 不是。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums1 &#x3D; [2,1,-2,5], nums2 &#x3D; [3,0,-6]</span><br><span class="line">输出：18</span><br><span class="line">解释：从 nums1 中得到子序列 [2,-2] ，从 nums2 中得到子序列 [3,-6] 。</span><br><span class="line">它们的点积为 (2*3 + (-2)*(-6)) &#x3D; 18 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums1 &#x3D; [3,-2], nums2 &#x3D; [2,-6,7]</span><br><span class="line">输出：21</span><br><span class="line">解释：从 nums1 中得到子序列 [3] ，从 nums2 中得到子序列 [7] 。</span><br><span class="line">它们的点积为 (3*7) &#x3D; 21 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums1 &#x3D; [-1,-1], nums2 &#x3D; [1,1]</span><br><span class="line">输出：-1</span><br><span class="line">解释：从 nums1 中得到子序列 [-1] ，从 nums2 中得到子序列 [1] 。</span><br><span class="line">它们的点积为 -1 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; nums1.length, nums2.length &lt;&#x3D; 500</span><br><span class="line">-1000 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>动态规划思想，一旦发现题目中的操作有分步进行的，可以考虑<code>dp</code>。</p>
<p><code>dp</code>的状态如何定义呢?</p>
<blockquote>
<p>明显$dp[i][j]$表示前$i$个<code>nums1</code>元素与前$j$个nums2`元素的最大点积。</p>
</blockquote>
<p><code>dp</code>的状态如何转化呢?</p>
<blockquote>
<p> $dp[i][j] = min(dp[i-1][j-1]+nums1[i] * nums2[j],dp[i][j-1],dp[i-1][j])$</p>
</blockquote>
<p>初始状态如何呢?</p>
<blockquote>
<p>$dp[0][j]=0,dp[i][0]=0$</p>
</blockquote>
<p>明显题意中<code>nums1</code>与<code>nums2</code>中至少都要取一个元素，因此要考虑如果最后<code>dp</code>结果为0时的情形</p>
<h4 id="实现示例-3"><a href="#实现示例-3" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDotProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> NIL = -(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,NIL))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = NIL;</span><br><span class="line">        <span class="keyword">int</span> lm = NIL;</span><br><span class="line">        <span class="keyword">int</span> rmn = -NIL;</span><br><span class="line">        <span class="comment">// 在nums1中与nums2中各选取一个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">            dp[i+<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i]&lt;=<span class="number">0</span>) lm = <span class="built_in">max</span>(lm,nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums2[j]&gt;=<span class="number">0</span>) rmn = <span class="built_in">min</span>(rmn,nums2[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        res = lm*rmn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                dp[i][j] = nums1[i<span class="number">-1</span>] * nums2[j<span class="number">-1</span>]+dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="comment">// cout&lt;&lt;dp[i][j]&lt;&lt;endl;</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j<span class="number">-1</span>],dp[i][j]);</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j]);</span><br><span class="line">                <span class="comment">// cout&lt;&lt;dp[i][j]&lt;&lt;endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[m][n]) <span class="keyword">return</span> dp[m][n];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>题目难度小，属于手速场，好多高手很快AK了。自己在第三题的回溯上出了点bug，花了几分钟调试了一下。第四题难度不大，但是在处理初始条件上也花了时间来调试。总的来说，动态规划的题目思路找对后要仔细地揣摩初始条件以及边界条件。</p>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣周赛188</title>
    <url>/2020/05/10/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B188/</url>
    <content><![CDATA[<p>这篇文章主要记录一下第188场周赛的题目解答。以下是四个题目：</p>
<ol>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/build-an-array-with-stack-operations/" target="_blank" rel="noopener">用栈操作构建数组</a>: 3分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/" target="_blank" rel="noopener">形成两个异或相等数组的三元组数目</a>: 4分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/minimum-time-to-collect-all-apples-in-a-tree/" target="_blank" rel="noopener">收集树上所有苹果的最少时间</a>: 5分</li>
<li><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/number-of-ways-of-cutting-a-pizza/" target="_blank" rel="noopener">切披萨的方案数</a>: 7分</li>
</ol>
<a id="more"></a>
<h3 id="用栈操作构建数组"><a href="#用栈操作构建数组" class="headerlink" title="用栈操作构建数组"></a><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/build-an-array-with-stack-operations/" target="_blank" rel="noopener">用栈操作构建数组</a></h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给你一个目标数组 <code>target</code> 和一个整数 <code>n</code>。每次迭代，需要从 <code>list = {1,2,3..., n}</code> 中依序读取一个数字。</p>
<p>请使用下述操作来构建目标数组 <code>target</code> ：</p>
<ul>
<li><strong>Push</strong>：从 <code>list</code> 中读取一个新元素， 并将其推入数组中。</li>
<li><strong>Pop</strong>：删除数组中的最后一个元素。</li>
<li>如果目标数组构建完成，就停止读取更多元素。</li>
</ul>
<p>题目数据保证目标数组严格递增，并且只包含 <code>1</code> 到 <code>n</code> 之间的数字。</p>
<p>请返回构建目标数组所用的操作序列。</p>
<p>题目数据保证答案是唯一的。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; [1,3], n &#x3D; 3</span><br><span class="line">输出：[&quot;Push&quot;,&quot;Push&quot;,&quot;Pop&quot;,&quot;Push&quot;]</span><br><span class="line">解释： </span><br><span class="line">读取 1 并自动推入数组 -&gt; [1]</span><br><span class="line">读取 2 并自动推入数组，然后删除它 -&gt; [1]</span><br><span class="line">读取 3 并自动推入数组 -&gt; [1,3]</span><br><span class="line"></span><br><span class="line">输入：target &#x3D; [1,2,3], n &#x3D; 3</span><br><span class="line">输出：[&quot;Push&quot;,&quot;Push&quot;,&quot;Push&quot;]</span><br><span class="line"></span><br><span class="line">输入：target &#x3D; [1,2], n &#x3D; 4</span><br><span class="line">输出：[&quot;Push&quot;,&quot;Push&quot;]</span><br><span class="line">解释：只需要读取前 2 个数字就可以停止。</span><br><span class="line"></span><br><span class="line">输入：target &#x3D; [2,3,4], n &#x3D; 4</span><br><span class="line">输出：[&quot;Push&quot;,&quot;Pop&quot;,&quot;Push&quot;,&quot;Push&quot;,&quot;Push&quot;]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; target.length &lt;&#x3D; 100</span><br><span class="line">1 &lt;&#x3D; target[i] &lt;&#x3D; 100</span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 100</span><br><span class="line">target 是严格递增的</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>从<code>List</code>中拿出元素必须是<code>{1,2,3...n}</code>的顺序，当拿出的元素不是需要的元素时，需要执行<code>Push</code>与<code>Pop</code>两个操作，当是需要的元素时，只执行<code>Push</code>操作，并且考虑下一个要拿出元素。</p>
<h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">buildArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> tn = target.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> item = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tn;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(item!=target[i])&#123;	<span class="comment">// 加入的值不是target[i]</span></span><br><span class="line">                res.push_back(<span class="string">"Push"</span>);</span><br><span class="line">                res.push_back(<span class="string">"Pop"</span>);</span><br><span class="line">                item++;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(<span class="string">"Push"</span>);</span><br><span class="line">            item++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="形成两个异或相等数组的三元组数目"><a href="#形成两个异或相等数组的三元组数目" class="headerlink" title="形成两个异或相等数组的三元组数目"></a><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/" target="_blank" rel="noopener">形成两个异或相等数组的三元组数目</a></h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>给你一个整数数组 <code>arr</code> 。</p>
<p>现需要从数组中取三个下标 <code>i</code>、<code>j</code> 和 <code>k</code> ，其中 <code>(0 &lt;= i &lt; j &lt;= k &lt; arr.length)</code> 。</p>
<p><code>a</code> 和 <code>b</code> 定义如下：</p>
<ul>
<li><code>a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]</code></li>
<li><code>b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]</code></li>
</ul>
<p>注意：<strong>^</strong> 表示 <strong>按位异或</strong> 操作。</p>
<p>请返回能够令 <code>a == b</code> 成立的三元组 (<code>i</code>, <code>j</code> , <code>k</code>) 的数目。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [2,3,1,6,7]</span><br><span class="line">输出：4</span><br><span class="line">解释：满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4)</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [1,1,1,1,1]</span><br><span class="line">输出：10</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [2,3]</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [1,3,5,7,9]</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [7,11,12,9,5,2,7,17,22]</span><br><span class="line">输出：8</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; arr.length &lt;&#x3D; 300</span><br><span class="line">1 &lt;&#x3D; arr[i] &lt;&#x3D; 10^8</span><br></pre></td></tr></table></figure>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>暴力枚举即可。</p>
<h4 id="实现示例-1"><a href="#实现示例-1" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                pre ^= nums[j<span class="number">-1</span>];	<span class="comment">// a</span></span><br><span class="line">                <span class="keyword">int</span> bac = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;n;k++)&#123;</span><br><span class="line">                    bac ^= nums[k];		<span class="comment">// b</span></span><br><span class="line">                    <span class="keyword">if</span>(pre == bac) res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="收集树上所有苹果的最少时间"><a href="#收集树上所有苹果的最少时间" class="headerlink" title="收集树上所有苹果的最少时间"></a><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/minimum-time-to-collect-all-apples-in-a-tree/" target="_blank" rel="noopener">收集树上所有苹果的最少时间</a></h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>给你一棵有 <code>n</code> 个节点的无向树，节点编号为 <code>0</code> 到 <code>n-1</code> ，它们中有一些节点有苹果。通过树上的一条边，需要花费 1 秒钟。你从 <strong>节点 0</strong> 出发，请你返回最少需要多少秒，可以收集到所有苹果，并回到节点 0 。</p>
<p>无向树的边由 <code>edges</code> 给出，其中 <code>edges[i] = [fromi, toi]</code> ，表示有一条边连接 <code>from</code> 和 <code>toi</code> 。除此以外，还有一个布尔数组 <code>hasApple</code> ，其中 <code>hasApple[i] = true</code> 代表节点 <code>i</code> 有一个苹果，否则，节点 <code>i</code> 没有苹果。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p><img src="/2020/05/10/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B188/min_time_collect_apple_1.png" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 7, edges &#x3D; [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple &#x3D; [false,false,true,false,true,true,false]</span><br><span class="line">输出：8 </span><br><span class="line">解释：上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/10/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B188/min_time_collect_apple_2.png" alt="2"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 7, edges &#x3D; [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple &#x3D; [false,false,true,false,false,true,false]</span><br><span class="line">输出：6</span><br><span class="line">解释：上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 7, edges &#x3D; [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple &#x3D; [false,false,false,false,false,false,false]</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 10^5</span><br><span class="line">edges.length &#x3D;&#x3D; n-1</span><br><span class="line">edges[i].length &#x3D;&#x3D; 2</span><br><span class="line">0 &lt;&#x3D; fromi, toi &lt;&#x3D; n-1</span><br><span class="line">fromi &lt; toi</span><br><span class="line">hasApple.length &#x3D;&#x3D; n</span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>观察到结果中的边都被使用了两次，因此求遍历的边数就可以得到答案。</p>
<p>问一：怎样的方案是最优的方案呢？</p>
<blockquote>
<p>贪心思想：对于某个根节点，如果左子树为空或者左子树中没有苹果，那么，该root到left的这条边不会被包含在结果中，右子树同理</p>
</blockquote>
<p>设结果为<code>set={e1,e2...}</code>,<code>set</code>中元素为边。(下面讨论的是<code>set</code>中的边)</p>
<p>问二: 子树中边的条数与根树中边的条数之间的递推关系是什么?</p>
<blockquote>
<p>设为$f(root),f(left),f(right)$</p>
<p>如果$f(left) != 0$,那么必然有边$(root,left)$,否则一定没有</p>
<p>同理$f(right)!=0$,那么必然有边$(root,right)$</p>
</blockquote>
<p>问三：怎么判断$f(left)$以及$f(right)$是否为0呢？</p>
<blockquote>
<p>已判断$f(left)$为例:</p>
<p>如果以$left$为根的树中含有苹果,那么$f(left)$一定不为0</p>
<p>即判断以$left$为根的树中是否含有苹果，如果有，则$f(left) != 0$,否则$f(left)=0$</p>
<p>那么就转化为求每个点以及子树包含的苹果的个数。</p>
</blockquote>
<p>问四：无向树如何<code>dfs</code>(不重复遍历)?</p>
<blockquote>
<p>对于一个顶点来说，除了父节点外，其他均是该顶点的子节点，因此只需标记父节点就行了。</p>
</blockquote>
<h4 id="实现示例-2"><a href="#实现示例-2" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 求to顶点及其子树包含的苹果个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;dp,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;g,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;ha)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[to] != <span class="number">-1</span>) <span class="keyword">return</span> dp[to];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ha[to]) ans++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:g[to])&#123;</span><br><span class="line">            <span class="keyword">if</span>(item==from) <span class="keyword">continue</span>;</span><br><span class="line">            ans+=dfs(to,item,dp,g,ha); <span class="comment">// 递归求子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        dp[to] = ans;</span><br><span class="line">        <span class="keyword">return</span> dp[to];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求to节点及其子树中包含的边数(结果set中的边)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;dp,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;g,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;ha)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[to]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:g[to])&#123;</span><br><span class="line">            <span class="keyword">if</span>(item==from) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[item]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ans +=<span class="number">1</span>+dfs2(to,item,dp,g,ha);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTime</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; hasApple)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">g</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; vis;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:edges)&#123;	<span class="comment">// 建立连接表</span></span><br><span class="line">            g[item[<span class="number">0</span>]].push_back(item[<span class="number">1</span>]);</span><br><span class="line">            g[item[<span class="number">1</span>]].push_back(item[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        dfs(<span class="number">-1</span>,<span class="number">0</span>,dp,g,hasApple);</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;n;i++) cout&lt;&lt;dp[i]&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * dfs2(<span class="number">-1</span>,<span class="number">0</span>,dp,g,hasApple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该题也有其他的实现方法，详情可以看看题目的题解部分。</p>
<h3 id="切披萨的方案数"><a href="#切披萨的方案数" class="headerlink" title="切披萨的方案数"></a><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/number-of-ways-of-cutting-a-pizza/" target="_blank" rel="noopener">切披萨的方案数</a></h3><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>给你一个 <code>rows x cols</code> 大小的矩形披萨和一个整数 <code>k</code> ，矩形包含两种字符： <code>&#39;A&#39;</code> （表示苹果）和 <code>&#39;.&#39;</code> （表示空白格子）。你需要切披萨 <code>k-1</code> 次，得到 <code>k</code> 块披萨并送给别人。</p>
<p>切披萨的每一刀，先要选择是向垂直还是水平方向切，再在矩形的边界上选一个切的位置，将披萨一分为二。如果垂直地切披萨，那么需要把左边的部分送给一个人，如果水平地切，那么需要把上面的部分送给一个人。在切完最后一刀后，需要把剩下来的一块送给最后一个人。</p>
<p>请你返回确保每一块披萨包含 <strong>至少</strong> 一个苹果的切披萨方案数。由于答案可能是个很大的数字，请你返回它对 10^9 + 7 取余的结果。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p><img src="/2020/05/10/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B188/ways_to_cut_apple_1.png" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：pizza &#x3D; [&quot;A..&quot;,&quot;AAA&quot;,&quot;...&quot;], k &#x3D; 3</span><br><span class="line">输出：3 </span><br><span class="line">解释：上图展示了三种切披萨的方案。注意每一块披萨都至少包含一个苹果。</span><br><span class="line"></span><br><span class="line">输入：pizza &#x3D; [&quot;A..&quot;,&quot;AA.&quot;,&quot;...&quot;], k &#x3D; 3</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：pizza &#x3D; [&quot;A..&quot;,&quot;A..&quot;,&quot;...&quot;], k &#x3D; 1</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; rows, cols &lt;&#x3D; 50</span><br><span class="line">rows &#x3D;&#x3D; pizza.length</span><br><span class="line">cols &#x3D;&#x3D; pizza[i].length</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; 10</span><br><span class="line">pizza 只包含字符 &#39;A&#39; 和 &#39;.&#39; 。</span><br></pre></td></tr></table></figure>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>关键词有逐步分割，逐步选择。联想到<code>DP</code>。</p>
<p>设要求的值为$f(m,n,k)$,表示有$m$行，$n$列,分割成$k$段的方案数。</p>
<p>问一：$f(m,n,k)$与$f(..,..,k-1)$有何关系?</p>
<blockquote>
<p>明显，</p>
<p>如果能在行上切一刀时,$f(m,n,k)$与$f(i,n,k-1)$$(0 \le i &lt; m)$有关</p>
<p>同理如果能在列上切一刀时，$f(m,n,k)$与$f(m,j,k-1)$$(0 \le j &lt; m)$有关</p>
</blockquote>
<p>问二：怎么判断在行上的一刀或者在列上的一刀是否合理？</p>
<blockquote>
<p>切出去的披萨是否含有苹果，含有的话，这一刀合理</p>
</blockquote>
<h4 id="实现示例-3"><a href="#实现示例-3" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ways</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; pizza, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = pizza.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = pizza[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="comment">// 是否要采取同下面代码中的上下翻转，左右翻转操作取决与你的DP状态表示方法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;	<span class="comment">// 左右翻转</span></span><br><span class="line">            reverse(pizza[i].<span class="built_in">begin</span>(),pizza[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(m/<span class="number">2</span>);i++)&#123;	<span class="comment">// 上下翻转</span></span><br><span class="line">            <span class="built_in">string</span> temp =pizza[i];</span><br><span class="line">            pizza[i] = pizza[m<span class="number">-1</span>-i];</span><br><span class="line">            pizza[m<span class="number">-1</span>-i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">ts</span><span class="params">(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(pizza[i<span class="number">-1</span>][j<span class="number">-1</span>]==<span class="string">'A'</span>) temp++;</span><br><span class="line">                ts[i][j] = ts[i<span class="number">-1</span>][j]+ts[i][j<span class="number">-1</span>]-ts[i<span class="number">-1</span>][j<span class="number">-1</span>]+temp;	<span class="comment">// 二维前缀和</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k+<span class="number">1</span>,<span class="number">0</span>)))</span></span>;</span><br><span class="line">        <span class="comment">// DP初始条件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>) dp[i][j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=k;p++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> ki=<span class="number">1</span>;ki&lt;i;ki++)&#123; <span class="comment">// dp[i][j][p]与dp[ki][j][p-1]</span></span><br><span class="line">                        <span class="keyword">int</span> temp = ts[i][j]-ts[ki][j];</span><br><span class="line">                        <span class="keyword">if</span>(temp==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        dp[i][j][p] = (dp[i][j][p]+dp[ki][j][p<span class="number">-1</span>])%MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> kj=<span class="number">1</span>;kj&lt;j;kj++)&#123;	<span class="comment">// dp[i][j][p]与dp[i][kj][p-1]</span></span><br><span class="line">                        <span class="keyword">int</span> temp = ts[i][j]-ts[i][kj];</span><br><span class="line">                        <span class="comment">// cout&lt;&lt;temp&lt;&lt;endl;</span></span><br><span class="line">                        <span class="keyword">if</span>(temp==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        dp[i][j][p] = (dp[i][j][p]+dp[i][kj][p<span class="number">-1</span>])%MOD;</span><br><span class="line">                        <span class="comment">// cout&lt;&lt;dp[i][j][k]&lt;&lt;endl;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(ts[i][j])&#123;	<span class="comment">// 整个分给一个人</span></span><br><span class="line">                        dp[i][j][p] = (dp[i][j][p]+dp[<span class="number">0</span>][<span class="number">0</span>][p<span class="number">-1</span>])%MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;dp[m][n][1]&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> dp[m][n][k]%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说，题目难度不算很大，前两题直接模拟或者暴力枚举即可。</p>
<p>第三题卡了一会儿，不是非常熟悉无向树的dfs写法，写得有点慢。</p>
<p>第4题记得<code>codeforces</code>上做过一个类似的<code>DP</code>题，调试花了一会儿，还是初始条件的设置容易出问题。</p>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣每日打卡20200506</title>
    <url>/2020/05/06/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A120200506/</url>
    <content><![CDATA[<p>这篇文章是关于<code>力扣每日打卡</code>的题目的一点点记录。</p>
<p>题目: <a href="https://leetcode-cn.com/problems/minimum-cost-for-tickets/" target="_blank" rel="noopener">最低票价</a></p>
<p>难度：中</p>
<a id="more"></a>
<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。</p>
<p>火车票有三种不同的销售方式：</p>
<p>一张为期一天的通行证售价为 costs[0] 美元；<br>一张为期七天的通行证售价为 costs[1] 美元；<br>一张为期三十天的通行证售价为 costs[2] 美元。<br>通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。</p>
<p>返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：days &#x3D; [1,4,6,7,8,20], costs &#x3D; [2,7,15]</span><br><span class="line">输出：11</span><br><span class="line">解释： </span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：</span><br><span class="line">在第 1 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 1 天生效。</span><br><span class="line">在第 3 天，你花了 costs[1] &#x3D; $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。</span><br><span class="line">在第 20 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 20 天生效。</span><br><span class="line">你总共花了 $11，并完成了你计划的每一天旅行。</span><br><span class="line"></span><br><span class="line">输入：days &#x3D; [1,2,3,4,5,6,7,8,9,10,30,31], costs &#x3D; [2,7,15]</span><br><span class="line">输出：17</span><br><span class="line">解释：</span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： </span><br><span class="line">在第 1 天，你花了 costs[2] &#x3D; $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。</span><br><span class="line">在第 31 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 </span><br><span class="line">你总共花了 $17，并完成了你计划的每一天旅行。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1. 1 &lt;&#x3D; days.length &lt;&#x3D; 365</span><br><span class="line">2. 1 &lt;&#x3D; days[i] &lt;&#x3D; 365</span><br><span class="line">3. days 按顺序严格递增</span><br><span class="line">4. costs.length &#x3D;&#x3D; 3</span><br><span class="line">5. 1 &lt;&#x3D; costs[i] &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><code>days</code>数组是严格递增的，那么在某个位置<code>i</code>（下标）,其天数信息为<code>day[i]</code>，有三种可选的计划方案:</p>
<ol>
<li>选取<code>为期1天</code>的通行证，那么在<code>[days[i],days[i]+1-1]</code>中的旅游不需要通行证，直接跳转到<strong>大于等于</strong><code>day[i]+1</code>处，设此处小标为<code>j</code>，那么有关系<code>dp[i] = dp[i]+1天通行证的代价</code></li>
<li>选取<code>为期7天</code>的通行证，同理在<code>[days[i],days[i]+7-1]</code>中的旅游不需要通行证,直接跳转到<strong>大于等于</strong><code>day[i]+7</code>处，设此处小标为<code>j</code>，那么有关系<code>dp[i] = dp[i]+7天通行证的代价</code></li>
<li>选取<code>为期30天</code>的通行证,同理</li>
</ol>
<p>只需取上面三种可能中的较小值即可。</p>
<p>初始条件设置当位置<code>i</code>为<code>n</code>（n为<code>days</code>的元素个数）时，代价为0。</p>
<p>按照上面的分析可以得出要求的结果为<code>dp[0]</code></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;days,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;costs,<span class="keyword">int</span> idx,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;dir,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = days.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(dp[idx] != <span class="number">-1</span>) <span class="keyword">return</span> dp[idx];   <span class="comment">// memo</span></span><br><span class="line">        dp[idx] = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tcost = costs[i];   <span class="comment">// 当前选取不同类别通行证的代价</span></span><br><span class="line">            <span class="keyword">int</span> rangeR = days[idx]+dir[i]<span class="number">-1</span>; <span class="comment">// 通行证的覆盖范围[idx,rangeR]</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 二分查找</span></span><br><span class="line">            <span class="comment">// 通行证未覆盖的最小下标</span></span><br><span class="line">            <span class="keyword">int</span> l = upper_bound(days.<span class="built_in">begin</span>(),days.<span class="built_in">end</span>(),rangeR)-days.<span class="built_in">begin</span>();</span><br><span class="line">            dp[idx] = <span class="built_in">min</span>(dp[idx],dfs(days,costs,l,dir,dp)+tcost);  <span class="comment">// 状态转移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; days, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dir = &#123;<span class="number">1</span>,<span class="number">7</span>,<span class="number">30</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = days.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        dp[n] = <span class="number">0</span>;  <span class="comment">// 初始化条件</span></span><br><span class="line">        <span class="keyword">return</span> dfs(days,costs,idx,dir,dp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>主方向：<code>dp</code></li>
<li>状态如何转移，上一或者下一状态的位置如何确定</li>
<li>初始条件是什么</li>
</ol>
<p>官方题解以及其他用户的题解也是相当的不错，都可以用自己熟悉的语言实现一下看看。</p>
<p>最后附上一首词:</p>
<center>青杏儿</center>

<center>[金]赵秉文</center>

<center>风雨替花愁。风雨罢，花也应休。劝君莫惜花前醉，今年花谢，明年花谢，白了人头。</center>

<center>乘兴两三瓯。拣溪山好处追游。但教有酒身无事，有花也好，无花也好，选甚春秋。</center>

<center></center>]]></content>
      <categories>
        <category>力扣打卡</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>力扣</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣每日打卡20200507</title>
    <url>/2020/05/07/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A120200507/</url>
    <content><![CDATA[<p>这篇文章是关于<code>力扣每日打卡</code>的题目的一点点记录。</p>
<p>题目: <a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">另一个树的子树</a></p>
<p>难度：易</p>
<a id="more"></a>
<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定的树 s:</span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line"> 给定的树t:</span><br><span class="line">   4 </span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line"> 返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</span><br><span class="line"> </span><br><span class="line"> 给定的树 s：</span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line">    &#x2F;</span><br><span class="line">   0</span><br><span class="line">给定的树 t：</span><br><span class="line">   4</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line"> 返回 false。</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><code>t</code>要是<code>s</code>的子树，只能是下面的三种情形:</p>
<ol>
<li><code>t</code>是<code>s</code>的左子树的子树</li>
<li><code>t</code>是<code>s</code>的右子树的子树</li>
<li><code>t</code>与<code>s</code>相同</li>
</ol>
<p>上面1、2两点可以通过递归调用<code>isSubTree</code>实现，第3点可以通过写一个辅助函数<code>is_same</code>实现，同时<code>is_same</code>函数同样是递归结构。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_same</span><span class="params">(TreeNode *s,TreeNode *t)</span></span>&#123;  <span class="comment">// 相同的树结构</span></span><br><span class="line">        <span class="keyword">if</span>(s==t &amp;&amp; s==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s-&gt;val != t-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> is_same(s-&gt;left,t-&gt;left) &amp;&amp; is_same(s-&gt;right,t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(isSubtree(s-&gt;left,t)) <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">// t是s的左子树的子树</span></span><br><span class="line">        <span class="keyword">if</span>(isSubtree(s-&gt;right,t)) <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">// t是s的右子树的子树</span></span><br><span class="line">        <span class="keyword">return</span> is_same(s,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>要点是递归</li>
<li>分析递归基</li>
</ol>
<p>总的来说该题难度很小，只需要细致地分析其递归基就能很快地写出<code>bug free</code>的代码。</p>
]]></content>
      <categories>
        <category>力扣打卡</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>力扣</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣周赛187</title>
    <url>/2020/05/06/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B187/</url>
    <content><![CDATA[<p>这篇文章主要记录一下第187场周赛的题目解答。以下是四个题目：</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/destination-city/" target="_blank" rel="noopener">旅行终点站</a>: 3分</li>
<li><a href="https://leetcode-cn.com/problems/check-if-all-1s-are-at-least-length-k-places-away/" target="_blank" rel="noopener">是否所有1都至少相隔k个元素</a>: 4分</li>
<li><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" target="_blank" rel="noopener">绝对差不超过限制的最长连续子数组</a>: 5分</li>
<li><a href="https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/" target="_blank" rel="noopener">有序矩阵中的第 k 个最小数组和</a>: 7分</li>
</ol>
<a id="more"></a>
<h3 id="旅行终点站"><a href="#旅行终点站" class="headerlink" title="旅行终点站"></a><a href="https://leetcode-cn.com/problems/destination-city/" target="_blank" rel="noopener">旅行终点站</a></h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。</p>
<p>题目数据保证线路图会形成一条不存在循环的线路，因此只会有一个旅行终点站。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：paths &#x3D; [[&quot;London&quot;,&quot;New York&quot;],[&quot;New York&quot;,&quot;Lima&quot;],[&quot;Lima&quot;,&quot;Sao Paulo&quot;]]</span><br><span class="line">输出：&quot;Sao Paulo&quot; </span><br><span class="line">解释：从 &quot;London&quot; 出发，最后抵达终点站 &quot;Sao Paulo&quot; 。本次旅行的路线是 &quot;London&quot; -&gt; &quot;New York&quot; -&gt; &quot;Lima&quot; -&gt; &quot;Sao Paulo&quot; 。</span><br><span class="line"></span><br><span class="line">输入：paths &#x3D; [[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;,&quot;B&quot;],[&quot;C&quot;,&quot;A&quot;]]</span><br><span class="line">输出：&quot;A&quot;</span><br><span class="line">解释：所有可能的线路是：</span><br><span class="line">&quot;D&quot; -&gt; &quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;A&quot;. </span><br><span class="line">显然，旅行终点站是 &quot;A&quot; 。</span><br><span class="line"></span><br><span class="line">输入：paths &#x3D; [[&quot;A&quot;,&quot;Z&quot;]]</span><br><span class="line">输出：&quot;Z&quot;</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; paths.length &lt;&#x3D; 100</span><br><span class="line">paths[i].length &#x3D;&#x3D; 2</span><br><span class="line">1 &lt;&#x3D; cityAi.length, cityBi.length &lt;&#x3D; 10</span><br><span class="line">cityAi !&#x3D; cityBi</span><br><span class="line">所有字符串均由大小写英文字母和空格字符组成。</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>是一个有向图问题，注意到只有一个终点并且没有环，同时每个节点的<code>出度</code>最多为$1$，所以从任意节点出发，沿有向边遍历一定可以到达终点，不妨取$paths[0][0]$或者$paths[0][1]$。</p>
<h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">destCity</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:paths)&#123;</span><br><span class="line">            t[item[<span class="number">0</span>]] = item[<span class="number">1</span>];	<span class="comment">// 建立边</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> res = paths[<span class="number">0</span>][<span class="number">1</span>];	<span class="comment">// 从paths[0][1]出发</span></span><br><span class="line">        <span class="keyword">while</span>(t.<span class="built_in">find</span>(res) != t.<span class="built_in">end</span>())&#123;	<span class="comment">// 存在有向边，则跳转到下一个节点</span></span><br><span class="line">            res = t[res];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="是否所有1都至少相隔k个元素"><a href="#是否所有1都至少相隔k个元素" class="headerlink" title="是否所有1都至少相隔k个元素"></a><a href="https://leetcode-cn.com/problems/check-if-all-1s-are-at-least-length-k-places-away/" target="_blank" rel="noopener">是否所有1都至少相隔k个元素</a></h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>给你一个由若干 <code>0</code> 和 <code>1</code> 组成的数组 <code>nums</code> 以及整数 <code>k</code>。如果所有 <code>1</code> 都至少相隔 <code>k</code> 个元素，则返回 <code>True</code> ；否则，返回 <code>False</code> 。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p><img src="/2020/05/06/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B187/sample_1_1791.png" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,0,0,0,1,0,0,1], k &#x3D; 2</span><br><span class="line">输出：true</span><br><span class="line">解释：每个 1 都至少相隔 2 个元素。</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/06/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B187/sample_2_1791.png" alt="2"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,0,0,1,0,1], k &#x3D; 2</span><br><span class="line">输出：false</span><br><span class="line">解释：第二个 1 和第三个 1 之间只隔了 1 个元素。</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,1,1,1,1], k &#x3D; 0</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [0,1,0,1], k &#x3D; 1</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</span><br><span class="line">0 &lt;&#x3D; k &lt;&#x3D; nums.length</span><br><span class="line">nums[i] 的值为 0 或 1</span><br></pre></td></tr></table></figure>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>只需判断连续的$0$的个数是否都<strong>大于等于</strong>$k$。也即任意连个不相连的$1$的距离都大于$k$。</p>
<h4 id="实现示例-1"><a href="#实现示例-1" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">kLengthApart</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;	<span class="comment">// 连续0的个数</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt &amp;&amp; cnt&lt;k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> cnt&gt;=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="绝对差不超过限制的最长连续子数组"><a href="#绝对差不超过限制的最长连续子数组" class="headerlink" title="绝对差不超过限制的最长连续子数组"></a><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" target="_blank" rel="noopener">绝对差不超过限制的最长连续子数组</a></h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>给你一个整数数组 <code>nums</code>，和一个表示限制的整数 <code>limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 <code>limit</code>。</p>
<p>如果不存在满足条件的子数组，则返回 0 。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [8,2,4,7], limit &#x3D; 4</span><br><span class="line">输出：2 </span><br><span class="line">解释：所有子数组如下：</span><br><span class="line">[8] 最大绝对差 |8-8| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">[8,2] 最大绝对差 |8-2| &#x3D; 6 &gt; 4. </span><br><span class="line">[8,2,4] 最大绝对差 |8-2| &#x3D; 6 &gt; 4.</span><br><span class="line">[8,2,4,7] 最大绝对差 |8-2| &#x3D; 6 &gt; 4.</span><br><span class="line">[2] 最大绝对差 |2-2| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">[2,4] 最大绝对差 |2-4| &#x3D; 2 &lt;&#x3D; 4.</span><br><span class="line">[2,4,7] 最大绝对差 |2-7| &#x3D; 5 &gt; 4.</span><br><span class="line">[4] 最大绝对差 |4-4| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">[4,7] 最大绝对差 |4-7| &#x3D; 3 &lt;&#x3D; 4.</span><br><span class="line">[7] 最大绝对差 |7-7| &#x3D; 0 &lt;&#x3D; 4. </span><br><span class="line">因此，满足题意的最长子数组的长度为 2 。</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [10,1,2,4,7,2], limit &#x3D; 5</span><br><span class="line">输出：4 </span><br><span class="line">解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| &#x3D; 5 &lt;&#x3D; 5 。</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [4,2,2,2,4,4,2,2], limit &#x3D; 0</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</span><br><span class="line">1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9</span><br><span class="line">0 &lt;&#x3D; limit &lt;&#x3D; 10^9</span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>数据范围很大，因此$O(n^2)$的解法是会超时的。考虑滑动窗口(双指针)，窗口中维护所有元素并能快速的得到窗口中元素的最值，考虑用<code>ordered_set</code>，由于元素可能重复因此使用<code>map</code>或者<code>multiset</code>。</p>
<h4 id="实现示例-2"><a href="#实现示例-2" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; t;	<span class="comment">// 元素值 -&gt; 次数</span></span><br><span class="line">        <span class="keyword">int</span> n  = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;	<span class="comment">// 慢指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;	<span class="comment">// 快指针</span></span><br><span class="line">            t[nums[i]]++;</span><br><span class="line">            <span class="keyword">auto</span> ite = t.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">auto</span> mn = ite-&gt;first;</span><br><span class="line">            ite = t.<span class="built_in">end</span>();</span><br><span class="line">            --ite;</span><br><span class="line">            <span class="keyword">auto</span> mx = ite-&gt;first;</span><br><span class="line">            <span class="keyword">if</span>((mx-mn) &lt;= k)&#123;	<span class="comment">// 仍然满足条件</span></span><br><span class="line">                res = <span class="built_in">max</span>(res,i+<span class="number">1</span>-pre);</span><br><span class="line">                <span class="comment">// cout&lt;&lt;1&lt;&lt;": "&lt;&lt;res&lt;&lt;endl;</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;	<span class="comment">// 慢指针前移</span></span><br><span class="line">                <span class="keyword">while</span>(pre&lt;i)&#123;	</span><br><span class="line">                    <span class="comment">// cout&lt;&lt;pre&lt;&lt;endl;</span></span><br><span class="line">                    t[nums[pre]]--;</span><br><span class="line">                    <span class="keyword">if</span>(t[nums[pre]] == <span class="number">0</span>) t.erase(nums[pre]);</span><br><span class="line">                    pre+=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">auto</span> ite = t.<span class="built_in">begin</span>();</span><br><span class="line">                    <span class="keyword">auto</span> tmn = ite-&gt;first;</span><br><span class="line">                    ite = t.<span class="built_in">end</span>();</span><br><span class="line">                    --ite;</span><br><span class="line">                    <span class="keyword">auto</span> tmx = ite-&gt;first;</span><br><span class="line">                    <span class="keyword">if</span>((tmx-tmn)&lt;=k)&#123;	<span class="comment">// 满足条件，停止慢指针前移</span></span><br><span class="line">                        res = <span class="built_in">max</span>(res,i+<span class="number">1</span>-pre);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该题也有其他的实现方法，详情可以看看题目的题解部分。</p>
<h3 id="有序矩阵中的第-k-个最小数组和"><a href="#有序矩阵中的第-k-个最小数组和" class="headerlink" title="有序矩阵中的第 k 个最小数组和"></a><a href="https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/" target="_blank" rel="noopener">有序矩阵中的第 k 个最小数组和</a></h3><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>给你一个 m * n 的矩阵 mat，以及一个整数 k ，矩阵中的每一行都以非递减的顺序排列。</p>
<p>你可以从每一行中选出 1 个元素形成一个数组。返回所有可能数组中的第 k 个 最小 数组和。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：mat &#x3D; [[1,3,11],[2,4,6]], k &#x3D; 5</span><br><span class="line">输出：7</span><br><span class="line">解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：</span><br><span class="line">[1,2], [1,4], [3,2], [3,4], [1,6]。其中第 5 个的和是 7 。  </span><br><span class="line"></span><br><span class="line">输入：mat &#x3D; [[1,3,11],[2,4,6]], k &#x3D; 9</span><br><span class="line">输出：17</span><br><span class="line"></span><br><span class="line">输入：mat &#x3D; [[1,10,10],[1,4,5],[2,3,6]], k &#x3D; 7</span><br><span class="line">输出：9</span><br><span class="line">解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：</span><br><span class="line">[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]。其中第 7 个的和是 9 。 </span><br><span class="line"></span><br><span class="line">输入：mat &#x3D; [[1,1,10],[2,2,9]], k &#x3D; 7</span><br><span class="line">输出：12</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">m &#x3D;&#x3D; mat.length</span><br><span class="line">n &#x3D;&#x3D; mat.length[i]</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 40</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; min(200, n ^ m)</span><br><span class="line">1 &lt;&#x3D; mat[i][j] &lt;&#x3D; 5000</span><br><span class="line">mat[i] 是一个非递减数组</span><br></pre></td></tr></table></figure>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>第$k$小(或大)的元素，考虑用贪心的优先队列。</p>
<p>直观上看当每行取第1个元素时最小，下一个元素必然是某行的元素索引向后移动一位，至于是哪一位，放入优先队列中进行比较可得，同理可得到第$k$小的元素。</p>
<h4 id="实现示例-3"><a href="#实现示例-3" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; que;	<span class="comment">// 总和，索引列表</span></span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vis;</span><br><span class="line">        <span class="keyword">int</span> m = mat.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vis.insert(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m,<span class="number">0</span>));	<span class="comment">// 防止重复遍历</span></span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">int</span> tcnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            tcnt+=mat[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        que.push(&#123;-tcnt,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m,<span class="number">0</span>)&#125;);</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">auto</span> table= p.second;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;	<span class="comment">// 每个下一个元素加入优先队列中</span></span><br><span class="line">                <span class="keyword">int</span> item = table[i];</span><br><span class="line">                <span class="keyword">if</span>((item+<span class="number">1</span>)&gt;=n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">auto</span> temp = table;</span><br><span class="line">                temp[i]++;</span><br><span class="line">                <span class="keyword">if</span>(vis.count(temp)) <span class="keyword">continue</span>;</span><br><span class="line">                vis.insert(temp);</span><br><span class="line">                <span class="keyword">int</span> res = -p.first;</span><br><span class="line">                res+=mat[i][item+<span class="number">1</span>]-mat[i][item];</span><br><span class="line">                res = -res;</span><br><span class="line">                que.push(&#123;res,temp&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -que.top().first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>题解中也有使用<code>二分</code>的写法，这里就不搬运了，感兴趣的可以到该题目的题解处看看。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>抽象能力还是有待提高，要将题目转化成数学表示，再然后是代码实现。滑动窗口问题最近出现较频繁，题目也并不容易，有待进一步的总结，练习。</p>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
</search>
